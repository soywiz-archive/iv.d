/* Written by Ketmar // Invisible Vector <ketmar@ketmar.no-ip.org>
 * Understanding is not required. Only obedience.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
module iv.sdpyutil /*is aliced*/;

import arsd.color;
import arsd.simpledisplay;
import iv.alice;

//version = krc_debug;


// ////////////////////////////////////////////////////////////////////////// //
public bool sdpyHasXShm () {
  static if (UsingSimpledisplayX11) {
    __gshared int xshmAvailable = -1;
    if (xshmAvailable < 0) {
      int i1, i2, i3;
      xshmAvailable = (XQueryExtension(XDisplayConnection.get(), "MIT-SHM", &i1, &i2, &i3) != 0 ? 1 : 0);
    }
    return (xshmAvailable > 0);
  } else {
    return false;
  }
}


// ////////////////////////////////////////////////////////////////////////// //
/// get desktop number for the given window; -1: unknown
public int getWindowDesktop (SimpleWindow sw) {
  static if (UsingSimpledisplayX11) {
    import core.stdc.config;
    if (sw is null || sw.closed) return -1;
    auto dpy = sw.impl.display;
    auto xwin = sw.impl.window;
    auto atomWTF = GetAtom!("_NET_WM_DESKTOP", true)(dpy);
    Atom aType;
    int format;
    c_ulong itemCount;
    c_ulong bytesAfter;
    void* propRes;
    int desktop = -1;
    auto status = XGetWindowProperty(dpy, xwin, atomWTF, 0, 1, /*False*/0, AnyPropertyType, &aType, &format, &itemCount, &bytesAfter, &propRes);
    if (status >= Success) {
      if (propRes !is null) {
        if (itemCount > 0 && format == 32) desktop = *cast(int*)propRes;
        XFree(propRes);
      }
    }
    return desktop;
  } else {
    return -1;
  }
}


// ////////////////////////////////////////////////////////////////////////// //
/// switch to desktop with the given window
public void switchToWindowDesktop(bool doflush=true) (SimpleWindow sw) {
  static if (UsingSimpledisplayX11) {
    if (sw is null || sw.closed) return;
    auto desktop = sw.getWindowDesktop();
    if (desktop < 0) return;
    auto dpy = sw.impl.display;
    XEvent e;
    e.xclient.type = EventType.ClientMessage;
    e.xclient.serial = 0;
    e.xclient.send_event = 1/*True*/;
    e.xclient.message_type = GetAtom!("_NET_CURRENT_DESKTOP", true)(dpy);
    e.xclient.window = RootWindow(dpy, DefaultScreen(dpy));
    e.xclient.format = 32;
    e.xclient.data.l[0] = desktop;
    XSendEvent(dpy, RootWindow(dpy, DefaultScreen(dpy)), false, EventMask.SubstructureRedirectMask|EventMask.SubstructureNotifyMask, &e);
    static if (doflush) flushGui();
  }
}


// ////////////////////////////////////////////////////////////////////////// //
/// switch to the given window
public void switchToWindow(string src="normal") (SimpleWindow sw) if (src == "normal" || src == "pager") {
  static if (UsingSimpledisplayX11) {
    if (sw is null || sw.closed) return;
    switchToWindowDesktop!false(sw);
    auto dpy = sw.impl.display;
    auto xwin = sw.impl.window;
    XEvent e;
    e.xclient.type = EventType.ClientMessage;
    e.xclient.serial = 0;
    e.xclient.send_event = 1/*True*/;
    e.xclient.message_type = GetAtom!("_NET_ACTIVE_WINDOW", true)(dpy);
    e.xclient.window = xwin;
    e.xclient.format = 32;
    static if (src == "pager") {
      e.xclient.data.l[0] = 2; // pretend to be a pager
    } else {
      e.xclient.data.l[0] = 1; // application request
    }
    XSendEvent(dpy, RootWindow(dpy, DefaultScreen(dpy)), false, EventMask.SubstructureRedirectMask|EventMask.SubstructureNotifyMask, &e);
    flushGui();
  }
}


// ////////////////////////////////////////////////////////////////////////// //
/// Get global window coordinates and size. This can be used to show various notifications.
void getWindowRect (SimpleWindow sw, out int x, out int y, out int width, out int height) {
  static if (UsingSimpledisplayX11) {
    if (sw is null || sw.closed) { width = 1; height = 1; return; } // 1: just in case
    Window dummyw;
    //XWindowAttributes xwa;
    //XGetWindowAttributes(dpy, nativeHandle, &xwa);
    //XTranslateCoordinates(dpy, nativeHandle, RootWindow(dpy, DefaultScreen(dpy)), xwa.x, xwa.y, &x, &y, &dummyw);
    XTranslateCoordinates(sw.impl.display, sw.impl.window, RootWindow(sw.impl.display, DefaultScreen(sw.impl.display)), x, y, &x, &y, &dummyw);
    width = sw.width;
    height = sw.height;
  } else {
    assert(0, "iv.sdpyutil: getWindowRect() -- not for windoze yet");
  }
}


// ////////////////////////////////////////////////////////////////////////// //
public void getWorkAreaRect (out int x, out int y, out int width, out int height) {
  static if (UsingSimpledisplayX11) {
    import core.stdc.config;
    width = 800;
    height = 600;
    auto dpy = XDisplayConnection.get;
    if (dpy is null) return;
    auto root = RootWindow(dpy, DefaultScreen(dpy));
    auto atomWTF = GetAtom!("_NET_WORKAREA", true)(dpy);
    Atom aType;
    int format;
    c_ulong itemCount;
    c_ulong bytesAfter;
    int* propRes;
    auto status = XGetWindowProperty(dpy, root, atomWTF, 0, 4, /*False*/0, AnyPropertyType, &aType, &format, &itemCount, &bytesAfter, cast(void**)&propRes);
    if (status >= Success) {
      if (propRes !is null) {
        x = propRes[0];
        y = propRes[1];
        width = propRes[2];
        height = propRes[3];
        XFree(propRes);
      }
    }
  } else {
    width = 800;
    height = 600;
  }
}


// ////////////////////////////////////////////////////////////////////////// //
enum _NET_WM_MOVERESIZE_SIZE_TOPLEFT = 0;
enum _NET_WM_MOVERESIZE_SIZE_TOP = 1;
enum _NET_WM_MOVERESIZE_SIZE_TOPRIGHT = 2;
enum _NET_WM_MOVERESIZE_SIZE_RIGHT = 3;
enum _NET_WM_MOVERESIZE_SIZE_BOTTOMRIGHT = 4;
enum _NET_WM_MOVERESIZE_SIZE_BOTTOM = 5;
enum _NET_WM_MOVERESIZE_SIZE_BOTTOMLEFT = 6;
enum _NET_WM_MOVERESIZE_SIZE_LEFT = 7;
enum _NET_WM_MOVERESIZE_MOVE = 8; /* movement only */
enum _NET_WM_MOVERESIZE_SIZE_KEYBOARD = 9; /* size via keyboard */
enum _NET_WM_MOVERESIZE_MOVE_KEYBOARD = 10; /* move via keyboard */
enum _NET_WM_MOVERESIZE_CANCEL = 11; /* cancel operation */


public void wmInitiateMoving (SimpleWindow sw, int localx, int localy) {
  static if (UsingSimpledisplayX11) {
    if (sw is null || sw.closed || sw.hidden) return;
    Window dummyw;
    auto dpy = sw.impl.display;
    auto xwin = sw.impl.window;
    auto root = RootWindow(dpy, DefaultScreen(dpy));
    // convert local to global
    //{ import core.stdc.stdio; printf("local: %d,%d\n", localx, localy); }
    XTranslateCoordinates(dpy, xwin, root, localx, localy, &localx, &localy, &dummyw);
    //{ import core.stdc.stdio; printf("global: %d,%d\n", localx, localy); }
    // send event
    XEvent e;
    e.xclient.type = EventType.ClientMessage;
    e.xclient.serial = 0;
    e.xclient.send_event = 1/*True*/;
    e.xclient.message_type = GetAtom!("_NET_WM_MOVERESIZE", true)(dpy);
    e.xclient.window = xwin;
    e.xclient.format = 32;
    e.xclient.data.l[0] = localx; // root_x
    e.xclient.data.l[1] = localy; // root_y
    e.xclient.data.l[2] = _NET_WM_MOVERESIZE_MOVE;
    e.xclient.data.l[3] = 0; // left button
    e.xclient.data.l[4] = 1; // application request
    XSendEvent(dpy, root, false, EventMask.SubstructureRedirectMask|EventMask.SubstructureNotifyMask, &e);
    flushGui();
  }
}


public void wmCancelMoving (SimpleWindow sw, int localx, int localy) {
  static if (UsingSimpledisplayX11) {
    if (sw is null || sw.closed || sw.hidden) return;
    Window dummyw;
    auto dpy = sw.impl.display;
    auto xwin = sw.impl.window;
    auto root = RootWindow(dpy, DefaultScreen(dpy));
    // convert local to global
    XTranslateCoordinates(dpy, xwin, root, localx, localy, &localx, &localy, &dummyw);
    // send event
    XEvent e;
    e.xclient.type = EventType.ClientMessage;
    e.xclient.serial = 0;
    e.xclient.send_event = 1/*True*/;
    e.xclient.message_type = GetAtom!("_NET_WM_MOVERESIZE", true)(dpy);
    e.xclient.window = xwin;
    e.xclient.format = 32;
    e.xclient.data.l[0] = localx; // root_x
    e.xclient.data.l[1] = localy; // root_y
    e.xclient.data.l[2] = _NET_WM_MOVERESIZE_CANCEL;
    e.xclient.data.l[3] = 0; // left button
    e.xclient.data.l[4] = 1; // application request
    XSendEvent(dpy, root, false, EventMask.SubstructureRedirectMask|EventMask.SubstructureNotifyMask, &e);
    flushGui();
  }
}


// ////////////////////////////////////////////////////////////////////////// //
public struct XRefCounted(T) if (is(T == struct)) {
private:
  usize intrp__;

private:
  static void doIncRef (usize ox) nothrow @trusted @nogc {
    pragma(inline, true);
    if (ox) {
      *cast(uint*)(ox-uint.sizeof) += 1;
      version(krc_debug) { import core.stdc.stdio : printf; printf("doIncRef for 0x%08x (%u)\n", cast(uint)ox, *cast(uint*)(ox-uint.sizeof)); }
    }
  }

  static void doDecRef() (ref usize ox) {
    if (ox) {
      version(krc_debug) { import core.stdc.stdio : printf; printf("doDecRef for 0x%08x (%u)\n", cast(uint)ox, *cast(uint*)(ox-uint.sizeof)); }
      if ((*cast(uint*)(ox-uint.sizeof) -= 1) == 0) {
        // kill and free
        scope(exit) {
          import core.stdc.stdlib : free;
          import core.memory : GC;

          version(krc_debug) { import core.stdc.stdio : printf; printf("CG CLEANUP FOR WRAPPER 0x%08x\n", cast(uint)ox); }
          version(krc_debug) import core.stdc.stdio : printf;
          void* mem = cast(void*)ox;
          version(krc_debug) { import core.stdc.stdio : printf; printf("DESTROYING WRAPPER 0x%08x\n", cast(uint)mem); }
          enum instSize = T.sizeof;
          auto pbm = __traits(getPointerBitmap, T);
          version(krc_debug) printf("[%.*s]: size=%u (%u) (%u)\n", cast(uint)T.stringof.length, T.stringof.ptr, cast(uint)pbm[0], cast(uint)instSize, cast(uint)(pbm[0]/usize.sizeof));
          immutable(ubyte)* p = cast(immutable(ubyte)*)(pbm.ptr+1);
          usize bitnum = 0;
          immutable end = pbm[0]/usize.sizeof;
          while (bitnum < end) {
            if (p[bitnum/8]&(1U<<(bitnum%8))) {
              usize len = 1;
              while (bitnum+len < end && (p[(bitnum+len)/8]&(1U<<((bitnum+len)%8))) != 0) ++len;
              version(krc_debug) printf("  #%u (%u)\n", cast(uint)(bitnum*usize.sizeof), cast(uint)len);
              GC.removeRange((cast(usize*)mem)+bitnum);
              bitnum += len;
            } else {
              ++bitnum;
            }
          }

          free(cast(void*)(ox-uint.sizeof));
          ox = 0;
        }
        (*cast(T*)ox).destroy;
      }
    }
  }

public:
  this(A...) (auto ref A args) {
    intrp__ = newOx!T(args);
  }

  this() (auto ref typeof(this) src) nothrow @trusted @nogc {
    intrp__ = src.intrp__;
    doIncRef(intrp__);
  }

  ~this () { doDecRef(intrp__); }

  this (this) nothrow @trusted @nogc { doIncRef(intrp__); }

  void opAssign() (typeof(this) src) {
    if (!intrp__ && !src.intrp__) return;
    version(krc_debug) { import core.stdc.stdio : printf; printf("***OPASSIGN(0x%08x -> 0x%08x)\n", cast(void*)src.intrp__, cast(void*)intrp__); }
    if (intrp__) {
      // assigning to non-empty
      if (src.intrp__) {
        // both streams are active
        if (intrp__ == src.intrp__) return; // nothing to do
        auto oldo = intrp__;
        auto newo = src.intrp__;
        // first increase rc for new object
        doIncRef(newo);
        // replace object for this
        intrp__ = newo;
        // release old object
        doDecRef(oldo);
      } else {
        // just close this one
        scope(exit) intrp__ = 0;
        doDecRef(intrp__);
      }
    } else if (src.intrp__) {
      // this is empty, but other is not; easy deal
      intrp__ = src.intrp__;
      doIncRef(intrp__);
    }
  }

  usize toHash () const pure nothrow @safe @nogc { pragma(inline, true); return intrp__; } // yeah, so simple
  bool opEquals() (auto ref typeof(this) s) const { pragma(inline, true); return (intrp__ == s.intrp__); }

  @property bool hasObject () const pure nothrow @trusted @nogc { pragma(inline, true); return (intrp__ != 0); }

  @property inout(T)* intr_ () inout pure nothrow @trusted @nogc { pragma(inline, true); return cast(typeof(return))intrp__; }

  // hack!
  static if (__traits(compiles, ((){T s; bool v = s.valid;}))) {
    @property bool valid () const nothrow @trusted @nogc { pragma(inline, true); return (intrp__ ? intr_.valid : false); }
  }

  alias intr_ this;

static private:
  usize newOx (CT, A...) (auto ref A args) if (is(CT == struct)) {
    import core.exception : onOutOfMemoryErrorNoGC;
    import core.memory : GC;
    import core.stdc.stdlib : malloc, free;
    import core.stdc.string : memset;
    import std.conv : emplace;
    enum instSize = CT.sizeof;
    // let's hope that malloc() aligns returned memory right
    auto memx = malloc(instSize+uint.sizeof);
    if (memx is null) onOutOfMemoryErrorNoGC(); // oops
    scope(failure) free(memx);
    memset(memx, 0, instSize+uint.sizeof);
    *cast(uint*)memx = 1;
    auto mem = memx+uint.sizeof;
    emplace!CT(mem[0..instSize], args);

    version(krc_debug) import core.stdc.stdio : printf;
    auto pbm = __traits(getPointerBitmap, CT);
    version(krc_debug) printf("[%.*s]: size=%u (%u) (%u)\n", cast(uint)CT.stringof.length, CT.stringof.ptr, cast(uint)pbm[0], cast(uint)instSize, cast(uint)(pbm[0]/usize.sizeof));
    immutable(ubyte)* p = cast(immutable(ubyte)*)(pbm.ptr+1);
    usize bitnum = 0;
    immutable end = pbm[0]/usize.sizeof;
    while (bitnum < end) {
      if (p[bitnum/8]&(1U<<(bitnum%8))) {
        usize len = 1;
        while (bitnum+len < end && (p[(bitnum+len)/8]&(1U<<((bitnum+len)%8))) != 0) ++len;
        version(krc_debug) printf("  #%u (%u)\n", cast(uint)(bitnum*usize.sizeof), cast(uint)len);
        GC.addRange((cast(usize*)mem)+bitnum, usize.sizeof*len);
        bitnum += len;
      } else {
        ++bitnum;
      }
    }
    version(krc_debug) { import core.stdc.stdio : printf; printf("CREATED WRAPPER 0x%08x\n", mem); }
    return cast(usize)mem;
  }
}


static if (UsingSimpledisplayX11) {
// ////////////////////////////////////////////////////////////////////////// //
// for X11 we will keep all XShm-allocated images in this list, so we can free 'em on connection closing.
// we'll use glibc malloc()/free(), 'cause `unregisterImage()` can be called from object dtor.
private struct XShmSeg {
private:
  __gshared usize headp = 0, tailp = 0;

  static @property XShmSeg* head () nothrow @trusted @nogc { pragma(inline, true); return cast(XShmSeg*)headp; }
  static @property void head (XShmSeg* v) nothrow @trusted @nogc { pragma(inline, true); headp = cast(usize)v; }

  static @property XShmSeg* tail () nothrow @trusted @nogc { pragma(inline, true); return cast(XShmSeg*)tailp; }
  static @property void tail (XShmSeg* v) nothrow @trusted @nogc { pragma(inline, true); tailp = cast(usize)v; }

private:
  usize segp; // XShmSegmentInfo*; hide it from GC
  usize prevp; // next link; hide it from GC
  usize nextp; // next link; hide it from GC

private:
  @property bool valid () const pure nothrow @trusted @nogc { pragma(inline, true); return (segp != 0); }

  @property XShmSeg* next () pure nothrow @trusted @nogc { pragma(inline, true); return cast(XShmSeg*)nextp; }
  @property void next (XShmSeg* v) pure nothrow @trusted @nogc { pragma(inline, true); nextp = cast(usize)v; }

  @property XShmSeg* prev () pure nothrow @trusted @nogc { pragma(inline, true); return cast(XShmSeg*)prevp; }
  @property void prev (XShmSeg* v) pure nothrow @trusted @nogc { pragma(inline, true); prevp = cast(usize)v; }

  @property XShmSegmentInfo* seg () pure nothrow @trusted @nogc { pragma(inline, true); return cast(XShmSegmentInfo*)segp; }
  @property void seg (XShmSegmentInfo* v) pure nothrow @trusted @nogc { pragma(inline, true); segp = cast(usize)v; }

static:
  XShmSeg* alloc () nothrow @trusted @nogc {
    import core.stdc.stdlib : malloc, free;
    XShmSeg* res = cast(XShmSeg*)malloc(XShmSeg.sizeof);
    if (res !is null) {
      res.seg = cast(XShmSegmentInfo*)malloc(XShmSegmentInfo.sizeof);
      if (res.seg is null) { free(res); return null; }
      res.prev = tail;
      res.next = null;
      if (tail !is null) tail.next = res; else { assert(head is null); head = res; }
      tail = res;
    }
    return res;
  }

  void free (XShmSeg* seg, bool unregister) {
    if (seg !is null) {
      //{ import core.stdc.stdio; printf("00: freeing...\n"); }
      import core.stdc.stdlib : free;
      if (seg.prev !is null) seg.prev.next = seg.next; else { assert(head is seg); head = head.next; if (head !is null) head.prev = null; }
      if (seg.next !is null) seg.next.prev = seg.prev; else { assert(tail is seg); tail = tail.prev; if (tail !is null) tail.next = null; }
      if (seg.seg) {
        if (unregister) {
          //{ import core.stdc.stdio; printf("00: freeing-unreg...\n"); }
          shmdt(seg.seg.shmaddr);
          shmctl(seg.seg.shmid, IPC_RMID, null);
        }
        free(seg.seg);
      }
      free(seg);
    }
  }

  void freeList () {
    import core.stdc.stdlib : free;
    while (head !is null) {
      //{ import core.stdc.stdio; printf("01: freeing...\n"); }
      if (head.seg) {
        //{ import core.stdc.stdio; printf("01: freeing-unreg...\n"); }
        shmdt(head.seg.shmaddr);
        shmctl(head.seg.shmid, IPC_RMID, null);
        free(head.seg);
      }
      auto p = head;
      head = head.next;
      free(p);
    }
    tail = null;
  }

  shared static ~this () { freeList(); }
}
}


// ////////////////////////////////////////////////////////////////////////// //
public alias XImageTC = XRefCounted!XlibImageTC;

public struct XlibImageTC {
  static if (UsingSimpledisplayX11) {
    private bool thisIsXShm;
    private union {
      XImage handle;
      XImage* handleshm;
    }
    private XShmSeg* shminfo;

    @disable this (this);

    this (MemoryImage img, bool xshm=false) {
      if (img is null || img.width < 1 || img.height < 1) throw new Exception("can't create xlib image from empty MemoryImage");
      create(img.width, img.height, img, xshm);
    }

    this (int wdt, int hgt, bool xshm=false) {
      if (wdt < 1 || hgt < 1) throw new Exception("invalid xlib image");
      create(wdt, hgt, null, xshm);
    }

    this (int wdt, int hgt, MemoryImage aimg, bool xshm=false) {
      if (wdt < 1 || hgt < 1) throw new Exception("invalid xlib image");
      create(wdt, hgt, aimg, xshm);
    }

    ~this () { dispose(); }

    @property bool valid () const pure nothrow @trusted @nogc { pragma(inline, true); return (thisIsXShm ? handleshm !is null : handle.data !is null); }
    @property bool xshm () const pure nothrow @trusted @nogc { pragma(inline, true); return thisIsXShm; }

    @property int width () const pure nothrow @trusted @nogc { pragma(inline, true); return (thisIsXShm ? handleshm.width : handle.width); }
    @property int height () const pure nothrow @trusted @nogc { pragma(inline, true); return (thisIsXShm ? handleshm.height : handle.height); }

    inout(uint)* data () inout nothrow @trusted @nogc { pragma(inline, true); return cast(typeof(return))(thisIsXShm ? handleshm.data : handle.data); }

    void setup (MemoryImage aimg, bool xshm=false) {
      dispose();
      if (aimg is null || aimg.width < 1 || aimg.height < 1) throw new Exception("can't create xlib image from empty MemoryImage");
      create(aimg.width, aimg.height, aimg, xshm);
    }

    void setup (int wdt, int hgt, MemoryImage aimg=null, bool xshm=false) {
      dispose();
      if (wdt < 1 || hgt < 1) throw new Exception("invalid xlib image");
      create(wdt, hgt, aimg, xshm);
    }

    TrueColorImage getAsTC () {
      if (!valid) return null;
      auto tc = new TrueColorImage(width, height);
      scope(failure) delete tc;
      auto sc = cast(const(uint)*)data;
      auto dc = tc.imageData.colors.ptr;
      foreach (immutable dy; 0..height) {
        foreach (immutable dx; 0..width) {
          *dc++ = img2c(*sc++);
        }
      }
      return tc;
    }

    private void create (int width, int height, MemoryImage ximg, bool xshm) {
      import core.stdc.stdlib : malloc, free;
      if (xshm && !sdpyHasXShm) xshm = false;
      thisIsXShm = xshm;
      if (xshm) {
        auto dpy = XDisplayConnection.get();
        if (dpy is null) throw new Exception("can't create XShmImage");

        shminfo = XShmSeg.alloc();
        if (shminfo is null) throw new Exception("can't create XShmImage");
        bool registered = false;
        scope(failure) { XShmSeg.free(shminfo, registered); shminfo = null; }

        handleshm = XShmCreateImage(dpy, DefaultVisual(dpy, DefaultScreen(dpy)), 24, ImageFormat.ZPixmap, null, shminfo.seg, width, height);
        if (handleshm is null) throw new Exception("can't create XShmImage");
        assert(handleshm.bytes_per_line == 4*width);

        shminfo.seg.shmid = shmget(IPC_PRIVATE, handleshm.bytes_per_line*height, IPC_CREAT|511 /* 0777 */);
        assert(shminfo.seg.shmid >= 0);
        registered = true;
        handleshm.data = shminfo.seg.shmaddr = cast(ubyte*)shmat(shminfo.seg.shmid, null, 0);
        assert(handleshm.data != cast(ubyte*)-1);

        auto rawData = cast(uint*)handleshm.data;
        if (ximg is null || ximg.width < width || ximg.height < height) rawData[0..width*height] = 0;
        if (ximg !is null && ximg.width > 0 && ximg.height > 0) {
          foreach (immutable int y; 0..height) {
            foreach (immutable int x; 0..width) {
              rawData[y*width+x] = c2img(ximg.getPixel(x, y));
            }
          }
        }

        shminfo.seg.readOnly = 0;
        XShmAttach(dpy, shminfo.seg);
      } else {
        auto rawData = cast(uint*)malloc(width*height*4);
        scope(failure) free(rawData);
        if (ximg is null || ximg.width < width || ximg.height < height) rawData[0..width*height] = 0;
        if (ximg !is null && ximg.width > 0 && ximg.height > 0) {
          foreach (immutable int y; 0..height) {
            foreach (immutable int x; 0..width) {
              rawData[y*width+x] = c2img(ximg.getPixel(x, y));
            }
          }
        }
        //handle = XCreateImage(dpy, DefaultVisual(dpy, screen), 24/*bpp*/, ImageFormat.ZPixmap, 0/*offset*/, cast(ubyte*)rawData, width, height, 8/*FIXME*/, 4*width); // padding, bytes per line
        handle.width = width;
        handle.height = height;
        handle.xoffset = 0;
        handle.format = ImageFormat.ZPixmap;
        handle.data = rawData;
        handle.byte_order = 0;
        handle.bitmap_unit = 32;
        handle.bitmap_bit_order = 0;
        handle.bitmap_pad = 8;
        handle.depth = 24;
        handle.bytes_per_line = 0;
        handle.bits_per_pixel = 32; // THIS MATTERS!
        handle.red_mask = 0x00ff0000;
        handle.green_mask = 0x0000ff00;
        handle.blue_mask = 0x000000ff;
        XInitImage(&handle);
      }
    }

    void dispose () {
      if (thisIsXShm) {
        if (auto dpy = XDisplayConnection.get()) XShmDetach(dpy, shminfo.seg);
        XDestroyImage(handleshm);
        //shmdt(shminfo.seg.shmaddr);
        //shmctl(shminfo.seg.shmid, IPC_RMID, null);
        XShmSeg.free(shminfo, true);
        shminfo = null;
        handleshm = null;
      } else {
        if (handle.data !is null) {
          import core.stdc.stdlib : free;
          if (handle.data !is null) free(handle.data);
          handle = XImage.init;
        }
      }
    }

    void putPixel (int x, int y, Color c) nothrow @trusted @nogc {
      pragma(inline, true);
      if (valid && x >= 0 && y >= 0 && x < width && y < height) {
        data[y*width+x] = c2img(c);
      }
    }

    Color getPixel (int x, int y, Color c) nothrow @trusted @nogc {
      pragma(inline, true);
      return (valid && x >= 0 && y >= 0 && x < width && y < height ? img2c(data[y*width+x]) : Color.transparent);
    }

    uint* row (int y) nothrow @trusted @nogc {
      pragma(inline, true);
      return (valid && y >= 0 && y < height ? data+y*width : null);
    }

    // blit to window buffer
    void blitAt (SimpleWindow w, int destx, int desty) { blitRect(w, destx, desty, 0, 0, width, height); }

    // blit to window buffer
    void blitRect (SimpleWindow w, int destx, int desty, int sx0, int sy0, int swdt, int shgt) {
      if (w is null || !valid || w.closed) return;
      if (thisIsXShm) {
        XShmPutImage(w.impl.display, cast(Drawable)w.impl.buffer, w.impl.gc, handleshm, sx0, sy0, destx, desty, swdt, shgt, 0);
      } else {
        XPutImage(w.impl.display, cast(Drawable)w.impl.buffer, w.impl.gc, &handle, sx0, sy0, destx, desty, swdt, shgt);
      }
    }

    // blit to window
    void blitAtWin (SimpleWindow w, int destx, int desty) { blitRectWin(w, destx, desty, 0, 0, width, height); }

    // blit to window
    void blitRectWin (SimpleWindow w, int destx, int desty, int sx0, int sy0, int swdt, int shgt) {
      if (w is null || !valid || w.closed) return;
      if (thisIsXShm) {
        XShmPutImage(w.impl.display, cast(Drawable)w.impl.window, w.impl.gc, handleshm, sx0, sy0, destx, desty, swdt, shgt, 0);
      } else {
        XPutImage(w.impl.display, cast(Drawable)w.impl.window, w.impl.gc, &handle, sx0, sy0, destx, desty, swdt, shgt);
      }
    }
  }

static:
  public ubyte icR (uint c) pure nothrow @safe @nogc { pragma(inline, true); return ((c>>16)&0xff); }
  public ubyte icG (uint c) pure nothrow @safe @nogc { pragma(inline, true); return ((c>>8)&0xff); }
  public ubyte icB (uint c) pure nothrow @safe @nogc { pragma(inline, true); return (c&0xff); }
  public ubyte icA (uint c) pure nothrow @safe @nogc { pragma(inline, true); return ((c>>24)&0xff); }

  public uint icRGB (int r, int g, int b) pure nothrow @safe @nogc {
    pragma(inline, true);
    return (Color.clampToByte(r)<<16)|(Color.clampToByte(g)<<8)|Color.clampToByte(b);
  }

  public uint icRGBA (int r, int g, int b, int a) pure nothrow @safe @nogc {
    pragma(inline, true);
    return (Color.clampToByte(a)<<24)|(Color.clampToByte(r)<<16)|(Color.clampToByte(g)<<8)|Color.clampToByte(b);
  }

  public uint c2img (in Color c) pure nothrow @safe @nogc {
    pragma(inline, true);
    return
      ((c.asUint&0xff)<<16)|
      (c.asUint&0x00ff00U)|
      ((c.asUint>>16)&0xff);
  }

  public uint c2imgA (in Color c) pure nothrow @safe @nogc {
    pragma(inline, true);
    return
      ((c.asUint&0xff)<<16)|
      (c.asUint&0xff_00ff00U)|
      ((c.asUint>>16)&0xff);
  }

  public uint c2img (uint c) pure nothrow @safe @nogc {
    pragma(inline, true);
    return
      ((c&0xff)<<16)|
      (c&0x00ff00)|
      ((c>>16)&0xff);
  }

  public uint c2imgA (uint c) pure nothrow @safe @nogc {
    pragma(inline, true);
    return
      ((c&0xff)<<16)|
      (c&0xff_00ff00)|
      ((c>>16)&0xff);
  }

  public Color img2c (uint clr) pure nothrow @safe @nogc {
    pragma(inline, true);
    return Color((clr>>16)&0xff, (clr>>8)&0xff, clr&0xff);
  }

  public Color img2cA (uint clr) pure nothrow @safe @nogc {
    pragma(inline, true);
    return Color((clr>>16)&0xff, (clr>>8)&0xff, clr&0xff, (clr>>24)&0xff);
  }
}


// ////////////////////////////////////////////////////////////////////////// //
static if (UsingSimpledisplayX11) {

public alias XPixmap = XRefCounted!XlibPixmap;

public struct XlibPixmap {
  Pixmap xpm;
  private int mWidth, mHeight;

  this (SimpleWindow w) {}

  this (SimpleWindow w, int wdt, int hgt) { setup(w, wdt, hgt); }
  this (SimpleWindow w, ref XlibImageTC xtc) { setup(w, xtc); }
  this (SimpleWindow w, XImageTC xtc) { if (!xtc.hasObject) throw new Exception("can't create pixmap from empty object"); setup(w, *xtc.intr_); }

  this (SimpleWindow w, ref XlibPixmap xpm) { setup(w, xpm); }
  this (SimpleWindow w, XPixmap xpm) { if (!xpm.hasObject) throw new Exception("can't create pixmap from empty object"); setup(w, *xpm.intr_); }

  @disable this (this);

  ~this () { dispose(); }

  @property bool valid () const pure nothrow @trusted @nogc { pragma(inline, true); return (xpm != 0); }

  @property int width () const pure nothrow @trusted @nogc { pragma(inline, true); return mWidth; }
  @property int height () const pure nothrow @trusted @nogc { pragma(inline, true); return mHeight; }

  void copyFromWinBuf (SimpleWindow w) {
    if (w is null || w.closed) throw new Exception("can't copy pixmap without window");
    if (!valid || mWidth != w.width || mHeight != w.height) {
      dispose();
      xpm = XCreatePixmap(w.impl.display, cast(Drawable)w.impl.window, w.width, w.height, 24);
      mWidth = w.width;
      mHeight = w.height;
    }
    XCopyArea(w.impl.display, cast(Drawable)w.impl.buffer, cast(Drawable)xpm, w.impl.gc, 0, 0, mWidth, mHeight, 0, 0);
  }

  void copyFrom (SimpleWindow w, ref XlibPixmap axpm) {
    if (!valid) return;
    if (!axpm.valid) return;
    if (w is null || w.closed) throw new Exception("can't copy pixmap without window");
    XCopyArea(w.impl.display, cast(Drawable)axpm.xpm, cast(Drawable)xpm, w.impl.gc, 0, 0, axpm.width, axpm.height, 0, 0);
  }

  void copyFrom (SimpleWindow w, XPixmap axpm) {
    if (!axpm.hasObject) return;
    copyFrom(w, *axpm.intr_);
  }

  void setup (SimpleWindow w, int wdt, int hgt) {
    dispose();
    if (w is null || w.closed) throw new Exception("can't create pixmap without window");
    if (wdt < 1) wdt = 1;
    if (hgt < 1) hgt = 1;
    if (wdt > 16384) wdt = 16384;
    if (hgt > 16384) hgt = 16384;
    xpm = XCreatePixmap(w.impl.display, cast(Drawable)w.impl.window, wdt, hgt, 24);
    mWidth = wdt;
    mHeight = hgt;
  }

  void setup (SimpleWindow w, XPixmap xpm) {
    if (!xpm.hasObject) throw new Exception("can't create pixmap from empty xlib image");
    setup(w, *xpm.intr_);
  }

  void setup (SimpleWindow w, ref XlibPixmap axpm) {
    if (!axpm.valid) throw new Exception("can't create pixmap from empty xlib pixmap");
    dispose();
    if (w is null || w.closed) throw new Exception("can't create pixmap without window");
    int wdt = axpm.width;
    int hgt = axpm.height;
    if (wdt < 1) wdt = 1;
    if (hgt < 1) hgt = 1;
    if (wdt > 16384) wdt = 16384;
    if (hgt > 16384) hgt = 16384;
    xpm = XCreatePixmap(w.impl.display, cast(Drawable)w.impl.window, wdt, hgt, 24);
    XCopyArea(w.impl.display, cast(Drawable)axpm.xpm, cast(Drawable)xpm, w.impl.gc, 0, 0, wdt, hgt, 0, 0);
    mWidth = wdt;
    mHeight = hgt;
  }

  void setup (SimpleWindow w, XImageTC xtc) {
    if (!xtc.hasObject) throw new Exception("can't create pixmap from empty xlib image");
    setup(w, *xtc.intr_);
  }

  void setup (SimpleWindow w, ref XlibImageTC xtc) {
    if (!xtc.valid) throw new Exception("can't create pixmap from empty xlib image");
    dispose();
    if (w is null || w.closed) throw new Exception("can't create pixmap without window");
    int wdt = xtc.width;
    int hgt = xtc.height;
    if (wdt < 1) wdt = 1;
    if (hgt < 1) hgt = 1;
    if (wdt > 16384) wdt = 16384;
    if (hgt > 16384) hgt = 16384;
    xpm = XCreatePixmap(w.impl.display, cast(Drawable)w.impl.window, wdt, hgt, 24);
    // source x, source y
    if (xtc.thisIsXShm) {
      XShmPutImage(w.impl.display, cast(Drawable)xpm, w.impl.gc, xtc.handleshm, 0, 0, 0, 0, wdt, hgt, 0);
    } else {
      XPutImage(w.impl.display, cast(Drawable)xpm, w.impl.gc, &xtc.handle, 0, 0, 0, 0, wdt, hgt);
    }
    mWidth = wdt;
    mHeight = hgt;
  }

  void dispose () {
    if (xpm) {
      XFreePixmap(XDisplayConnection.get(), xpm);
      xpm = 0;
    }
    mWidth = mHeight = 0;
  }

  // blit to window buffer
  void blitAt (SimpleWindow w, int x, int y) {
    blitRect(w, x, y, 0, 0, width, height);
  }

  // blit to window buffer
  void blitRect (SimpleWindow w, int destx, int desty, int sx0, int sy0, int swdt, int shgt) {
    if (w is null || !xpm || w.closed) return;
    XCopyArea(w.impl.display, cast(Drawable)xpm, cast(Drawable)w.impl.buffer, w.impl.gc, sx0, sy0, swdt, shgt, destx, desty);
  }

  // blit to window buffer
  void blitAtWin (SimpleWindow w, int x, int y) {
    blitRectWin(w, x, y, 0, 0, width, height);
  }

  // blit to window buffer
  void blitRectWin (SimpleWindow w, int destx, int desty, int sx0, int sy0, int swdt, int shgt) {
    if (w is null || !xpm || w.closed) return;
    XCopyArea(w.impl.display, cast(Drawable)xpm, cast(Drawable)w.impl.window, w.impl.gc, sx0, sy0, swdt, shgt, destx, desty);
  }
}

// ////////////////////////////////////////////////////////////////////////// //
}


void sdpyNormalizeArrowKeys(bool domods=true) (ref KeyEvent event) {
  static if (domods) {
    switch (event.key) {
      case Key.Ctrl_r: event.key = Key.Ctrl; return;
      case Key.Shift_r: event.key = Key.Shift; return;
      case Key.Alt_r: event.key = Key.Alt; return;
      case Key.Windows_r: event.key = Key.Windows; return;
      default:
    }
  }
  if ((event.modifierState&ModifierState.numLock) == 0) {
    switch (event.key) {
      case Key.PadEnter: event.key = Key.Enter; return;
      case Key.Pad1: event.key = Key.End; return;
      case Key.Pad2: event.key = Key.Down; return;
      case Key.Pad3: event.key = Key.PageDown; return;
      case Key.Pad4: event.key = Key.Left; return;
      //case Key.Pad5: event.key = Key.; return;
      case Key.Pad6: event.key = Key.Right; return;
      case Key.Pad7: event.key = Key.Home; return;
      case Key.Pad8: event.key = Key.Up; return;
      case Key.Pad9: event.key = Key.PageUp; return;
      case Key.Pad0: event.key = Key.Insert; return;
      default:
    }
  }
}


/+
// ////////////////////////////////////////////////////////////////////////// //
// this mixin can be used to alphablend two `uint` colors
// `colu32name` is variable that holds color to blend,
// `destu32name` is variable that holds "current" color (from surface, for example)
// alpha value of `destu32name` doesn't matter
// alpha value of `colu32name` means: 255 for replace color, 0 for keep `destu32name` (was reversed)
private enum ColorBlendMixinStr(string colu32name, string destu32name) = "{
  immutable uint a_tmp_ = (256-(255-(("~colu32name~")>>24)))&(-(1-(((255-(("~colu32name~")>>24))+1)>>8))); // to not loose bits, but 255 should become 0
  immutable uint dc_tmp_ = ("~destu32name~")&0xffffff;
  immutable uint srb_tmp_ = (("~colu32name~")&0xff00ff);
  immutable uint sg_tmp_ = (("~colu32name~")&0x00ff00);
  immutable uint drb_tmp_ = (dc_tmp_&0xff00ff);
  immutable uint dg_tmp_ = (dc_tmp_&0x00ff00);
  immutable uint orb_tmp_ = (drb_tmp_+(((srb_tmp_-drb_tmp_)*a_tmp_+0x800080)>>8))&0xff00ff;
  immutable uint og_tmp_ = (dg_tmp_+(((sg_tmp_-dg_tmp_)*a_tmp_+0x008000)>>8))&0x00ff00;
  ("~destu32name~") = (orb_tmp_|og_tmp_)|0xff000000; /*&0xffffff;*/
}";


Color blend (Color dst, Color src) nothrow @trusted @nogc {
  pragma(inline, true);
  mixin(ColorBlendMixinStr!("src.asUint", "dst.asUint"));
  return dst;
}


// the only two requirements: alpha is in high bits, and "0 alpha" means "transparent"
uint blendU32 (uint dst, uint src) nothrow @trusted @nogc {
  pragma(inline, true);
  mixin(ColorBlendMixinStr!("src", "dst"));
  return dst;
}
+/

Color blend (Color dst, Color src) pure nothrow @trusted @nogc { pragma(inline, true); return dst.alphaBlend(src); }
uint blendU32 (uint dst, uint src) pure nothrow @trusted @nogc { pragma(inline, true); mixin(Color.ColorBlendMixinStr!("src", "dst")); return dst; }


// ////////////////////////////////////////////////////////////////////////// //
import iv.gxx.geom;

// some "fastgfx" backend
class SdpyDrawBase {
protected:
  static T abs(T) (T n) pure nothrow @safe @nogc { pragma(inline, true); return (n < 0 ? -n : n); }

  version(Windows) {
    private static int lrintf (float f) nothrow @trusted @nogc { pragma(inline, true); return cast(int)(f+0.5f); }
    private static int lrintd (double f) nothrow @trusted @nogc { pragma(inline, true); return cast(int)(f+0.5); }
  } else {
    private import core.stdc.math : lrintf, lrintd = lrint;
  }
  private import core.stdc.math : sqrtf, sqrtd = sqrt;
  private import core.stdc.math : floorf, floord = floor;
  private import core.stdc.math : cosf, sinf;

public:
  GxSize dim;
  GxRect clip;

protected: // low-level methods; will always be called with valid coords
  // must be overriden
  abstract Color getpix (int x, int y);
  abstract void putpix (int x, int y, Color c);

  // optionals
  void hline (int x, int y, int len, Color c) {
    while (len-- > 0) putpix(x++, y, c);
  }

  void vline (int x, int y, int len, Color c) {
    while (len-- > 0) putpix(x, y++, c);
  }

  void fillrc (int x, int y, int w, int h, Color c) {
    while (h-- > 0) hline(x, y++, w, c);
  }

public:
  this (int awdt, int ahgt) {
    if (awdt < 0) awdt = 0;
    if (ahgt < 0) ahgt = 0;
    dim = GxSize(awdt, ahgt);
    clip = GxRect(dim);
  }

  final @property int width () const pure nothrow @safe @nogc { pragma(inline, true); return dim.width; }
  final @property int height () const pure nothrow @safe @nogc { pragma(inline, true); return dim.height; }

  void cls (Color clr=Color.white) { fillrc(0, 0, dim.width, dim.height, clr); }

  // can return null, yeah
  TrueColorImage getBuffer () { return null; }

final:
  Color getPixel (int x, int y) {
    pragma(inline, true);
    return (x >= 0 && y >= 0 && x < dim.width && y < dim.height && clip.inside(x, y) ? getpix(x, y) : Color.transparent);
  }

  void putPixel (int x, int y, Color c) {
    pragma(inline, true);
    if (x >= 0 && y >= 0 && x < dim.width && y < dim.height && clip.inside(x, y)) putpix(x, y, c);
  }

  void drawHLine (int x, int y, int len, Color c) {
    pragma(inline, true);
    if (GxRect(dim).clipHStripe(x, y, len) && clip.clipHStripe(x, y, len)) hline(x, y, len, c);
  }

  void drawVLine (int x, int y, int len, Color c) {
    pragma(inline, true);
    if (GxRect(dim).clipVStripe(x, y, len) && clip.clipVStripe(x, y, len)) vline(x, y, len, c);
  }

  void fillRect (int x, int y, int w, int h, Color c) {
    pragma(inline, true);
    if (GxRect(dim).clipHVStripes(x, y, w, h) && clip.clipHVStripes(x, y, w, h)) fillrc(x, y, w, h, c);
  }

  void drawRect(bool filled) (int x, int y, int w, int h, Color c) {
    pragma(inline, true);
    static if (filled) {
      if (GxRect(dim).clipHVStripes(x, y, w, h) && clip.clipHVStripes(x, y, w, h)) fillrc(x, y, w, h, c);
    } else {
      hline(x, y, w, c);
      if (h > 1) hline(x, y+h-1, w, c);
      if (h > 2 && w > 2) {
        vline(x+1, y, w-2, c);
        vline(x+1, y+h-1, w-2, c);
      }
    }
  }

  void drawEllipse(bool filled=false) (int x0, int y0, int x1, int y1, Color col) {
    int a = abs(x1-x0), b = abs(y1-y0), b1 = b&1; // values of diameter
    long dx = 4*(1-a)*b*b, dy = 4*(b1+1)*a*a; // error increment
    long err = dx+dy+b1*a*a; // error of 1.step
    int prev_y0 = -1, prev_y1 = -1;
    if (x0 > x1) { x0 = x1; x1 += a; } // if called with swapped points...
    if (y0 > y1) y0 = y1; // ...exchange them
    y0 += (b+1)/2; y1 = y0-b1; // starting pixel
    a *= 8*a; b1 = 8*b*b;
    do {
      long e2;
      if (y0 != prev_y0) {
        static if (filled) {
          drawHLine(x0, y0, x1-x0+1, col);
        } else {
          putPixel(x0, y0, col);
          if (x1 != x0) putPixel(x1, y0, col);
        }
        prev_y0 = y0;
      }
      if (y1 != y0 && y1 != prev_y1) {
        static if (filled) {
          drawHLine(x0, y1, x1-x0+1, col);
        } else {
          putPixel(x0, y1, col);
          if (x1 != x0) putPixel(x1, y1, col);
        }
        prev_y1 = y1;
      }
      e2 = 2*err;
      if (e2 >= dx) { ++x0; --x1; err += dx += b1; } // x step
      if (e2 <= dy) { ++y0; --y1; err += dy += a; }  // y step
    } while (x0 <= x1);
    while (y0-y1 < b) {
      // too early stop of flat ellipses a=1
      putPixel(x0-1, ++y0, col); // complete tip of ellipse
      putPixel(x0-1, --y1, col);
    }
  }

  void drawCircle(bool filled=false) (int cx, int cy, int radius, Color col) {
    if (radius < 1) return;
    int error = -radius, x = radius, y = 0;
    if (radius == 1) { putPixel(cx, cy, col); return; }
    while (x >= y) {
      int last_y = y;
      error += y;
      ++y;
      error += y;
      static if (filled) {
        drawHLine(cx-x, cy+last_y, 2*x+1, col);
      } else {
        putPixel(cx-x, cy+last_y, col);
        if (x != 0) putPixel(cx+x, cy+last_y, col);
      }
      if (x != 0 && last_y != 0) {
        static if (filled) {
          drawHLine(cx-x, cy-last_y, 2*x+1, col);
        } else {
          putPixel(cx-x, cy-last_y, col);
          putPixel(cx+x, cy-last_y, col);
        }
      }
      if (error >= 0) {
        if (x != last_y) {
          static if (filled) {
            drawHLine(cx-last_y, cy+x, 2*last_y+1, col);
            if (last_y != 0 && x != 0) drawHLine(cx-last_y, cy-x, 2*last_y+1, col);
          } else {
            putPixel(cx-last_y, cy+x, col);
            if (last_y != 0 && x != 0) {
              putPixel(cx+last_y, cy+x, col);
              putPixel(cx-last_y, cy-x, col);
              putPixel(cx+last_y, cy-x, col);
            }
          }
        }
        error -= x;
        --x;
        error -= x;
      }
    }
  }

  void drawLineEx(bool lastPoint=true) (int x0, int y0, int x1, int y1, scope void delegate (int x, int y) putPixel) {
    enum swap(string a, string b) = "{int tmp_="~a~";"~a~"="~b~";"~b~"=tmp_;}";

    if (x0 == x1 && y0 == y1) {
      static if (lastPoint) putPixel(x0, y0);
      return;
    }

    // clip rectange
    int wx0 = clip.x0, wy0 = clip.y0, wx1 = clip.x1, wy1 = clip.y1;
    if (wx0 < 0) wx0 = 0; else if (wx0 >= dim.width) wx0 = dim.width-1;
    if (wx1 < 0) wx1 = 0; else if (wx1 >= dim.width) wx1 = dim.width-1;
    if (wy0 < 0) wy0 = 0; else if (wy0 >= dim.height) wy0 = dim.height-1;
    if (wy1 < 0) wy1 = 0; else if (wy1 >= dim.height) wy1 = dim.height-1;
    if (wx0 > wx1 || wy0 > wy1) return;
    // other vars
    int stx, sty; // "steps" for x and y axes
    int dsx, dsy; // "lengthes" for x and y axes
    int dx2, dy2; // "double lengthes" for x and y axes
    int xd, yd; // current coord
    int e; // "error" (as in bresenham algo)
    int rem;
    int term;
    int* d0, d1;
    // horizontal setup
    if (x0 < x1) {
      // from left to right
      if (x0 > wx1 || x1 < wx0) return; // out of screen
      stx = 1; // going right
    } else {
      // from right to left
      if (x1 > wx1 || x0 < wx0) return; // out of screen
      stx = -1; // going left
      x0 = -x0;
      x1 = -x1;
      wx0 = -wx0;
      wx1 = -wx1;
      mixin(swap!("wx0", "wx1"));
    }
    // vertical setup
    if (y0 < y1) {
      // from top to bottom
      if (y0 > wy1 || y1 < wy0) return; // out of screen
      sty = 1; // going down
    } else {
      // from bottom to top
      if (y1 > wy1 || y0 < wy0) return; // out of screen
      sty = -1; // going up
      y0 = -y0;
      y1 = -y1;
      wy0 = -wy0;
      wy1 = -wy1;
      mixin(swap!("wy0", "wy1"));
    }
    dsx = x1-x0;
    dsy = y1-y0;
    if (dsx < dsy) {
      d0 = &yd;
      d1 = &xd;
      mixin(swap!("x0", "y0"));
      mixin(swap!("x1", "y1"));
      mixin(swap!("dsx", "dsy"));
      mixin(swap!("wx0", "wy0"));
      mixin(swap!("wx1", "wy1"));
      mixin(swap!("stx", "sty"));
    } else {
      d0 = &xd;
      d1 = &yd;
    }
    dx2 = 2*dsx;
    dy2 = 2*dsy;
    xd = x0;
    yd = y0;
    e = 2*dsy-dsx;
    term = x1;
    bool xfixed = false;
    if (y0 < wy0) {
      // clip at top
      int temp = dx2*(wy0-y0)-dsx;
      xd += temp/dy2;
      rem = temp%dy2;
      if (xd > wx1) return; // x is moved out of clipping rect, nothing to do
      if (xd+1 >= wx0) {
        yd = wy0;
        e -= rem+dsx;
        if (rem > 0) { ++xd; e += dy2; }
        xfixed = true;
      }
    }
    if (!xfixed && x0 < wx0) {
      // clip at left
      int temp = dy2*(wx0-x0);
      yd += temp/dx2;
      rem = temp%dx2;
      if (yd > wy1 || yd == wy1 && rem >= dsx) return;
      xd = wx0;
      e += rem;
      if (rem >= dsx) { ++yd; e -= dx2; }
    }
    if (y1 > wy1) {
      // clip at bottom
      int temp = dx2*(wy1-y0)+dsx;
      term = x0+temp/dy2;
      rem = temp%dy2;
      if (rem == 0) --term;
    }
    if (term > wx1) term = wx1; // clip at right
    static if (lastPoint) {
      // draw last point
      ++term;
    } else {
      if (term == xd) return; // this is the only point, get out of here
    }
    if (sty == -1) yd = -yd;
    if (stx == -1) { xd = -xd; term = -term; }
    dx2 -= dy2;
    // draw it; `putPixel()` can omit checks
    while (xd != term) {
      putPixel(*d0, *d1);
      // done drawing, move coords
      if (e >= 0) {
        yd += sty;
        e -= dx2;
      } else {
        e += dy2;
      }
      xd += stx;
    }
  }

  void drawLine(bool lastPoint=true) (int x0, int y0, int x1, int y1, Color c) { drawLineEx!lastPoint(x0, y0, x1, y1, (x, y) => putPixel(x, y, c)); }

  // ////////////////////////////////////////////////////////////////////// //
  // plot a limited quadratic Bezier segment
  final void drawQuadBezierSeg (int x0, int y0, int x1, int y1, int x2, int y2, Color fc) {
    int sx = x2-x1, sy = y2-y1;
    long xx = x0-x1, yy = y0-y1; // relative values for checks
    assert(xx*sx <= 0 && yy*sy <= 0); // sign of gradient must not change
    double cur = xx*sy-yy*sx; // curvature
    // begin with longer part
    if (sx*cast(long)sx+sy*cast(long)sy > xx*xx+yy*yy) { x2 = x0; x0 = sx+x1; y2 = y0; y0 = sy+y1; cur = -cur; } // swap P0 P2
    // no straight line
    if (cur != 0) {
      xx += sx; xx *= (sx = (x0 < x2 ? 1 : -1)); // x step direction
      yy += sy; yy *= (sy = (y0 < y2 ? 1 : -1)); // y step direction
      // differences 2nd degree
      long xy = 2*xx*yy;
      xx *= xx;
      yy *= yy;
      // negated curvature?
      if (cur*sx*sy < 0) { xx = -xx; yy = -yy; xy = -xy; cur = -cur; }
      double dx = 4.0*sy*cur*(x1-x0)+xx-xy; // differences 1st degree
      double dy = 4.0*sx*cur*(y0-y1)+yy-xy;
      xx += xx;
      yy += yy;
      double err = dx+dy+xy; // error 1st step
      do {
        putPixel(x0, y0, fc); // plot curve
        if (x0 == x2 && y0 == y2) return; // last pixel -> curve finished
        y1 = 2*err < dx; // save value for test of y step
        if (2*err > dy) { x0 += sx; dx -= xy; err += dy += yy; } // x step
        if (y1) { y0 += sy; dy -= xy; err += dx += xx; } // y step
      } while (dy < 0 && dx > 0); // gradient negates -> algorithm fails
    }
    drawLine(x0, y0, x2, y2, fc); // plot remaining part to end
  }

  // plot any quadratic Bezier curve
  final void drawQuadBezier (int x0, int y0, int x1, int y1, int x2, int y2, Color fc) {
    int x = x0-x1, y = y0-y1;
    double t = x0-2*x1+x2;
    // horizontal cut at P4?
    if (cast(long)x*(x2-x1) > 0) {
      // vertical cut at P6 too?
      if (cast(long)y*(y2-y1) > 0) {
        // which first?
        if (abs((y0-2*y1+y2)/t*x) > abs(y)) { x0 = x2; x2 = x+x1; y0 = y2; y2 = y+y1; } // swap points
        // now horizontal cut at P4 comes first
      }
      t = (x0-x1)/t;
      double r = (1-t)*((1-t)*y0+2.0*t*y1)+t*t*y2; // By(t=P4)
      t = (x0*x2-x1*x1)*t/(x0-x1); // gradient dP4/dx=0
      x = lrintd(t); y = lrintd(r);
      r = (y1-y0)*(t-x0)/(x1-x0)+y0; // intersect P3 | P0 P1
      drawQuadBezierSeg(x0, y0, x, lrintd(r), x, y, fc);
      r = (y1-y2)*(t-x2)/(x1-x2)+y2; // intersect P4 | P1 P2
      x0 = x1 = x; y0 = y; y1 = lrintd(r); // P0 = P4, P1 = P8
    }
    // vertical cut at P6?
    if (cast(long)(y0-y1)*(y2-y1) > 0) {
      t = y0-2*y1+y2; t = (y0-y1)/t;
      double r = (1-t)*((1-t)*x0+2.0*t*x1)+t*t*x2; // Bx(t=P6)
      t = (y0*y2-y1*y1)*t/(y0-y1); // gradient dP6/dy=0
      x = lrintd(r); y = lrintd(t);
      r = (x1-x0)*(t-y0)/(y1-y0)+x0; // intersect P6 | P0 P1
      drawQuadBezierSeg(x0, y0, lrintd(r), y, x, y, fc);
      r = (x1-x2)*(t-y2)/(y1-y2)+x2; // intersect P7 | P1 P2
      x0 = x; x1 = lrintd(r); y0 = y1 = y; // P0 = P6, P1 = P7
    }
    drawQuadBezierSeg(x0, y0, x1, y1, x2, y2, fc); // remaining part
  }

  // plot a limited rational Bezier segment, squared weight
  final void drawQuadRationalBezierSeg (int x0, int y0, int x1, int y1, int x2, int y2, float w, Color fc) {
    int sx = x2-x1, sy = y2-y1; // relative values for checks
    double dx = x0-x2, dy = y0-y2, xx = x0-x1, yy = y0-y1;
    double xy = xx*sy+yy*sx, cur = xx*sy-yy*sx; // curvature
    assert(xx*sx <= 0.0 && yy*sy <= 0.0); // sign of gradient must not change
    if (cur != 0.0 && w > 0.0) { // no straight line
      // begin with longer part
      if (sx*cast(long)sx+sy*cast(long)sy > xx*xx+yy*yy) { x2 = x0; x0 -= cast(int)dx; y2 = y0; y0 -= cast(int)dy; cur = -cur; } // swap P0 P2
      xx = 2.0*(4.0*w*sx*xx+dx*dx); // differences 2nd degree
      yy = 2.0*(4.0*w*sy*yy+dy*dy);
      sx = (x0 < x2 ? 1 : -1); // x step direction
      sy = (y0 < y2 ? 1 : -1); // y step direction
      xy = -2.0*sx*sy*(2.0*w*xy+dx*dy);
      // negated curvature?
      if (cur*sx*sy < 0.0) { xx = -xx; yy = -yy; xy = -xy; cur = -cur; }
      dx = 4.0*w*(x1-x0)*sy*cur+xx/2.0+xy; // differences 1st degree
      dy = 4.0*w*(y0-y1)*sx*cur+yy/2.0+xy;
      if (w < 0.5 && dy > dx) {
        // flat ellipse, algorithm fails
        cur = (w+1.0)/2.0; w = sqrtf(w); xy = 1.0/(w+1.0);
        sx = lrintd((x0+2.0*w*x1+x2)*xy/2.0); // subdivide curve in half
        sy = lrintd((y0+2.0*w*y1+y2)*xy/2.0);
        dx = floord((w*x1+x0)*xy+0.5); dy = floord((y1*w+y0)*xy+0.5);
        drawQuadRationalBezierSeg(x0, y0, cast(int)dx, cast(int)dy, sx, sy, cur, fc);/* plot separately */
        dx = floord((w*x1+x2)*xy+0.5); dy = floord((y1*w+y2)*xy+0.5);
        drawQuadRationalBezierSeg(sx, sy, cast(int)dx, cast(int)dy, x2, y2, cur, fc);
        return;
      }
      double err = dx+dy-xy; // error 1.step
      do {
        putPixel(x0, y0, fc); // plot curve
        if (x0 == x2 && y0 == y2) return; // last pixel -> curve finished
        x1 = 2*err > dy; y1 = 2*(err+yy) < -dy;/* save value for test of x step */
        if (2*err < dx || y1) { y0 += sy; dy += xy; err += dx += xx; }/* y step */
        if (2*err > dx || x1) { x0 += sx; dx += xy; err += dy += yy; }/* x step */
      } while (dy <= xy && dx >= xy); // gradient negates -> algorithm fails
    }
    drawLine(x0, y0, x2, y2, fc); // plot remaining needle to end
  }

  // rectangle enclosing the ellipse, integer rotation angle
  final void drawRotatedEllipseRect (int x0, int y0, int x1, int y1, long zd, Color fc) {
    int xd = x1-x0, yd = y1-y0;
    float w = xd*cast(long)yd;
    if (zd == 0) return drawEllipse(x0, y0, x1, y1, fc); // looks nicer
    if (w != 0.0) w = (w-zd)/(w+w); // squared weight of P1
    assert(w <= 1.0 && w >= 0.0); // limit angle to |zd|<=xd*yd
    // snap xe,ye to int
    xd = lrintf(xd*w);
    yd = lrintf(yd*w);
    drawQuadRationalBezierSeg(x0, y0+yd, x0, y0, x0+xd, y0, 1.0-w, fc);
    drawQuadRationalBezierSeg(x0, y0+yd, x0, y1, x1-xd, y1, w, fc);
    drawQuadRationalBezierSeg(x1, y1-yd, x1, y1, x1-xd, y1, 1.0-w, fc);
    drawQuadRationalBezierSeg(x1, y1-yd, x1, y0, x0+xd, y0, w, fc);
  }

  // plot ellipse rotated by angle (radian)
  final void drawRotatedEllipse (int x, int y, int a, int b, float angle, Color fc) {
    float xd = cast(long)a*a, yd = cast(long)b*b;
    float s = sinf(angle), zd = (xd-yd)*s; // ellipse rotation
    xd = sqrtf(xd-zd*s), yd = sqrtf(yd+zd*s); // surrounding rectangle
    a = lrintf(xd);
    b = lrintf(yd);
    zd = zd*a*b/(xd*yd); // scale to integer
    drawRotatedEllipseRect(x-a, y-b, x+a, y+b, cast(long)(4*zd*cosf(angle)), fc);
  }

  // plot limited cubic Bezier segment
  final void drawCubicBezierSeg (int x0, int y0, float x1, float y1, float x2, float y2, int x3, int y3, Color fc) {
    immutable double EP = 0.01;
    int leg = 1;
    int sx = (x0 < x3 ? 1 : -1), sy = (y0 < y3 ? 1 : -1); // step direction
    float xc = -abs(x0+x1-x2-x3), xa = xc-4*sx*(x1-x2), xb = sx*(x0-x1-x2+x3);
    float yc = -abs(y0+y1-y2-y3), ya = yc-4*sy*(y1-y2), yb = sy*(y0-y1-y2+y3);
    // check for curve restrains
    // slope P0-P1 == P2-P3   and  (P0-P3 == P1-P2      or  no slope change)
    assert((x1-x0)*(x2-x3) < EP && ((x3-x0)*(x1-x2) < EP || xb*xb < xa*xc+EP));
    assert((y1-y0)*(y2-y3) < EP && ((y3-y0)*(y1-y2) < EP || yb*yb < ya*yc+EP));
    // quadratic Bezier
    if (xa == 0 && ya == 0) {
      // new midpoint
      sx = cast(int)floorf((3*x1-x0+1)/2);
      sy = cast(int)floorf((3*y1-y0+1)/2);
      return drawQuadBezierSeg(x0, y0, sx, sy, x3, y3, fc);
    }
    x1 = (x1-x0)*(x1-x0)+(y1-y0)*(y1-y0)+1; // line lengths
    x2 = (x2-x3)*(x2-x3)+(y2-y3)*(y2-y3)+1;
    // loop over both ends
    do {
      double ab = xa*yb-xb*ya;
      double ac = xa*yc-xc*ya;
      double bc = xb*yc-xc*yb;
      double ex = ab*(ab+ac-3*bc)+ac*ac; // P0 part of self-intersection loop?
      immutable int f = cast(int)(ex > 0 ? 1 : sqrtf(1+1024/x1)); // calculate resolution
      ab *= f; ac *= f; bc *= f; ex *= f*f; // increase resolution
      // init differences of 1st degree
      double xy = 9*(ab+ac+bc)/8;
      double cb = 8*(xa-ya);
      double dx = 27*(8*ab*(yb*yb-ya*yc)+ex*(ya+2*yb+yc))/64-ya*ya*(xy-ya);
      double dy = 27*(8*ab*(xb*xb-xa*xc)-ex*(xa+2*xb+xc))/64-xa*xa*(xy+xa);
      // init differences of 2nd degree
      double xx = 3*(3*ab*(3*yb*yb-ya*ya-2*ya*yc)-ya*(3*ac*(ya+yb)+ya*cb))/4;
      double yy = 3*(3*ab*(3*xb*xb-xa*xa-2*xa*xc)-xa*(3*ac*(xa+xb)+xa*cb))/4;
      xy = xa*ya*(6*ab+6*ac-3*bc+cb); ac = ya*ya; cb = xa*xa;
      xy = 3*(xy+9*f*(cb*yb*yc-xb*xc*ac)-18*xb*yb*ab)/8;
      // negate values if inside self-intersection loop
      if (ex < 0) { dx = -dx; dy = -dy; xx = -xx; yy = -yy; xy = -xy; ac = -ac; cb = -cb; }
      // init differences of 3rd degree
      ab = 6*ya*ac;
      ac = -6*xa*ac;
      bc = 6*ya*cb;
      cb = -6*xa*cb;
      // error of 1st step
      dx += xy;
      ex = dx+dy;
      dy += xy;
      const(double)* pxy = &xy;
      zzloop: for (int fx = f, fy = f; x0 != x3 && y0 != y3; ) {
        putPixel(x0, y0, fc); // plot curve
        // move sub-steps of one pixel
        do {
          if (dx > *pxy || dy < *pxy) break zzloop; // confusing values
          y1 = 2*ex-dy; // save value for test of y step
          if (2*ex >= dx) { fx--; ex += dx += xx; dy += xy += ac; yy += bc; xx += ab; } // x sub-step
          if (y1 <= 0) { fy--; ex += dy += yy; dx += xy += bc; xx += ac; yy += cb; } // y sub-step
        } while (fx > 0 && fy > 0); // pixel complete?
        if (2*fx <= f) { x0 += sx; fx += f; } // x step
        if (2*fy <= f) { y0 += sy; fy += f; } // y step
        if (pxy == &xy && dx < 0 && dy > 0) pxy = &EP; // pixel ahead valid
      }
      // swap legs
      xx = x0; x0 = x3; x3 = cast(int)xx; sx = -sx; xb = -xb;
      yy = y0; y0 = y3; y3 = cast(int)yy; sy = -sy; yb = -yb; x1 = x2;
    } while (leg--); // try other end
    drawLine(x0, y0, x3, y3, fc); // remaining part in case of cusp or crunode
  }

  // plot any cubic Bezier curve
  final void drawCubicBezier (int x0, int y0, int x1, int y1, int x2, int y2, int x3, int y3, Color fc) {
    int n = 0, i = 0;
    long xc = x0+x1-x2-x3, xa = xc-4*(x1-x2);
    long xb = x0-x1-x2+x3, xd = xb+4*(x1+x2);
    long yc = y0+y1-y2-y3, ya = yc-4*(y1-y2);
    long yb = y0-y1-y2+y3, yd = yb+4*(y1+y2);
    float fx0 = x0, fy0 = y0;
    double t1 = xb*xb-xa*xc;
    double[5] t = void;
    // sub-divide curve at gradient sign changes
    if (xa == 0) { // horizontal
      if (abs(xc) < 2*abs(xb)) t.ptr[n++] = xc/(2.0*xb); // one change
    } else if (t1 > 0.0) { // two changes
      immutable double t2 = sqrtd(t1);
      t1 = (xb-t2)/xa; if (abs(t1) < 1.0) t.ptr[n++] = t1;
      t1 = (xb+t2)/xa; if (abs(t1) < 1.0) t.ptr[n++] = t1;
    }
    t1 = yb*yb-ya*yc;
    if (ya == 0) { // vertical
      if (abs(yc) < 2*abs(yb)) t.ptr[n++] = yc/(2.0*yb); // one change
    } else if (t1 > 0.0) { // two changes
      immutable double t2 = sqrtd(t1);
      t1 = (yb-t2)/ya; if (abs(t1) < 1.0) t.ptr[n++] = t1;
      t1 = (yb+t2)/ya; if (abs(t1) < 1.0) t.ptr[n++] = t1;
    }
    // bubble sort of 4 points
    for (i = 1; i < n; i++) if ((t1 = t.ptr[i-1]) > t.ptr[i]) { t.ptr[i-1] = t.ptr[i]; t.ptr[i] = t1; i = 0; }
    t1 = -1.0; t.ptr[n] = 1.0; // begin / end point
    for (i = 0; i <= n; i++) { // plot each segment separately
      immutable double t2 = t.ptr[i]; // sub-divide at t[i-1], t[i]
      float fx1 = (t1*(t1*xb-2*xc)-t2*(t1*(t1*xa-2*xb)+xc)+xd)/8-fx0;
      float fy1 = (t1*(t1*yb-2*yc)-t2*(t1*(t1*ya-2*yb)+yc)+yd)/8-fy0;
      float fx2 = (t2*(t2*xb-2*xc)-t1*(t2*(t2*xa-2*xb)+xc)+xd)/8-fx0;
      float fy2 = (t2*(t2*yb-2*yc)-t1*(t2*(t2*ya-2*yb)+yc)+yd)/8-fy0;
      immutable float fx3 = (t2*(t2*(3*xb-t2*xa)-3*xc)+xd)/8;
      immutable float fy3 = (t2*(t2*(3*yb-t2*ya)-3*yc)+yd)/8;
      fx0 -= fx3;
      fy0 -= fy3;
      // scale bounds to int
      x3 = lrintf(fx3);
      y3 = lrintf(fy3);
      if (fx0 != 0.0f) { fx1 *= fx0 = (x0-x3)/fx0; fx2 *= fx0; }
      if (fy0 != 0.0f) { fy1 *= fy0 = (y0-y3)/fy0; fy2 *= fy0; }
      if (x0 != x3 || y0 != y3) drawCubicBezierSeg(x0, y0, x0+fx1, y0+fy1, x0+fx2, y0+fy2, x3, y3, fc); // segment t1 - t2
      x0 = x3; y0 = y3; fx0 = fx3; fy0 = fy3; t1 = t2;
    }
  }

  // ////////////////////////////////////////////////////////////////////////// //
  enum BaphometDims = 512; // [0..511]
  final void renderBaphomet (Color fc, float ofsx=0, float ofsy=0, float scalex=1, float scaley=1) {
    auto path = cast(const(ubyte)[])baphometPath;
    immutable plen = path.length;
    uint ppos = 0;

    enum Command {
      Bounds, // always first, has 4 args (x0, y0, x1, y1)
      StrokeMode,
      FillMode,
      StrokeFillMode,
      NormalStroke,
      ThinStroke,
      MoveTo,
      LineTo,
      CubicTo, // cubic bezier
      EndPath,
    }

    Command getCommand () nothrow @trusted @nogc {
      if (ppos >= plen) assert(0, "invalid path");
      return cast(Command)(path.ptr[ppos++]);
    }

    float getFloat () nothrow @trusted @nogc {
      if (ppos >= plen || plen-ppos < float.sizeof) assert(0, "invalid path");
      version(LittleEndian) {
        float res = *cast(const(float)*)(&path.ptr[ppos]);
        ppos += cast(uint)float.sizeof;
        return res;
      } else {
        static assert(float.sizeof == 4);
        uint xp = path.ptr[ppos]|(path.ptr[ppos+1]<<8)|(path.ptr[ppos+2]<<16)|(path.ptr[ppos+3]<<24);
        ppos += cast(uint)float.sizeof;
        return *cast(const(float)*)(&xp);
      }
    }

    int scaleX (float v) nothrow @trusted @nogc { pragma(inline, true); return lrintf(ofsx+v*scalex); }
    int scaleY (float v) nothrow @trusted @nogc { pragma(inline, true); return lrintf(ofsy+v*scaley); }

    int cx = 0, cy = 0;
    while (ppos < plen) {
      auto cmd = getCommand();
      final switch (cmd) {
        case Command.Bounds: ppos += 4*cast(uint)float.sizeof; break;
        case Command.StrokeMode: case Command.FillMode: case Command.StrokeFillMode: break;
        case Command.NormalStroke: case Command.ThinStroke: break;
        case Command.MoveTo:
          cx = scaleX(getFloat());
          cy = scaleY(getFloat());
          break;
        case Command.LineTo:
          immutable int ex = scaleX(getFloat());
          immutable int ey = scaleY(getFloat());
          drawLine(cx, cy, ex, ey, fc);
          cx = ex;
          cy = ey;
          break;
        case Command.CubicTo: // cubic bezier
          immutable int x1 = scaleX(getFloat());
          immutable int y1 = scaleY(getFloat());
          immutable int x2 = scaleX(getFloat());
          immutable int y2 = scaleY(getFloat());
          immutable int ex = scaleX(getFloat());
          immutable int ey = scaleY(getFloat());
          drawCubicBezier(cx, cy, x1, y1, x2, y2, ex, ey, fc);
          cx = ex;
          cy = ey;
          break;
        case Command.EndPath: // don't close this path
          break;
      }
    }
  }

  // ////////////////////////////////////////////////////////////////////////// //
  enum CharWidth = 10, CharHeight = 10;

  void drawChar (int x, int y, char ch, Color c, Color bg=Color.transparent) {
    foreach (immutable dy; 0..10) {
      ushort w = confont10.ptr[ch*10+dy];
      foreach (immutable dx; 0..10) {
        if (w&0x8000) {
          if (c.a != 0) putPixel(x+dx, y+dy, c);
        } else {
          if (bg.a != 0) putPixel(x+dx, y+dy, bg);
        }
        w <<= 1;
      }
    }
  }

  void drawText (int x, int y, const(char)[] text, Color c, Color bg=Color.transparent) {
    foreach (char ch; text) {
      drawChar(x, y, ch, c, bg);
      x += CharWidth;
    }
  }

  void drawTextShadow (int x, int y, const(char)[] text, Color c, Color shadc) {
    drawText(x+1, y+1, text, shadc);
    drawText(x, y, text, c);
  }

  // ////////////////////////////////////////////////////////////////////////// //
  static public __gshared immutable ushort[256*10] confont10 = [
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x3f00,0x4080,0x5280,0x4080,0x5e80,0x4c80,0x2100,0x1e00,
    0x0000,0x0000,0x3f00,0x7f80,0x6d80,0x7f80,0x6180,0x7380,0x3f00,0x1e00,0x0000,0x0000,0x3b80,0x7fc0,0x7fc0,0x7fc0,0x3f80,0x1f00,0x0e00,
    0x0400,0x0000,0x0400,0x0e00,0x1f00,0x3f80,0x7fc0,0x3f80,0x1f00,0x0e00,0x0400,0x0000,0x0000,0x0e00,0x1f00,0x0e00,0x3f80,0x7fc0,0x3580,
    0x0400,0x0e00,0x0000,0x0400,0x0e00,0x1f00,0x3f80,0x7fc0,0x7fc0,0x3580,0x0400,0x0e00,0x0000,0x0000,0x0000,0x0000,0x0c00,0x1e00,0x1e00,
    0x0c00,0x0000,0x0000,0x0000,0xffc0,0xffc0,0xffc0,0xf3c0,0xe1c0,0xe1c0,0xf3c0,0xffc0,0xffc0,0xffc0,0x0000,0x0000,0x1e00,0x3300,0x2100,
    0x2100,0x3300,0x1e00,0x0000,0x0000,0xffc0,0xffc0,0xe1c0,0xccc0,0xdec0,0xdec0,0xccc0,0xe1c0,0xffc0,0xffc0,0x0000,0x0780,0x0380,0x0780,
    0x3e80,0x6600,0x6600,0x6600,0x3c00,0x0000,0x0000,0x1e00,0x3300,0x3300,0x3300,0x1e00,0x0c00,0x3f00,0x0c00,0x0000,0x0400,0x0600,0x0700,
    0x0500,0x0500,0x0400,0x1c00,0x3c00,0x1800,0x0000,0x0000,0x1f80,0x1f80,0x1080,0x1080,0x1180,0x3380,0x7100,0x2000,0x0000,0x0000,0x0c00,
    0x6d80,0x1e00,0x7380,0x7380,0x1e00,0x6d80,0x0c00,0x0000,0x1000,0x1800,0x1c00,0x1e00,0x1f00,0x1e00,0x1c00,0x1800,0x1000,0x0000,0x0100,
    0x0300,0x0700,0x0f00,0x1f00,0x0f00,0x0700,0x0300,0x0100,0x0000,0x0000,0x0c00,0x1e00,0x3f00,0x0c00,0x0c00,0x3f00,0x1e00,0x0c00,0x0000,
    0x0000,0x3300,0x3300,0x3300,0x3300,0x3300,0x0000,0x3300,0x0000,0x0000,0x0000,0x3f80,0x6d80,0x6d80,0x3d80,0x0d80,0x0d80,0x0d80,0x0000,
    0x0000,0x0000,0x1f00,0x3000,0x1f00,0x3180,0x1f00,0x0180,0x1f00,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7f80,0x7f80,0x7f80,
    0x0000,0x0000,0x0000,0x0c00,0x1e00,0x3f00,0x0c00,0x0c00,0x3f00,0x1e00,0x0c00,0xffc0,0x0000,0x0c00,0x1e00,0x3f00,0x0c00,0x0c00,0x0c00,
    0x0c00,0x0c00,0x0000,0x0000,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x3f00,0x1e00,0x0c00,0x0000,0x0000,0x0000,0x0600,0x0300,0x7f80,0x0300,
    0x0600,0x0000,0x0000,0x0000,0x0000,0x0000,0x1800,0x3000,0x7f80,0x3000,0x1800,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x6000,
    0x6000,0x6000,0x7f80,0x0000,0x0000,0x0000,0x0000,0x1100,0x3180,0x7fc0,0x3180,0x1100,0x0000,0x0000,0x0000,0x0000,0x0000,0x0400,0x0e00,
    0x1f00,0x3f80,0x7fc0,0x0000,0x0000,0x0000,0x0000,0x0000,0x7fc0,0x3f80,0x1f00,0x0e00,0x0400,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0c00,0x1e00,0x1e00,0x0c00,0x0c00,0x0000,0x0c00,0x0000,0x0000,0x0000,0x1b00,
    0x1b00,0x1b00,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1b00,0x1b00,0x7fc0,0x1b00,0x7fc0,0x1b00,0x1b00,0x0000,0x0000,0x0400,
    0x1f00,0x3580,0x3400,0x1f00,0x0580,0x3580,0x1f00,0x0400,0x0000,0x0000,0x3180,0x3300,0x0600,0x0c00,0x1980,0x3180,0x0000,0x0000,0x0000,
    0x0000,0x1c00,0x3300,0x3300,0x1f80,0x3300,0x3300,0x1d80,0x0000,0x0000,0x0000,0x0e00,0x0c00,0x1800,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0600,0x0c00,0x1800,0x1800,0x1800,0x0c00,0x0600,0x0000,0x0000,0x0000,0x1800,0x0c00,0x0600,0x0600,0x0600,0x0c00,0x1800,
    0x0000,0x0000,0x0000,0x0000,0x3300,0x1e00,0x7f80,0x1e00,0x3300,0x0000,0x0000,0x0000,0x0000,0x0000,0x0c00,0x0c00,0x3f00,0x0c00,0x0c00,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0c00,0x0c00,0x1800,0x0000,0x0000,0x0000,0x0000,0x0000,0x3f00,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0c00,0x0c00,0x0000,0x0000,0x0000,0x0180,0x0300,0x0600,0x0c00,
    0x1800,0x3000,0x6000,0x0000,0x0000,0x0000,0x1f00,0x3380,0x3780,0x3f80,0x3d80,0x3980,0x1f00,0x0000,0x0000,0x0000,0x0c00,0x1c00,0x0c00,
    0x0c00,0x0c00,0x0c00,0x3f00,0x0000,0x0000,0x0000,0x1f00,0x3180,0x0180,0x0f00,0x1800,0x3180,0x3f80,0x0000,0x0000,0x0000,0x1f00,0x3180,
    0x0180,0x0700,0x0180,0x3180,0x1f00,0x0000,0x0000,0x0000,0x0700,0x0f00,0x1b00,0x3300,0x3f80,0x0300,0x0780,0x0000,0x0000,0x0000,0x3f80,
    0x3000,0x3000,0x3f00,0x0180,0x3180,0x1f00,0x0000,0x0000,0x0000,0x0f00,0x1800,0x3000,0x3f00,0x3180,0x3180,0x1f00,0x0000,0x0000,0x0000,
    0x3f80,0x3180,0x0180,0x0300,0x0600,0x0c00,0x0c00,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3180,0x1f00,0x3180,0x3180,0x1f00,0x0000,0x0000,
    0x0000,0x1f00,0x3180,0x3180,0x1f80,0x0180,0x0300,0x1e00,0x0000,0x0000,0x0000,0x0000,0x0c00,0x0c00,0x0000,0x0000,0x0c00,0x0c00,0x0000,
    0x0000,0x0000,0x0000,0x0c00,0x0c00,0x0000,0x0000,0x0c00,0x0c00,0x1800,0x0000,0x0000,0x0300,0x0600,0x0c00,0x1800,0x0c00,0x0600,0x0300,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x3f00,0x0000,0x3f00,0x0000,0x0000,0x0000,0x0000,0x0000,0x1800,0x0c00,0x0600,0x0300,0x0600,0x0c00,
    0x1800,0x0000,0x0000,0x0000,0x1e00,0x3300,0x0300,0x0300,0x0600,0x0c00,0x0000,0x0c00,0x0000,0x0000,0x3f00,0x6180,0x6780,0x6d80,0x6780,
    0x6000,0x3f00,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3180,0x3f80,0x3180,0x3180,0x3180,0x0000,0x0000,0x0000,0x3f00,0x3180,0x3180,0x3f00,
    0x3180,0x3180,0x3f00,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3000,0x3000,0x3000,0x3180,0x1f00,0x0000,0x0000,0x0000,0x3e00,0x3300,0x3180,
    0x3180,0x3180,0x3300,0x3e00,0x0000,0x0000,0x0000,0x3f80,0x3000,0x3000,0x3f00,0x3000,0x3000,0x3f80,0x0000,0x0000,0x0000,0x3f80,0x3000,
    0x3000,0x3f00,0x3000,0x3000,0x3000,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3000,0x3380,0x3180,0x3180,0x1f00,0x0000,0x0000,0x0000,0x3180,
    0x3180,0x3180,0x3f80,0x3180,0x3180,0x3180,0x0000,0x0000,0x0000,0x1e00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x1e00,0x0000,0x0000,0x0000,
    0x0700,0x0300,0x0300,0x0300,0x3300,0x3300,0x1e00,0x0000,0x0000,0x0000,0x3180,0x3180,0x3300,0x3e00,0x3300,0x3180,0x3180,0x0000,0x0000,
    0x0000,0x3000,0x3000,0x3000,0x3000,0x3000,0x3000,0x3f80,0x0000,0x0000,0x0000,0x6180,0x7380,0x7f80,0x6d80,0x6180,0x6180,0x6180,0x0000,
    0x0000,0x0000,0x3180,0x3980,0x3d80,0x3780,0x3380,0x3180,0x3180,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3180,0x3180,0x3180,0x3180,0x1f00,
    0x0000,0x0000,0x0000,0x3f00,0x3180,0x3180,0x3f00,0x3000,0x3000,0x3000,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3180,0x3180,0x3180,0x3380,
    0x1f00,0x0380,0x0000,0x0000,0x3f00,0x3180,0x3180,0x3f00,0x3300,0x3180,0x3180,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3000,0x1f00,0x0180,
    0x3180,0x1f00,0x0000,0x0000,0x0000,0x7f80,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0000,0x0000,0x0000,0x3180,0x3180,0x3180,0x3180,
    0x3180,0x3180,0x1f00,0x0000,0x0000,0x0000,0x3180,0x3180,0x3180,0x3180,0x1b00,0x0e00,0x0400,0x0000,0x0000,0x0000,0x6180,0x6180,0x6180,
    0x6d80,0x7f80,0x7380,0x6180,0x0000,0x0000,0x0000,0x6180,0x3300,0x1e00,0x0c00,0x1e00,0x3300,0x6180,0x0000,0x0000,0x0000,0x6180,0x6180,
    0x3300,0x1e00,0x0c00,0x0c00,0x0c00,0x0000,0x0000,0x0000,0x3f80,0x0300,0x0600,0x0c00,0x1800,0x3000,0x3f80,0x0000,0x0000,0x0000,0x1e00,
    0x1800,0x1800,0x1800,0x1800,0x1800,0x1e00,0x0000,0x0000,0x0000,0x6000,0x3000,0x1800,0x0c00,0x0600,0x0300,0x0000,0x0000,0x0000,0x0000,
    0x1e00,0x0600,0x0600,0x0600,0x0600,0x0600,0x1e00,0x0000,0x0000,0x0000,0x0400,0x0e00,0x1b00,0x3180,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xffc0,0x0000,0x0000,0x1c00,0x0c00,0x0600,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x1f00,0x0180,0x1f80,0x3180,0x1f80,0x0000,0x0000,0x0000,0x3000,0x3000,0x3f00,0x3180,0x3180,0x3180,0x3f00,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3000,0x3180,0x1f00,0x0000,0x0000,0x0000,0x0180,0x0180,0x1f80,0x3180,0x3180,0x3180,
    0x1f80,0x0000,0x0000,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3f80,0x3000,0x1f00,0x0000,0x0000,0x0000,0x0f00,0x1800,0x1800,0x3e00,0x1800,
    0x1800,0x1800,0x0000,0x0000,0x0000,0x0000,0x0000,0x1f80,0x3180,0x3180,0x3180,0x1f80,0x0180,0x1f00,0x0000,0x3000,0x3000,0x3f00,0x3180,
    0x3180,0x3180,0x3180,0x0000,0x0000,0x0000,0x0c00,0x0000,0x1c00,0x0c00,0x0c00,0x0c00,0x1e00,0x0000,0x0000,0x0000,0x0600,0x0000,0x0e00,
    0x0600,0x0600,0x0600,0x0600,0x0600,0x1c00,0x0000,0x3000,0x3000,0x3180,0x3300,0x3e00,0x3300,0x3180,0x0000,0x0000,0x0000,0x1c00,0x0c00,
    0x0c00,0x0c00,0x0c00,0x0c00,0x0700,0x0000,0x0000,0x0000,0x0000,0x0000,0x3300,0x7f80,0x6d80,0x6d80,0x6180,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x3f00,0x3180,0x3180,0x3180,0x3180,0x0000,0x0000,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3180,0x3180,0x1f00,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x3f00,0x3180,0x3180,0x3f00,0x3000,0x3000,0x0000,0x0000,0x0000,0x0000,0x1f80,0x3180,0x3180,0x1f80,0x0180,0x01c0,0x0000,
    0x0000,0x0000,0x0000,0x3f00,0x3180,0x3000,0x3000,0x3000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1f80,0x3000,0x1f00,0x0180,0x3f00,0x0000,
    0x0000,0x0000,0x1800,0x1800,0x3e00,0x1800,0x1800,0x1800,0x0f00,0x0000,0x0000,0x0000,0x0000,0x0000,0x3180,0x3180,0x3180,0x3180,0x1f80,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x3180,0x3180,0x1b00,0x0e00,0x0400,0x0000,0x0000,0x0000,0x0000,0x0000,0x6180,0x6d80,0x6d80,0x7f80,
    0x3300,0x0000,0x0000,0x0000,0x0000,0x0000,0x3180,0x1b00,0x0e00,0x1b00,0x3180,0x0000,0x0000,0x0000,0x0000,0x0000,0x3180,0x3180,0x3180,
    0x1f80,0x0180,0x1f00,0x0000,0x0000,0x0000,0x0000,0x3f00,0x0600,0x0c00,0x1800,0x3f00,0x0000,0x0000,0x0000,0x0e00,0x1800,0x1800,0x3000,
    0x1800,0x1800,0x0e00,0x0000,0x0000,0x0c00,0x0c00,0x0c00,0x0c00,0x0000,0x0c00,0x0c00,0x0c00,0x0c00,0x0000,0x0000,0x1c00,0x0600,0x0600,
    0x0300,0x0600,0x0600,0x1c00,0x0000,0x0000,0x0000,0x0000,0x0000,0x3800,0x6d80,0x0700,0x0000,0x0000,0x0000,0x0000,0x0000,0x0400,0x0e00,
    0x1b00,0x3180,0x3180,0x3180,0x3f80,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3000,0x3000,0x3000,0x3180,0x1f00,0x0c00,0x1800,0x0000,0x1b00,
    0x0000,0x3180,0x3180,0x3180,0x3180,0x1f80,0x0000,0x0000,0x0600,0x0c00,0x0000,0x1f00,0x3180,0x3f80,0x3000,0x1f00,0x0000,0x0000,0x0e00,
    0x1b00,0x0000,0x1f00,0x0180,0x1f80,0x3180,0x1f80,0x0000,0x0000,0x0000,0x1b00,0x0000,0x1f00,0x0180,0x1f80,0x3180,0x1f80,0x0000,0x0000,
    0x0c00,0x0600,0x0000,0x1f00,0x0180,0x1f80,0x3180,0x1f80,0x0000,0x0000,0x0e00,0x1b00,0x0e00,0x1f00,0x0180,0x1f80,0x3180,0x1f80,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3000,0x3180,0x1f00,0x0c00,0x1800,0x0e00,0x1b00,0x0000,0x1f00,0x3180,0x3f80,0x3000,0x1f00,
    0x0000,0x0000,0x0000,0x1b00,0x0000,0x1f00,0x3180,0x3f80,0x3000,0x1f00,0x0000,0x0000,0x0c00,0x0600,0x0000,0x1f00,0x3180,0x3f80,0x3000,
    0x1f00,0x0000,0x0000,0x0000,0x3600,0x0000,0x1c00,0x0c00,0x0c00,0x0c00,0x1e00,0x0000,0x0000,0x1c00,0x3600,0x0000,0x1c00,0x0c00,0x0c00,
    0x0c00,0x1e00,0x0000,0x0000,0x1800,0x0c00,0x0000,0x1c00,0x0c00,0x0c00,0x0c00,0x1e00,0x0000,0x0000,0x0000,0x1b00,0x0000,0x1f00,0x3180,
    0x3f80,0x3180,0x3180,0x0000,0x0000,0x0e00,0x1b00,0x0e00,0x1f00,0x3180,0x3f80,0x3180,0x3180,0x0000,0x0000,0x0600,0x0c00,0x0000,0x3f80,
    0x3000,0x3f00,0x3000,0x3f80,0x0000,0x0000,0x0000,0x0000,0x0000,0x3b80,0x0ec0,0x3fc0,0x6e00,0x3b80,0x0000,0x0000,0x0000,0x1f80,0x3600,
    0x6600,0x7f80,0x6600,0x6600,0x6780,0x0000,0x0000,0x0e00,0x1b00,0x0000,0x1f00,0x3180,0x3180,0x3180,0x1f00,0x0000,0x0000,0x0000,0x1b00,
    0x0000,0x1f00,0x3180,0x3180,0x3180,0x1f00,0x0000,0x0000,0x0c00,0x0600,0x0000,0x1f00,0x3180,0x3180,0x3180,0x1f00,0x0000,0x0000,0x0e00,
    0x1b00,0x0000,0x3180,0x3180,0x3180,0x3180,0x1f80,0x0000,0x0000,0x0c00,0x0600,0x0000,0x3180,0x3180,0x3180,0x3180,0x1f80,0x0000,0x0000,
    0x0000,0x1b00,0x0000,0x3180,0x3180,0x3180,0x1f80,0x0180,0x1f00,0x0000,0x0000,0x1b00,0x0000,0x1f00,0x3180,0x3180,0x3180,0x1f00,0x0000,
    0x0000,0x0000,0x1b00,0x0000,0x3180,0x3180,0x3180,0x3180,0x1f80,0x0000,0x0000,0x0000,0x0000,0x0400,0x1f00,0x3580,0x3400,0x3580,0x1f00,
    0x0400,0x0000,0x0000,0x0f00,0x1980,0x1800,0x3e00,0x1800,0x1800,0x3000,0x3f80,0x0000,0x0000,0x6180,0x6180,0x3300,0x1e00,0x3f00,0x0c00,
    0x3f00,0x0c00,0x0000,0x0000,0x7f00,0x6180,0x6d80,0x6d80,0x7f00,0x6c00,0x6c00,0x6700,0x0000,0x0000,0x0700,0x0c00,0x0c00,0x1e00,0x0c00,
    0x0c00,0x0c00,0x3800,0x0000,0x0600,0x0c00,0x0000,0x1f00,0x0180,0x1f80,0x3180,0x1f80,0x0000,0x0000,0x0c00,0x1800,0x0000,0x1c00,0x0c00,
    0x0c00,0x0c00,0x1e00,0x0000,0x0000,0x0600,0x0c00,0x0000,0x1f00,0x3180,0x3180,0x3180,0x1f00,0x0000,0x0000,0x0600,0x0c00,0x0000,0x3180,
    0x3180,0x3180,0x3180,0x1f80,0x0000,0x0000,0x1d80,0x3700,0x0000,0x3f00,0x3180,0x3180,0x3180,0x3180,0x0000,0x0000,0x1d80,0x3700,0x0000,
    0x3980,0x3d80,0x3780,0x3380,0x3180,0x0000,0x0000,0x0000,0x1e00,0x0300,0x1f00,0x3300,0x1f00,0x0000,0x0000,0x0000,0x0000,0x0000,0x1e00,
    0x3300,0x3300,0x3300,0x1e00,0x0000,0x0000,0x0000,0x0000,0x0000,0x0c00,0x0000,0x0c00,0x1800,0x3000,0x3000,0x3300,0x1e00,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x3f80,0x3000,0x3000,0x3000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x3f80,0x0180,0x0180,0x0180,0x0000,0x0000,
    0x0000,0x2080,0x2100,0x2200,0x2400,0x0b00,0x1180,0x2300,0x4380,0x0000,0x0000,0x2080,0x2100,0x2200,0x2400,0x0a80,0x1280,0x2380,0x4080,
    0x0000,0x0000,0x0c00,0x0000,0x0c00,0x0c00,0x1e00,0x1e00,0x0c00,0x0000,0x0000,0x0000,0x0000,0x1980,0x3300,0x6600,0x3300,0x1980,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x6600,0x3300,0x1980,0x3300,0x6600,0x0000,0x0000,0x0000,0x2200,0x8880,0x2200,0x8880,0x2200,0x8880,0x2200,
    0x8880,0x2200,0x8880,0x5540,0xaa80,0x5540,0xaa80,0x5540,0xaa80,0x5540,0xaa80,0x5540,0xaa80,0xbb80,0xeec0,0xbb80,0xeec0,0xbb80,0xeec0,
    0xbb80,0xeec0,0xbb80,0xeec0,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0xfc00,
    0xfc00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0xfc00,0xfc00,0x0c00,0x0c00,0xfc00,0xfc00,0x0c00,0x0c00,0x3300,0x3300,0x3300,0x3300,
    0xf300,0xf300,0x3300,0x3300,0x3300,0x3300,0x0000,0x0000,0x0000,0x0000,0xff00,0xff00,0x3300,0x3300,0x3300,0x3300,0x0000,0x0000,0xfc00,
    0xfc00,0x0c00,0x0c00,0xfc00,0xfc00,0x0c00,0x0c00,0x3300,0x3300,0xf300,0xf300,0x0300,0x0300,0xf300,0xf300,0x3300,0x3300,0x3300,0x3300,
    0x3300,0x3300,0x3300,0x3300,0x3300,0x3300,0x3300,0x3300,0x0000,0x0000,0xff00,0xff00,0x0300,0x0300,0xf300,0xf300,0x3300,0x3300,0x3300,
    0x3300,0xf300,0xf300,0x0300,0x0300,0xff00,0xff00,0x0000,0x0000,0x3300,0x3300,0x3300,0x3300,0xff00,0xff00,0x0000,0x0000,0x0000,0x0000,
    0x1800,0x1800,0xf800,0xf800,0x1800,0x1800,0xf800,0xf800,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xfc00,0xfc00,0x0c00,0x0c00,0x0c00,
    0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0fc0,0x0fc0,0x0000,0x0000,0x0000,0x0000,0x0c00,0x0c00,0x0c00,0x0c00,0xffc0,0xffc0,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xffc0,0xffc0,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0fc0,0x0fc0,0x0c00,
    0x0c00,0x0c00,0x0c00,0x0000,0x0000,0x0000,0x0000,0xffc0,0xffc0,0x0000,0x0000,0x0000,0x0000,0x0c00,0x0c00,0x0c00,0x0c00,0xffc0,0xffc0,
    0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0fc0,0x0fc0,0x0c00,0x0c00,0x0fc0,0x0fc0,0x0c00,0x0c00,0x3300,0x3300,0x3300,0x3300,0x33c0,
    0x33c0,0x3300,0x3300,0x3300,0x3300,0x3300,0x3300,0x33c0,0x33c0,0x3000,0x3000,0x3fc0,0x3fc0,0x0000,0x0000,0x0000,0x0000,0x3fc0,0x3fc0,
    0x3000,0x3000,0x33c0,0x33c0,0x3300,0x3300,0x3300,0x3300,0xf3c0,0xf3c0,0x0000,0x0000,0xffc0,0xffc0,0x0000,0x0000,0x0000,0x0000,0xffc0,
    0xffc0,0x0000,0x0000,0xf3c0,0xf3c0,0x3300,0x3300,0x3300,0x3300,0x33c0,0x33c0,0x3000,0x3000,0x33c0,0x33c0,0x3300,0x3300,0x0000,0x0000,
    0xffc0,0xffc0,0x0000,0x0000,0xffc0,0xffc0,0x0000,0x0000,0x3300,0x3300,0xf3c0,0xf3c0,0x0000,0x0000,0xf3c0,0xf3c0,0x3300,0x3300,0x0c00,
    0x0c00,0xffc0,0xffc0,0x0000,0x0000,0xffc0,0xffc0,0x0000,0x0000,0x3300,0x3300,0x3300,0x3300,0xffc0,0xffc0,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0xffc0,0xffc0,0x0000,0x0000,0xffc0,0xffc0,0x0c00,0x0c00,0x0000,0x0000,0x0000,0x0000,0xffc0,0xffc0,0x3300,0x3300,0x3300,
    0x3300,0x3300,0x3300,0x3300,0x3300,0x3fc0,0x3fc0,0x0000,0x0000,0x0000,0x0000,0x0c00,0x0c00,0x0fc0,0x0fc0,0x0c00,0x0c00,0x0fc0,0x0fc0,
    0x0000,0x0000,0x0000,0x0000,0x0fc0,0x0fc0,0x0c00,0x0c00,0x0fc0,0x0fc0,0x0c00,0x0c00,0x0000,0x0000,0x0000,0x0000,0x3fc0,0x3fc0,0x3300,
    0x3300,0x3300,0x3300,0x3300,0x3300,0x3300,0x3300,0xf3c0,0xf3c0,0x3300,0x3300,0x3300,0x3300,0x0c00,0x0c00,0xffc0,0xffc0,0x0000,0x0000,
    0xffc0,0xffc0,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0xfc00,0xfc00,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0fc0,
    0x0fc0,0x0c00,0x0c00,0x0c00,0x0c00,0xffc0,0xffc0,0xffc0,0xffc0,0xffc0,0xffc0,0xffc0,0xffc0,0xffc0,0xffc0,0x0000,0x0000,0x0000,0x0000,
    0x0000,0xffc0,0xffc0,0xffc0,0xffc0,0xffc0,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0x07c0,0x07c0,0x07c0,
    0x07c0,0x07c0,0x07c0,0x07c0,0x07c0,0x07c0,0x07c0,0xffc0,0xffc0,0xffc0,0xffc0,0xffc0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x1d80,0x3700,0x3200,0x3700,0x1d80,0x0000,0x0000,0x0000,0x1e00,0x3300,0x3300,0x3600,0x3300,0x3180,0x3700,0x3000,0x0000,0x0000,
    0x3f80,0x3180,0x3000,0x3000,0x3000,0x3000,0x3000,0x0000,0x0000,0x0000,0x0000,0x7f80,0x3300,0x3300,0x3300,0x3300,0x3300,0x0000,0x0000,
    0x0000,0x3f80,0x1800,0x0c00,0x0600,0x0c00,0x1800,0x3f80,0x0000,0x0000,0x0000,0x0000,0x0000,0x1f80,0x3600,0x3300,0x3300,0x1e00,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x6300,0x6300,0x6700,0x7d80,0x6000,0x6000,0x0000,0x0000,0x0000,0x0000,0x3f00,0x0c00,0x0c00,0x0c00,0x0600,
    0x0000,0x0000,0x0000,0x1e00,0x0c00,0x3f00,0x6d80,0x6d80,0x3f00,0x0c00,0x1e00,0x0000,0x0000,0x1e00,0x3300,0x3300,0x3f00,0x3300,0x3300,
    0x1e00,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3180,0x3180,0x3180,0x1b00,0x3b80,0x0000,0x0000,0x0000,0x1f00,0x0c00,0x0600,0x1f00,0x3180,
    0x3180,0x1f00,0x0000,0x0000,0x0000,0x0000,0x0000,0x3b80,0x66c0,0x64c0,0x6cc0,0x3b80,0x0000,0x0000,0x0000,0x0000,0x0180,0x3f00,0x6780,
    0x6d80,0x7980,0x3f00,0x6000,0x0000,0x0000,0x0000,0x0000,0x1f00,0x3000,0x1e00,0x3000,0x1f00,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3180,
    0x3180,0x3180,0x3180,0x3180,0x0000,0x0000,0x0000,0x0000,0x3f00,0x0000,0x3f00,0x0000,0x3f00,0x0000,0x0000,0x0000,0x0000,0x0c00,0x0c00,
    0x3f00,0x0c00,0x0c00,0x0000,0x3f00,0x0000,0x0000,0x0000,0x0600,0x0c00,0x1800,0x0c00,0x0600,0x0000,0x3f00,0x0000,0x0000,0x0000,0x1800,
    0x0c00,0x0600,0x0c00,0x1800,0x0000,0x3f00,0x0000,0x0000,0x0000,0x0700,0x0d80,0x0d80,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,
    0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x6c00,0x6c00,0x3800,0x0000,0x0000,0x0000,0x0c00,0x0000,0x3f00,0x0000,0x0c00,0x0000,0x0000,0x0000,
    0x0000,0x3800,0x6d80,0x0700,0x0000,0x3800,0x6d80,0x0700,0x0000,0x0000,0x0000,0x0e00,0x1b00,0x1b00,0x0e00,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0c00,0x0c00,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0c00,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x07c0,0x0600,0x0600,0x6600,0x3600,0x1e00,0x0e00,0x0600,0x0200,0x0000,0x3e00,0x3300,0x3300,0x3300,0x3300,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x1e00,0x0300,0x0e00,0x1800,0x1f00,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1e00,0x1e00,0x1e00,
    0x1e00,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
  ];

  private static immutable ubyte[7641] baphometPath = [
    0x01,0x04,0x06,0x30,0x89,0x7f,0x43,0x00,0x80,0xff,0x43,0x08,0xa0,0x1d,0xc6,0x43,0x00,0x80,0xff,0x43,
    0x00,0x80,0xff,0x43,0xa2,0x1d,0xc6,0x43,0x00,0x80,0xff,0x43,0x30,0x89,0x7f,0x43,0x08,0x00,0x80,0xff,
    0x43,0x7a,0x89,0xe5,0x42,0xa0,0x1d,0xc6,0x43,0x00,0x00,0x00,0x00,0x30,0x89,0x7f,0x43,0x00,0x00,0x00,
    0x00,0x08,0x7a,0x89,0xe5,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7a,0x89,0xe5,0x42,0x00,0x00,
    0x00,0x00,0x30,0x89,0x7f,0x43,0x08,0x00,0x00,0x00,0x00,0xa2,0x1d,0xc6,0x43,0x7a,0x89,0xe5,0x42,0x00,
    0x80,0xff,0x43,0x30,0x89,0x7f,0x43,0x00,0x80,0xff,0x43,0x09,0x06,0x30,0x89,0x7f,0x43,0x72,0x87,0xdd,
    0x43,0x08,0x16,0x68,0xb3,0x43,0x72,0x87,0xdd,0x43,0x71,0x87,0xdd,0x43,0x17,0x68,0xb3,0x43,0x71,0x87,
    0xdd,0x43,0x30,0x89,0x7f,0x43,0x08,0x71,0x87,0xdd,0x43,0xd2,0x2f,0x18,0x43,0x16,0x68,0xb3,0x43,0x35,
    0xe2,0x87,0x42,0x30,0x89,0x7f,0x43,0x35,0xe2,0x87,0x42,0x08,0xd1,0x2f,0x18,0x43,0x35,0xe2,0x87,0x42,
    0x35,0xe2,0x87,0x42,0xd2,0x2f,0x18,0x43,0x35,0xe2,0x87,0x42,0x30,0x89,0x7f,0x43,0x08,0x35,0xe2,0x87,
    0x42,0x17,0x68,0xb3,0x43,0xd1,0x2f,0x18,0x43,0x72,0x87,0xdd,0x43,0x30,0x89,0x7f,0x43,0x72,0x87,0xdd,
    0x43,0x09,0x06,0x79,0xcb,0x11,0x43,0x62,0xbf,0xd7,0x42,0x07,0xa4,0x3f,0x7f,0x43,0x0b,0x86,0xdc,0x43,
    0x07,0x6c,0xb9,0xb2,0x43,0xe8,0xd1,0xca,0x42,0x07,0x6e,0x4d,0xa0,0x42,0xa9,0x10,0x9c,0x43,0x07,0xb7,
    0x40,0xd7,0x43,0xa9,0x10,0x9c,0x43,0x07,0x79,0xcb,0x11,0x43,0x62,0xbf,0xd7,0x42,0x09,0x06,0x98,0x42,
    0x74,0x43,0xb1,0x8d,0x68,0x43,0x08,0xd7,0x24,0x79,0x43,0xba,0x83,0x6e,0x43,0xa9,0x16,0x7c,0x43,0x56,
    0xa1,0x76,0x43,0x74,0x2a,0x7d,0x43,0x44,0x73,0x80,0x43,0x08,0x55,0xd1,0x7e,0x43,0xe3,0xea,0x76,0x43,
    0xbc,0x18,0x81,0x43,0x7f,0xa8,0x6e,0x43,0x8f,0x0a,0x84,0x43,0x02,0xfc,0x68,0x43,0x09,0x06,0x92,0x29,
    0x8d,0x43,0x73,0xc3,0x67,0x43,0x08,0xa4,0xd9,0x8e,0x43,0xf2,0xa6,0x7a,0x43,0x8f,0x22,0x88,0x43,0x75,
    0x2a,0x7d,0x43,0x42,0x7f,0x82,0x43,0x08,0xc8,0x88,0x43,0x09,0x06,0xc1,0x79,0x74,0x43,0x50,0x64,0x89,
    0x43,0x08,0x68,0x2d,0x72,0x43,0xee,0x21,0x81,0x43,0xcd,0x97,0x55,0x43,0xe6,0xf1,0x7b,0x43,0x91,0xec,
    0x5d,0x43,0xa8,0xc7,0x6a,0x43,0x09,0x06,0xfa,0xa5,0x52,0x43,0x60,0x97,0x7c,0x43,0x08,0x19,0xff,0x50,
    0x43,0xe9,0x6e,0x8a,0x43,0xb0,0xbd,0x70,0x43,0x4c,0x51,0x82,0x43,0x04,0xeb,0x69,0x43,0x66,0x0f,0x8e,
    0x43,0x09,0x06,0x17,0xbf,0x71,0x43,0x2c,0x58,0x94,0x43,0x08,0x1c,0x96,0x6e,0x43,0x61,0x68,0x99,0x43,
    0x2d,0x3a,0x6e,0x43,0xc8,0x81,0x9e,0x43,0xb7,0x9b,0x72,0x43,0x61,0xa4,0xa3,0x43,0x09,0x06,0x30,0xdb,
    0x82,0x43,0xdb,0xe9,0x93,0x43,0x08,0x11,0x82,0x84,0x43,0x61,0x68,0x99,0x43,0xe8,0x4a,0x84,0x43,0x8e,
    0xa6,0x9e,0x43,0x42,0x7f,0x82,0x43,0x61,0xa4,0xa3,0x43,0x09,0x06,0xc4,0x02,0x85,0x43,0xd1,0x0b,0x92,
    0x43,0x08,0xd6,0xb2,0x86,0x43,0x34,0x1e,0x92,0x43,0x4f,0x58,0x87,0x43,0xa4,0xf1,0x92,0x43,0x03,0xd9,
    0x87,0x43,0x7b,0xc6,0x94,0x43,0x09,0x06,0x87,0x3e,0x64,0x43,0x31,0x3b,0x93,0x43,0x08,0x3b,0xbf,0x64,
    0x43,0x6f,0xf9,0x91,0x43,0x96,0x0b,0x67,0x43,0xc5,0x4a,0x91,0x43,0xcf,0xfe,0x6a,0x43,0x31,0x2f,0x91,
    0x43,0x09,0x06,0x16,0x74,0xb5,0x43,0x08,0xec,0x8e,0x43,0x08,0x1b,0x4b,0xb2,0x43,0xee,0x5d,0x8b,0x43,
    0x48,0x4d,0xad,0x43,0x12,0xa6,0x8a,0x43,0xf3,0xd7,0xa7,0x43,0x74,0xb8,0x8a,0x43,0x08,0x8c,0xb2,0xa0,
    0x43,0xcd,0xf8,0x8a,0x43,0x68,0x46,0x9b,0x43,0x79,0x8f,0x87,0x43,0x49,0xc9,0x96,0x43,0xe9,0x3e,0x82,
    0x43,0x08,0x60,0x5c,0x97,0x43,0xa1,0xde,0x8b,0x43,0x4e,0xa0,0x93,0x43,0x31,0x3b,0x93,0x43,0x9f,0xea,
    0x8d,0x43,0x27,0x8d,0x99,0x43,0x08,0x07,0xe0,0x8c,0x43,0x06,0x34,0x9b,0x43,0x38,0xe9,0x8c,0x43,0x46,
    0x0a,0x9e,0x43,0x3d,0xcc,0x8b,0x43,0xb2,0x06,0xa2,0x43,0x08,0xf1,0x40,0x8a,0x43,0xb0,0x12,0xa4,0x43,
    0x39,0xd1,0x88,0x43,0x76,0x43,0xa6,0x43,0xfa,0x06,0x88,0x43,0xa4,0x75,0xa9,0x43,0x08,0x19,0x6c,0x88,
    0x43,0x9f,0x9e,0xac,0x43,0x66,0xeb,0x87,0x43,0x44,0x76,0xb0,0x43,0x6b,0xce,0x86,0x43,0x3b,0xbc,0xb4,
    0x43,0x08,0xa9,0x8c,0x85,0x43,0x06,0xd0,0xb5,0x43,0xfa,0xee,0x83,0x43,0x74,0xa3,0xb6,0x43,0x3d,0x90,
    0x81,0x43,0x31,0xf6,0xb6,0x43,0x08,0x9d,0x61,0x7d,0x43,0xee,0x48,0xb7,0x43,0x3b,0x1f,0x75,0x43,0xcf,
    0xe3,0xb6,0x43,0xee,0x6f,0x6d,0x43,0x68,0xe2,0xb5,0x43,0x08,0xd4,0xed,0x6b,0x43,0x87,0x2f,0xb2,0x43,
    0x0e,0xc9,0x6b,0x43,0xa7,0x7c,0xae,0x43,0x98,0xfa,0x67,0x43,0xab,0x53,0xab,0x43,0x08,0x25,0x2c,0x64,
    0x43,0x33,0xa2,0xa8,0x43,0x40,0x96,0x61,0x43,0xc3,0xc2,0xa5,0x43,0x64,0xde,0x60,0x43,0xfa,0xa2,0xa2,
    0x43,0x08,0xb0,0x5d,0x60,0x43,0x06,0x4c,0x9f,0x43,0x9a,0xca,0x5f,0x43,0x38,0x3d,0x9b,0x43,0x3b,0x8f,
    0x5c,0x43,0x85,0xb0,0x98,0x43,0x08,0x42,0x36,0x51,0x43,0x3d,0xf0,0x91,0x43,0xcd,0x4f,0x49,0x43,0xdb,
    0xb9,0x8b,0x43,0xe0,0xdb,0x44,0x43,0x42,0x8b,0x84,0x43,0x08,0x7e,0xc9,0x44,0x43,0x8a,0x57,0x8d,0x43,
    0xbc,0x6c,0x0f,0x43,0x23,0x62,0x8e,0x43,0xf5,0x17,0x07,0x43,0xc5,0x3e,0x8f,0x43,0x09,0x06,0xe0,0xea,
    0x76,0x43,0xab,0xef,0xc5,0x43,0x08,0x12,0x00,0x79,0x43,0xab,0xcb,0xbf,0x43,0x79,0xb9,0x6d,0x43,0x7e,
    0x8d,0xba,0x43,0xee,0x6f,0x6d,0x43,0x98,0xeb,0xb5,0x43,0x08,0xe0,0x02,0x7b,0x43,0x5f,0x1c,0xb8,0x43,
    0x85,0x2c,0x82,0x43,0xe9,0x65,0xb8,0x43,0xd6,0xb2,0x86,0x43,0xc6,0x05,0xb5,0x43,0x08,0x03,0xcd,0x85,
    0x43,0x5a,0x39,0xb9,0x43,0xe4,0x4f,0x81,0x43,0xdb,0xd4,0xbf,0x43,0xdf,0x6c,0x82,0x43,0xbc,0x93,0xc5,
    0x43,0x09,0x06,0xf0,0xd0,0x22,0x43,0x5d,0x19,0x08,0x43,0x08,0xbc,0xab,0x49,0x43,0x4a,0x35,0x29,0x43,
    0xcb,0xf7,0x65,0x43,0xce,0x37,0x45,0x43,0x0e,0x99,0x63,0x43,0x67,0xc6,0x5c,0x43,0x09,0x06,0x05,0x94,
    0xab,0x43,0xc2,0x13,0x04,0x43,0x08,0x9f,0x26,0x98,0x43,0x11,0x42,0x25,0x43,0x97,0x00,0x8a,0x43,0x32,
    0x32,0x41,0x43,0xf5,0x2f,0x8b,0x43,0xc7,0xc0,0x58,0x43,0x09,0x06,0x8f,0x85,0x48,0x43,0xe0,0xa8,0x8c,
    0x43,0x08,0x55,0xaa,0x48,0x43,0xe0,0xa8,0x8c,0x43,0x6b,0x3d,0x49,0x43,0xc1,0x43,0x8c,0x43,0x31,0x62,
    0x49,0x43,0xc1,0x43,0x8c,0x43,0x08,0x2f,0xe3,0x2f,0x43,0xad,0xe7,0x98,0x43,0xff,0x0d,0x0d,0x43,0xad,
    0xf3,0x9a,0x43,0xf0,0xaf,0xcc,0x42,0x74,0x00,0x97,0x43,0x08,0xbb,0xa2,0xf7,0x42,0x93,0x4d,0x93,0x43,
    0x5e,0x19,0x08,0x43,0x5a,0x2a,0x87,0x43,0x23,0x6e,0x10,0x43,0x42,0x97,0x86,0x43,0x08,0xca,0xe8,0x33,
    0x43,0x1b,0x3c,0x80,0x43,0x80,0xe8,0x4d,0x43,0xda,0xf4,0x70,0x43,0xae,0x0e,0x4f,0x43,0x2b,0x1b,0x65,
    0x43,0x08,0x66,0x96,0x54,0x43,0xa3,0xe1,0x3b,0x43,0x4e,0xc4,0x19,0x43,0xa0,0x1a,0x16,0x43,0x10,0xe2,
    0x14,0x43,0x26,0x14,0xe0,0x42,0x08,0x5c,0x91,0x1c,0x43,0xcb,0x27,0xee,0x42,0xa9,0x40,0x24,0x43,0x71,
    0x3b,0xfc,0x42,0xf3,0xef,0x2b,0x43,0x8b,0x27,0x05,0x43,0x08,0xe2,0x4b,0x2c,0x43,0x48,0x86,0x07,0x43,
    0x79,0x62,0x2f,0x43,0x05,0xe5,0x09,0x43,0x55,0x32,0x34,0x43,0xa0,0xd2,0x09,0x43,0x08,0x74,0xa3,0x36,
    0x43,0x3a,0xd1,0x08,0x43,0x7e,0x81,0x38,0x43,0x09,0xd4,0x0a,0x43,0x0d,0xba,0x39,0x43,0xa0,0xea,0x0d,
    0x43,0x08,0x6f,0xe4,0x3d,0x43,0x43,0xc7,0x0e,0x43,0xd6,0xe5,0x3e,0x43,0xc4,0x4a,0x11,0x43,0x55,0x7a,
    0x40,0x43,0x59,0x72,0x13,0x43,0x08,0x55,0x92,0x44,0x43,0xbf,0x73,0x14,0x43,0x23,0x95,0x46,0x43,0xa5,
    0x09,0x17,0x43,0xe0,0xf3,0x48,0x43,0xfe,0x55,0x19,0x43,0x08,0xcd,0x4f,0x49,0x43,0xaa,0x10,0x1c,0x43,
    0x61,0x77,0x4b,0x43,0xfe,0x6d,0x1d,0x43,0x80,0xe8,0x4d,0x43,0x2b,0x94,0x1e,0x43,0x08,0x58,0xc9,0x51,
    0x43,0x41,0x27,0x1f,0x43,0x9b,0x82,0x53,0x43,0x35,0x72,0x20,0x43,0x53,0xf2,0x54,0x43,0x88,0xcf,0x21,
    0x43,0x08,0x7b,0x29,0x55,0x43,0xe8,0x0a,0x25,0x43,0xb2,0x2d,0x58,0x43,0xef,0xe8,0x26,0x43,0x9b,0xb2,
    0x5b,0x43,0xd0,0x8f,0x28,0x43,0x08,0x5f,0xef,0x5f,0x43,0xeb,0x11,0x2a,0x43,0xfd,0xdc,0x5f,0x43,0x6e,
    0x95,0x2c,0x43,0x3b,0xa7,0x60,0x43,0x2b,0xf4,0x2e,0x43,0x08,0x06,0xbb,0x61,0x43,0xfd,0xe5,0x31,0x43,
    0xe7,0x61,0x63,0x43,0xef,0x30,0x33,0x43,0x53,0x52,0x65,0x43,0xa3,0xb1,0x33,0x43,0x08,0x12,0xa0,0x68,
    0x43,0x7f,0x69,0x34,0x43,0x40,0xc6,0x69,0x43,0x64,0xff,0x36,0x43,0x7e,0x90,0x6a,0x43,0x71,0xcc,0x39,
    0x43,0x08,0xbc,0x5a,0x6b,0x43,0x51,0x73,0x3b,0x43,0xc1,0x49,0x6c,0x43,0xa5,0xd0,0x3c,0x43,0xe0,0xba,
    0x6e,0x43,0xb8,0x74,0x3c,0x43,0x08,0x6b,0x1c,0x73,0x43,0x13,0xc1,0x3e,0x43,0x40,0xf6,0x71,0x43,0xce,
    0x1f,0x41,0x43,0x55,0x89,0x72,0x43,0x8d,0x7e,0x43,0x43,0x08,0x68,0x2d,0x72,0x43,0x89,0xae,0x4b,0x43,
    0xc1,0x79,0x74,0x43,0xcb,0x78,0x4c,0x43,0x55,0xa1,0x76,0x43,0x5b,0xb1,0x4d,0x43,0x08,0xa2,0x38,0x7a,
    0x43,0xd1,0x56,0x4e,0x43,0x85,0xb6,0x78,0x43,0xb1,0x15,0x54,0x43,0x83,0xc7,0x77,0x43,0x89,0x0e,0x5c,
    0x43,0x08,0xcf,0x46,0x77,0x43,0x0f,0x81,0x5f,0x43,0x1a,0xde,0x7a,0x43,0xce,0xc7,0x5d,0x43,0x42,0x73,
    0x80,0x43,0x99,0xc3,0x5a,0x43,0x08,0x85,0x2c,0x82,0x43,0xf6,0xe6,0x59,0x43,0x81,0x3d,0x81,0x43,0x16,
    0x10,0x50,0x43,0xd6,0x8e,0x80,0x43,0x5b,0x99,0x49,0x43,0x08,0xc4,0xea,0x80,0x43,0x22,0x95,0x46,0x43,
    0xfa,0xe2,0x81,0x43,0xda,0xec,0x43,0x43,0x78,0x77,0x83,0x43,0xe4,0xb2,0x41,0x43,0x08,0x8a,0x27,0x85,
    0x43,0x86,0x77,0x3e,0x43,0x0c,0x9f,0x85,0x43,0x07,0xf4,0x3b,0x43,0x8f,0x16,0x86,0x43,0xe6,0x82,0x39,
    0x43,0x08,0x85,0x44,0x86,0x43,0x37,0xd9,0x35,0x43,0x1e,0x4f,0x87,0x43,0xe1,0x7b,0x34,0x43,0xdf,0x90,
    0x88,0x43,0xb6,0x55,0x33,0x43,0x08,0xae,0x93,0x8a,0x43,0xfd,0xe5,0x31,0x43,0xfa,0x12,0x8a,0x43,0xbf,
    0x03,0x2d,0x43,0x19,0x78,0x8a,0x43,0x45,0x5e,0x2c,0x43,0x08,0x03,0xf1,0x8b,0x43,0xac,0x47,0x29,0x43,
    0x2f,0x17,0x8d,0x43,0x45,0x46,0x28,0x43,0xc8,0x21,0x8e,0x43,0x30,0xb3,0x27,0x43,0x08,0xa9,0xc8,0x8f,
    0x43,0xef,0xe8,0x26,0x43,0xbf,0x5b,0x90,0x43,0x5b,0xc1,0x24,0x43,0x10,0xca,0x90,0x43,0xa0,0x62,0x22,
    0x43,0x08,0x26,0x5d,0x91,0x43,0xbb,0xcc,0x1f,0x43,0xf0,0x70,0x92,0x43,0x78,0x13,0x1e,0x43,0x77,0xd7,
    0x93,0x43,0x73,0x24,0x1d,0x43,0x08,0x65,0x3f,0x96,0x43,0xce,0x58,0x1b,0x43,0xbe,0x7f,0x96,0x43,0xbf,
    0x8b,0x18,0x43,0x60,0x5c,0x97,0x43,0xb6,0xad,0x16,0x43,0x08,0xba,0xa8,0x99,0x43,0x78,0xcb,0x11,0x43,
    0x49,0xe1,0x9a,0x43,0x78,0xcb,0x11,0x43,0x01,0x51,0x9c,0x43,0x73,0xdc,0x10,0x43,0x08,0x72,0x24,0x9d,
    0x43,0xd2,0xff,0x0f,0x43,0x1c,0xd3,0x9d,0x43,0x07,0xec,0x0e,0x43,0xeb,0xc9,0x9d,0x43,0xe8,0x7a,0x0c,
    0x43,0x08,0x60,0x80,0x9d,0x43,0xd7,0xbe,0x08,0x43,0x4d,0xe8,0x9f,0x43,0x86,0x50,0x08,0x43,0x25,0xbd,
    0xa1,0x43,0x5b,0x2a,0x07,0x43,0x08,0x99,0x7f,0xa3,0x43,0xc9,0xf1,0x05,0x43,0x48,0x1d,0xa5,0x43,0x86,
    0x38,0x04,0x43,0x6c,0x71,0xa6,0x43,0x18,0x59,0x01,0x43,0x08,0x32,0x96,0xa6,0x43,0x6e,0x64,0xff,0x42,
    0x48,0x29,0xa7,0x43,0xed,0xcf,0xfd,0x42,0x5f,0xbc,0xa7,0x43,0x71,0x3b,0xfc,0x42,0x08,0xf3,0xe3,0xa9,
    0x43,0xf7,0x7d,0xf7,0x42,0xd8,0x6d,0xaa,0x43,0x45,0xe5,0xf2,0x42,0x48,0x41,0xab,0x43,0xcb,0x27,0xee,
    0x42,0x08,0x24,0xf9,0xab,0x43,0x52,0x6a,0xe9,0x42,0xee,0x0c,0xad,0x43,0x4c,0x8c,0xe7,0x42,0x1b,0x33,
    0xae,0x43,0xcc,0xf7,0xe5,0x42,0x08,0xaa,0x6b,0xaf,0x43,0xe8,0x61,0xe3,0x42,0x90,0xf5,0xaf,0x43,0xc9,
    0xf0,0xe0,0x42,0xe0,0x63,0xb0,0x43,0xe5,0x5a,0xde,0x42,0x08,0xaa,0x83,0xb3,0x43,0x29,0x2d,0x09,0x43,
    0x6a,0xfe,0x8e,0x43,0xb8,0x74,0x3c,0x43,0xd5,0x06,0x95,0x43,0xe6,0x79,0x67,0x43,0x08,0x2f,0x53,0x97,
    0x43,0xe9,0xb0,0x74,0x43,0xa8,0x28,0xa0,0x43,0x43,0xfd,0x76,0x43,0x83,0x28,0xad,0x43,0x17,0x59,0x81,
    0x43,0x08,0x3d,0xe7,0xbf,0x43,0x4b,0x8d,0x8c,0x43,0xae,0x96,0xba,0x43,0x66,0x27,0x92,0x43,0x15,0xe0,
    0xc7,0x43,0x6f,0x11,0x96,0x43,0x08,0x7e,0x5d,0xb2,0x43,0xdb,0x01,0x98,0x43,0x9e,0x56,0xa0,0x43,0x80,
    0xc1,0x97,0x43,0x69,0x2e,0x97,0x43,0x31,0x17,0x8d,0x43,0x09,0x06,0xab,0xa7,0x39,0x43,0x67,0x0f,0x0e,
    0x43,0x08,0xdb,0xbc,0x3b,0x43,0xe8,0x92,0x10,0x43,0xb5,0x85,0x3b,0x43,0x97,0x3c,0x14,0x43,0xab,0xa7,
    0x39,0x43,0x0c,0x0b,0x18,0x43,0x09,0x06,0xca,0x30,0x40,0x43,0x30,0x3b,0x13,0x43,0x08,0x17,0xc8,0x43,
    0x43,0xa5,0x09,0x17,0x43,0x7e,0xc9,0x44,0x43,0x1a,0xd8,0x1a,0x43,0x9d,0x22,0x43,0x43,0x8d,0xa6,0x1e,
    0x43,0x09,0x06,0xc8,0x78,0x4c,0x43,0xed,0xc9,0x1d,0x43,0x08,0x0b,0x32,0x4e,0x43,0x22,0xce,0x20,0x43,
    0x23,0xc5,0x4e,0x43,0x58,0xd2,0x23,0x43,0x0b,0x32,0x4e,0x43,0x2b,0xc4,0x26,0x43,0x09,0x06,0xec,0x08,
    0x58,0x43,0xc7,0xb1,0x26,0x43,0x08,0x02,0x9c,0x58,0x43,0xef,0x00,0x2b,0x43,0xd9,0x64,0x58,0x43,0x02,
    0xbd,0x2e,0x43,0x10,0x51,0x57,0x43,0x37,0xc1,0x31,0x43,0x09,0x06,0xcb,0xdf,0x61,0x43,0x4a,0x65,0x31,
    0x43,0x08,0xbe,0x2a,0x63,0x43,0xbd,0x33,0x35,0x43,0x32,0xe1,0x62,0x43,0x56,0x4a,0x38,0x43,0xde,0x83,
    0x61,0x43,0x3c,0xe0,0x3a,0x43,0x09,0x06,0x1c,0x7e,0x6a,0x43,0x5b,0x39,0x39,0x43,0x08,0x31,0x11,0x6b,
    0x43,0x0c,0xd2,0x3d,0x43,0x1c,0x7e,0x6a,0x43,0x13,0xd9,0x42,0x43,0xd9,0xc4,0x68,0x43,0xcb,0x60,0x48,
    0x43,0x09,0x06,0xe5,0xc1,0x73,0x43,0x16,0xf8,0x4b,0x43,0x08,0xa6,0xf7,0x72,0x43,0xb1,0xfd,0x4f,0x43,
    0x3b,0x07,0x71,0x43,0x4a,0x14,0x53,0x43,0xa2,0xf0,0x6d,0x43,0x7c,0x29,0x55,0x43,0x09,0x06,0x00,0x8d,
    0xa6,0x43,0xef,0x21,0x01,0x43,0x08,0x52,0xfb,0xa6,0x43,0xce,0xc8,0x02,0x43,0xe6,0x16,0xa7,0x43,0x51,
    0x4c,0x05,0x43,0x3b,0x68,0xa6,0x43,0x4c,0x75,0x08,0x43,0x09,0x06,0xde,0x20,0xa1,0x43,0x86,0x50,0x08,
    0x43,0x08,0xd4,0x4e,0xa1,0x43,0xd3,0xe7,0x0b,0x43,0xb5,0xe9,0xa0,0x43,0x59,0x5a,0x0f,0x43,0xba,0xcc,
    0x9f,0x43,0x54,0x83,0x12,0x43,0x09,0x06,0x77,0xfb,0x99,0x43,0x6c,0x16,0x13,0x43,0x08,0xde,0xfc,0x9a,
    0x43,0x4a,0xbd,0x14,0x43,0x06,0x34,0x9b,0x43,0xfe,0x55,0x19,0x43,0x13,0xe9,0x99,0x43,0x41,0x27,0x1f,
    0x43,0x09,0x06,0x46,0xce,0x93,0x43,0x26,0xa5,0x1d,0x43,0x08,0xe7,0xaa,0x94,0x43,0xbb,0xcc,0x1f,0x43,
    0x18,0xb4,0x94,0x43,0xa8,0x40,0x24,0x43,0xe2,0xbb,0x93,0x43,0x21,0xfe,0x28,0x43,0x09,0x06,0xb1,0x8e,
    0x8d,0x43,0xa8,0x58,0x28,0x43,0x08,0x19,0x90,0x8e,0x43,0x54,0x13,0x2b,0x43,0xa4,0xd9,0x8e,0x43,0x84,
    0x40,0x31,0x43,0x46,0xaa,0x8d,0x43,0x29,0x24,0x37,0x43,0x09,0x06,0xd6,0xbe,0x88,0x43,0xef,0x30,0x33,
    0x43,0x08,0x0c,0xb7,0x89,0x43,0x0e,0xa2,0x35,0x43,0xc0,0x37,0x8a,0x43,0x7a,0xaa,0x3b,0x43,0xbb,0x48,
    0x89,0x43,0xbb,0x7b,0x41,0x43,0x09,0x06,0x3a,0xad,0x82,0x43,0xc4,0x59,0x43,0x43,0x08,0xd2,0xb7,0x83,
    0x43,0x2b,0x5b,0x44,0x43,0x35,0xd6,0x85,0x43,0x48,0xf5,0x49,0x43,0x42,0x97,0x86,0x43,0xc4,0xa1,0x4f,
    0x43,0x09,0x06,0x9c,0xb3,0x80,0x43,0x48,0x55,0x5a,0x43,0x08,0xff,0xc5,0x80,0x43,0x09,0x73,0x55,0x43,
    0x93,0xe1,0x80,0x43,0x0f,0x39,0x53,0x43,0xf1,0xbe,0x7e,0x43,0x18,0xe7,0x4c,0x43,0x09,0x06,0xe0,0x02,
    0x7b,0x43,0x92,0xec,0x5d,0x43,0x08,0x09,0x3a,0x7b,0x43,0xf0,0xf7,0x58,0x43,0x09,0x3a,0x7b,0x43,0xe6,
    0x31,0x5b,0x43,0xe0,0x02,0x7b,0x43,0xa8,0x4f,0x56,0x43,0x09,0x06,0x39,0x4f,0x7d,0x43,0x3e,0x8f,0x5c,
    0x43,0x08,0xe9,0xe0,0x7c,0x43,0x03,0x9c,0x58,0x43,0x1e,0x2b,0x81,0x43,0x7f,0x30,0x5a,0x43,0xff,0x73,
    0x7d,0x43,0xf6,0xb6,0x51,0x43,0x09,0x06,0x5c,0xb8,0x52,0x43,0x28,0x21,0x87,0x43,0x08,0xae,0x3e,0x57,
    0x43,0x12,0x9a,0x88,0x43,0x23,0xf5,0x56,0x43,0x04,0xf1,0x8b,0x43,0x25,0xfc,0x5b,0x43,0x85,0x74,0x8e,
    0x43,0x08,0x2f,0xf2,0x61,0x43,0x8e,0x52,0x90,0x43,0xd9,0xdc,0x6c,0x43,0x85,0x74,0x8e,0x43,0xc6,0x20,
    0x69,0x43,0x3d,0xd8,0x8d,0x43,0x08,0x6d,0x8c,0x5a,0x43,0xf5,0x3b,0x8d,0x43,0x3d,0x77,0x58,0x43,0xa1,
    0xc6,0x87,0x43,0xf8,0xed,0x5e,0x43,0x5e,0x0d,0x86,0x43,0x09,0x06,0xde,0xcc,0x92,0x43,0xf7,0x17,0x87,
    0x43,0x08,0xb6,0x89,0x90,0x43,0xae,0x87,0x88,0x43,0x4a,0xa5,0x90,0x43,0xa1,0xde,0x8b,0x43,0xf9,0x2a,
    0x8e,0x43,0x23,0x62,0x8e,0x43,0x08,0xf5,0x2f,0x8b,0x43,0x5c,0x49,0x90,0x43,0x35,0xd6,0x85,0x43,0x8e,
    0x46,0x8e,0x43,0x3d,0xb4,0x87,0x43,0x47,0xaa,0x8d,0x43,0x08,0x6a,0xfe,0x8e,0x43,0xff,0x0d,0x8d,0x43,
    0xbb,0x6c,0x8f,0x43,0xf7,0x17,0x87,0x43,0x5c,0x31,0x8c,0x43,0xb2,0x5e,0x85,0x43,0x09,0x06,0x60,0x38,
    0x91,0x43,0x69,0x5d,0x7a,0x43,0x08,0x34,0x1e,0x92,0x43,0x1e,0x5b,0x89,0x43,0x04,0x63,0x7e,0x43,0x5e,
    0x01,0x84,0x43,0x59,0x2a,0x87,0x43,0x0d,0xcf,0x8d,0x43,0x09,0x03,0x04,0x06,0x5a,0x18,0x63,0x43,0x82,
    0x79,0x8b,0x43,0x08,0x25,0x2c,0x64,0x43,0x82,0x79,0x8b,0x43,0x2a,0x1b,0x65,0x43,0x9d,0xef,0x8a,0x43,
    0x2a,0x1b,0x65,0x43,0xc1,0x37,0x8a,0x43,0x08,0x2a,0x1b,0x65,0x43,0x17,0x89,0x89,0x43,0x25,0x2c,0x64,
    0x43,0x31,0xff,0x88,0x43,0x5a,0x18,0x63,0x43,0x31,0xff,0x88,0x43,0x08,0xf3,0x16,0x62,0x43,0x31,0xff,
    0x88,0x43,0xee,0x27,0x61,0x43,0x17,0x89,0x89,0x43,0xee,0x27,0x61,0x43,0xc1,0x37,0x8a,0x43,0x08,0xee,
    0x27,0x61,0x43,0x9d,0xef,0x8a,0x43,0xf3,0x16,0x62,0x43,0x82,0x79,0x8b,0x43,0x5a,0x18,0x63,0x43,0x82,
    0x79,0x8b,0x43,0x09,0x06,0x4f,0x64,0x89,0x43,0x82,0x79,0x8b,0x43,0x08,0x34,0xee,0x89,0x43,0x82,0x79,
    0x8b,0x43,0x85,0x5c,0x8a,0x43,0x9d,0xef,0x8a,0x43,0x85,0x5c,0x8a,0x43,0xc1,0x37,0x8a,0x43,0x08,0x85,
    0x5c,0x8a,0x43,0x17,0x89,0x89,0x43,0x34,0xee,0x89,0x43,0x31,0xff,0x88,0x43,0x4f,0x64,0x89,0x43,0x31,
    0xff,0x88,0x43,0x08,0x9c,0xe3,0x88,0x43,0x31,0xff,0x88,0x43,0x19,0x6c,0x88,0x43,0x17,0x89,0x89,0x43,
    0x19,0x6c,0x88,0x43,0xc1,0x37,0x8a,0x43,0x08,0x19,0x6c,0x88,0x43,0x9d,0xef,0x8a,0x43,0x9c,0xe3,0x88,
    0x43,0x82,0x79,0x8b,0x43,0x4f,0x64,0x89,0x43,0x82,0x79,0x8b,0x43,0x09,0x02,0x04,0x06,0x19,0x60,0x86,
    0x43,0xec,0xed,0xa3,0x43,0x08,0x35,0xd6,0x85,0x43,0x76,0x43,0xa6,0x43,0x93,0xe1,0x80,0x43,0x57,0x02,
    0xac,0x43,0x61,0xd8,0x80,0x43,0x87,0x17,0xae,0x43,0x08,0xa5,0x85,0x80,0x43,0xc3,0xfe,0xaf,0x43,0xce,
    0xbc,0x80,0x43,0x83,0x40,0xb1,0x43,0xa5,0x91,0x82,0x43,0x79,0x6e,0xb1,0x43,0x08,0x23,0x26,0x84,0x43,
    0x40,0x93,0xb1,0x43,0x30,0xe7,0x84,0x43,0xbe,0x1b,0xb1,0x43,0x11,0x82,0x84,0x43,0xab,0x6b,0xaf,0x43,
    0x08,0xb7,0x41,0x84,0x43,0x3b,0x98,0xae,0x43,0xb7,0x41,0x84,0x43,0xc3,0xf2,0xad,0x43,0xa1,0xae,0x83,
    0x43,0x83,0x28,0xad,0x43,0x08,0xb2,0x52,0x83,0x43,0x80,0x39,0xac,0x43,0x81,0x49,0x83,0x43,0xf0,0x00,
    0xab,0x43,0xe4,0x67,0x85,0x43,0x76,0x4f,0xa8,0x43,0x08,0x9c,0xd7,0x86,0x43,0xd1,0x83,0xa6,0x43,0xec,
    0x45,0x87,0x43,0x01,0x75,0xa2,0x43,0x19,0x60,0x86,0x43,0xec,0xed,0xa3,0x43,0x09,0x06,0xd9,0xdc,0x6c,
    0x43,0x14,0x25,0xa4,0x43,0x08,0xa2,0xf0,0x6d,0x43,0x9f,0x7a,0xa6,0x43,0x47,0xec,0x77,0x43,0x80,0x39,
    0xac,0x43,0xa9,0xfe,0x77,0x43,0xb0,0x4e,0xae,0x43,0x08,0x23,0xa4,0x78,0x43,0xea,0x35,0xb0,0x43,0xd2,
    0x35,0x78,0x43,0xab,0x77,0xb1,0x43,0xc1,0x79,0x74,0x43,0xa2,0xa5,0xb1,0x43,0x08,0xc6,0x50,0x71,0x43,
    0x68,0xca,0xb1,0x43,0xab,0xce,0x6f,0x43,0xe7,0x52,0xb1,0x43,0xea,0x98,0x70,0x43,0xd4,0xa2,0xaf,0x43,
    0x08,0x9d,0x19,0x71,0x43,0x96,0xd8,0xae,0x43,0x9d,0x19,0x71,0x43,0xec,0x29,0xae,0x43,0xca,0x3f,0x72,
    0x43,0xab,0x5f,0xad,0x43,0x08,0xa6,0xf7,0x72,0x43,0xa7,0x70,0xac,0x43,0x09,0x0a,0x73,0x43,0x17,0x38,
    0xab,0x43,0x44,0xcd,0x6e,0x43,0x9f,0x86,0xa8,0x43,0x08,0xd4,0xed,0x6b,0x43,0xf8,0xba,0xa6,0x43,0x31,
    0x11,0x6b,0x43,0x2a,0xac,0xa2,0x43,0xd9,0xdc,0x6c,0x43,0x14,0x25,0xa4,0x43,0x09,0x01,0x05,0x06,0x66,
    0x5d,0x7a,0x43,0x74,0xeb,0xc2,0x43,0x08,0x09,0x22,0x77,0x43,0x50,0xbb,0xc7,0x43,0xe9,0xe0,0x7c,0x43,
    0xf5,0x86,0xc9,0x43,0x8f,0x94,0x7a,0x43,0xc5,0x95,0xcd,0x43,0x09,0x06,0x08,0x98,0x80,0x43,0x6b,0x19,
    0xc3,0x43,0x08,0xb7,0x35,0x82,0x43,0x79,0xf2,0xc7,0x43,0xf1,0xbe,0x7e,0x43,0x1e,0xbe,0xc9,0x43,0x73,
    0x7c,0x80,0x43,0xec,0xcc,0xcd,0x43,0x09,0x06,0x28,0xab,0x7d,0x43,0xae,0xde,0xc6,0x43,0x08,0x1e,0xcd,
    0x7b,0x43,0x8a,0xa2,0xc9,0x43,0x30,0x89,0x7f,0x43,0x5c,0x94,0xcc,0x43,0x28,0xab,0x7d,0x43,0x42,0x2a,
    0xcf,0x43,0x09,0x01,0x05,0x06,0x24,0x14,0xe0,0x42,0xf5,0x77,0x97,0x43,0x08,0xf7,0x1d,0xe7,0x42,0x74,
    0x00,0x97,0x43,0x4d,0x93,0xec,0x42,0xdb,0xf5,0x95,0x43,0x29,0x4b,0xed,0x42,0xcd,0x34,0x95,0x43,0x09,
    0x06,0x29,0x7b,0xf5,0x42,0x6f,0x1d,0x98,0x43,0x08,0xe4,0xf1,0xfb,0x42,0x61,0x5c,0x97,0x43,0xdb,0x7d,
    0x01,0x43,0xb2,0xbe,0x95,0x43,0x55,0x23,0x02,0x43,0xe7,0xaa,0x94,0x43,0x09,0x06,0x98,0xdc,0x03,0x43,
    0xbe,0x8b,0x98,0x43,0x08,0x66,0xdf,0x05,0x43,0x47,0xe6,0x97,0x43,0xae,0x87,0x08,0x43,0x98,0x48,0x96,
    0x43,0x61,0x08,0x09,0x43,0xd6,0x06,0x95,0x43,0x09,0x06,0x31,0x0b,0x0b,0x43,0x8e,0x82,0x98,0x43,0x08,
    0xdb,0xc5,0x0d,0x43,0x80,0xc1,0x97,0x43,0xd6,0xee,0x10,0x43,0xa9,0xec,0x95,0x43,0x79,0xcb,0x11,0x43,
    0x55,0x8f,0x94,0x43,0x09,0x06,0xd1,0x2f,0x18,0x43,0xdb,0x01,0x98,0x43,0x08,0xad,0xe7,0x18,0x43,0x38,
    0x25,0x97,0x43,0x8a,0x9f,0x19,0x43,0x80,0xb5,0x95,0x43,0xd6,0x1e,0x19,0x43,0xe0,0xd8,0x94,0x43,0x09,
    0x06,0x9a,0x5b,0x1d,0x43,0x58,0x8a,0x97,0x43,0x08,0x01,0x5d,0x1e,0x43,0xf1,0x88,0x96,0x43,0x2f,0x83,
    0x1f,0x43,0x19,0xb4,0x94,0x43,0x19,0xf0,0x1e,0x43,0x6f,0x05,0x94,0x43,0x09,0x06,0x0b,0x53,0x24,0x43,
    0xae,0xdb,0x96,0x43,0x08,0x25,0xd5,0x25,0x43,0x50,0xac,0x95,0x43,0x53,0xfb,0x26,0x43,0x8a,0x7b,0x93,
    0x43,0x76,0x43,0x26,0x43,0xb7,0x95,0x92,0x43,0x09,0x06,0x76,0x5b,0x2a,0x43,0x47,0xda,0x95,0x43,0x08,
    0xf3,0xef,0x2b,0x43,0x10,0xe2,0x94,0x43,0x6d,0x95,0x2c,0x43,0xae,0xc3,0x92,0x43,0x68,0xa6,0x2b,0x43,
    0x47,0xc2,0x91,0x43,0x09,0x06,0x36,0xc1,0x31,0x43,0x2c,0x58,0x94,0x43,0x08,0x8c,0x1e,0x33,0x43,0x31,
    0x3b,0x93,0x43,0x79,0x7a,0x33,0x43,0xff,0x25,0x91,0x43,0xd9,0x9d,0x32,0x43,0xc1,0x5b,0x90,0x43,0x09,
    0x06,0x25,0x35,0x36,0x43,0x31,0x3b,0x93,0x43,0x08,0x3f,0xb7,0x37,0x43,0xc1,0x67,0x92,0x43,0xe0,0x93,
    0x38,0x43,0xae,0xb7,0x90,0x43,0x7e,0x81,0x38,0x43,0x0d,0xdb,0x8f,0x43,0x09,0x06,0xb5,0x85,0x3b,0x43,
    0xe4,0xaf,0x91,0x43,0x08,0xcf,0x07,0x3d,0x43,0x9d,0x13,0x91,0x43,0xbc,0x63,0x3d,0x43,0x47,0xb6,0x8f,
    0x43,0xe5,0x9a,0x3d,0x43,0x74,0xd0,0x8e,0x43,0x09,0x06,0xae,0xc6,0x42,0x43,0xa4,0xd9,0x8e,0x43,0x08,
    0xca,0x48,0x44,0x43,0xfa,0x2a,0x8e,0x43,0xa2,0x11,0x44,0x43,0x9d,0xfb,0x8c,0x43,0x55,0x92,0x44,0x43,
    0x0d,0xc3,0x8b,0x43,0x09,0x06,0x39,0x10,0xc3,0x43,0x34,0x36,0x96,0x43,0x08,0x92,0x44,0xc1,0x43,0xe4,
    0xc7,0x95,0x43,0x6f,0xf0,0xbf,0x43,0x4b,0xbd,0x94,0x43,0x47,0xb9,0xbf,0x43,0x0b,0xf3,0x93,0x43,0x09,
    0x06,0x8f,0x49,0xbe,0x43,0xb7,0xad,0x96,0x43,0x08,0x11,0xb5,0xbc,0x43,0x77,0xe3,0x95,0x43,0x9c,0xf2,
    0xba,0x43,0xfa,0x4e,0x94,0x43,0xae,0x96,0xba,0x43,0x31,0x3b,0x93,0x43,0x09,0x06,0xdb,0xb0,0xb9,0x43,
    0x10,0xee,0x96,0x43,0x08,0x42,0xa6,0xb8,0x43,0xc8,0x51,0x96,0x43,0x50,0x5b,0xb7,0x43,0x19,0xb4,0x94,
    0x43,0xf7,0x1a,0xb7,0x43,0x58,0x72,0x93,0x43,0x09,0x06,0xf2,0x2b,0xb6,0x43,0x10,0xee,0x96,0x43,0x08,
    0x9d,0xce,0xb4,0x43,0x04,0x2d,0x96,0x43,0xed,0x30,0xb3,0x43,0x2c,0x58,0x94,0x43,0xce,0xcb,0xb2,0x43,
    0xd6,0xfa,0x92,0x43,0x09,0x06,0x5a,0x09,0xb1,0x43,0x19,0xc0,0x96,0x43,0x08,0x6c,0xad,0xb0,0x43,0x77,
    0xe3,0x95,0x43,0x7e,0x51,0xb0,0x43,0xc0,0x73,0x94,0x43,0xd8,0x91,0xb0,0x43,0x1e,0x97,0x93,0x43,0x09,
    0x06,0x48,0x4d,0xad,0x43,0xbe,0x7f,0x96,0x43,0x08,0x95,0xcc,0xac,0x43,0x58,0x7e,0x95,0x43,0x4d,0x30,
    0xac,0x43,0x80,0xa9,0x93,0x43,0xd8,0x79,0xac,0x43,0xd6,0xfa,0x92,0x43,0x09,0x06,0x90,0xd1,0xa9,0x43,
    0x14,0xd1,0x95,0x43,0x08,0x83,0x10,0xa9,0x43,0xb7,0xa1,0x94,0x43,0x3b,0x74,0xa8,0x43,0xf1,0x70,0x92,
    0x43,0x29,0xd0,0xa8,0x43,0x1e,0x8b,0x91,0x43,0x09,0x06,0x5a,0xcd,0xa6,0x43,0x8a,0x87,0x95,0x43,0x08,
    0x1c,0x03,0xa6,0x43,0x23,0x86,0x94,0x43,0x5f,0xb0,0xa5,0x43,0xc1,0x67,0x92,0x43,0xe1,0x27,0xa6,0x43,
    0x8a,0x6f,0x91,0x43,0x09,0x06,0xd4,0x5a,0xa3,0x43,0x2c,0x58,0x94,0x43,0x08,0x29,0xac,0xa2,0x43,0x31,
    0x3b,0x93,0x43,0x32,0x7e,0xa2,0x43,0xff,0x25,0x91,0x43,0x83,0xec,0xa2,0x43,0x8e,0x52,0x90,0x43,0x09,
    0x06,0xf8,0x96,0xa0,0x43,0x1e,0x97,0x93,0x43,0x08,0xeb,0xd5,0x9f,0x43,0x7b,0xba,0x92,0x43,0x99,0x67,
    0x9f,0x43,0x9d,0x13,0x91,0x43,0x99,0x67,0x9f,0x43,0xfa,0x36,0x90,0x43,0x09,0x06,0xeb,0xc9,0x9d,0x43,
    0xc8,0x39,0x92,0x43,0x08,0xde,0x08,0x9d,0x43,0xb2,0xa6,0x91,0x43,0xe6,0xda,0x9c,0x43,0x2c,0x40,0x90,
    0x43,0x52,0xbf,0x9c,0x43,0x5a,0x5a,0x8f,0x43,0x09,0x06,0x37,0x3d,0x9b,0x43,0x85,0x80,0x90,0x43,0x08,
    0x2a,0x7c,0x9a,0x43,0xdb,0xd1,0x8f,0x43,0xf0,0xa0,0x9a,0x43,0x7d,0xa2,0x8e,0x43,0x65,0x57,0x9a,0x43,
    0xee,0x69,0x8d,0x43,0x09,0x02,0x04,0x06,0x2a,0xf4,0x2e,0x42,0x04,0x21,0x94,0x43,0x08,0x0d,0x8a,0x31,
    0x42,0x9f,0x0e,0x94,0x43,0xf3,0x1f,0x34,0x42,0x3d,0xfc,0x93,0x43,0x63,0xff,0x36,0x42,0xa9,0xe0,0x93,
    0x43,0x08,0xb5,0x34,0x5d,0x42,0x0b,0xf3,0x93,0x43,0x6d,0xa4,0x5e,0x42,0x03,0x39,0x98,0x43,0xe7,0x31,
    0x5b,0x42,0x93,0x89,0x9d,0x43,0x08,0x02,0x9c,0x58,0x42,0xd4,0x5a,0xa3,0x43,0x38,0x70,0x53,0x42,0x14,
    0x49,0xaa,0x43,0xf8,0xed,0x5e,0x42,0x83,0x28,0xad,0x43,0x08,0xea,0x68,0x68,0x42,0x20,0x22,0xaf,0x43,
    0x12,0xb8,0x6c,0x42,0xb5,0x49,0xb1,0x43,0x2a,0x4b,0x6d,0x42,0x0d,0x96,0xb3,0x43,0x07,0x2a,0x4b,0x6d,
    0x42,0xc6,0x05,0xb5,0x43,0x08,0x87,0x6e,0x6c,0x42,0x68,0xee,0xb7,0x43,0x1c,0x66,0x66,0x42,0x31,0x0e,
    0xbb,0x43,0x57,0x11,0x5e,0x42,0x8f,0x49,0xbe,0x43,0x08,0x66,0x96,0x54,0x42,0xb9,0x5c,0xb8,0x43,0x2c,
    0x2b,0x3c,0x42,0x68,0xd6,0xb3,0x43,0x2a,0xf4,0x2e,0x42,0x6d,0xad,0xb0,0x43,0x07,0x2a,0xf4,0x2e,0x42,
    0x61,0xa4,0xa3,0x43,0x08,0x55,0x1a,0x30,0x42,0xf0,0xd0,0xa2,0x43,0xf8,0xf6,0x30,0x42,0xb2,0x06,0xa2,
    0x43,0x98,0xd3,0x31,0x42,0xd6,0x4e,0xa1,0x43,0x08,0x1c,0x6f,0x38,0x42,0x2a,0x94,0x9e,0x43,0xc1,0x22,
    0x36,0x42,0xf5,0x9b,0x9d,0x43,0x2a,0xf4,0x2e,0x42,0x6a,0x52,0x9d,0x43,0x07,0x2a,0xf4,0x2e,0x42,0x57,
    0xa2,0x9b,0x43,0x08,0xab,0x8f,0x35,0x42,0x8a,0xab,0x9b,0x43,0xe9,0x71,0x3a,0x42,0xb2,0xe2,0x9b,0x43,
    0xb7,0x74,0x3c,0x42,0x34,0x5a,0x9c,0x43,0x08,0x23,0x7d,0x42,0x42,0x0b,0x2f,0x9e,0x43,0xe5,0x9a,0x3d,
    0x42,0x38,0x6d,0xa3,0x43,0x36,0xd9,0x35,0x42,0xf3,0xd7,0xa7,0x43,0x08,0x12,0x61,0x2e,0x42,0xb0,0x42,
    0xac,0x43,0x63,0xff,0x36,0x42,0xdd,0x74,0xaf,0x43,0x1e,0xa6,0x45,0x42,0x44,0x82,0xb2,0x43,0x08,0x74,
    0x1b,0x4b,0x42,0x79,0x7a,0xb3,0x43,0x10,0x21,0x4f,0x42,0x2a,0x18,0xb5,0x43,0xdb,0x4c,0x54,0x42,0x91,
    0x19,0xb6,0x43,0x08,0xee,0x3f,0x65,0x42,0x5f,0x28,0xba,0x43,0xa7,0xaf,0x66,0x42,0xb9,0x50,0xb6,0x43,
    0x14,0x58,0x5c,0x42,0xca,0xdc,0xb1,0x43,0x08,0x2c,0x8b,0x4c,0x42,0x4e,0x30,0xac,0x43,0x19,0xcf,0x48,
    0x42,0x2a,0xd0,0xa8,0x43,0xbc,0xab,0x49,0x42,0xa9,0x4c,0xa6,0x43,0x08,0x61,0x5f,0x47,0x42,0xfa,0xa2,
    0xa2,0x43,0xa7,0xaf,0x66,0x42,0x85,0x98,0x94,0x43,0x2a,0xf4,0x2e,0x42,0xc3,0x62,0x95,0x43,0x07,0x2a,
    0xf4,0x2e,0x42,0x04,0x21,0x94,0x43,0x09,0x06,0xd0,0xfe,0xea,0x41,0x9f,0x0e,0x94,0x43,0x08,0xdc,0xe3,
    0xf1,0x41,0xe9,0x9e,0x92,0x43,0xd2,0xe7,0x0b,0x42,0xd6,0x06,0x95,0x43,0x2a,0xf4,0x2e,0x42,0x04,0x21,
    0x94,0x43,0x07,0x2a,0xf4,0x2e,0x42,0xc3,0x62,0x95,0x43,0x08,0x87,0x17,0x2e,0x42,0xc3,0x62,0x95,0x43,
    0xe7,0x3a,0x2d,0x42,0xf5,0x6b,0x95,0x43,0x44,0x5e,0x2c,0x42,0xf5,0x6b,0x95,0x43,0x08,0xd1,0x47,0x1c,
    0x42,0x19,0xc0,0x96,0x43,0x66,0xdf,0x05,0x42,0x38,0x19,0x95,0x43,0x12,0x6a,0x00,0x42,0xb2,0xbe,0x95,
    0x43,0x08,0xbb,0x6b,0xea,0x41,0xd6,0x12,0x97,0x43,0x2d,0x82,0xfa,0x41,0x61,0x74,0x9b,0x43,0x7e,0x72,
    0x06,0x42,0x8a,0xab,0x9b,0x43,0x08,0xc8,0x39,0x12,0x42,0x4e,0xd0,0x9b,0x43,0x53,0xe3,0x22,0x42,0xc3,
    0x86,0x9b,0x43,0x2a,0xf4,0x2e,0x42,0x57,0xa2,0x9b,0x43,0x07,0x2a,0xf4,0x2e,0x42,0x6a,0x52,0x9d,0x43,
    0x08,0x01,0xa5,0x2a,0x42,0xa4,0x2d,0x9d,0x43,0x96,0x9c,0x24,0x42,0x06,0x40,0x9d,0x43,0x8a,0xb7,0x1d,
    0x42,0x9a,0x5b,0x9d,0x43,0x08,0x6b,0x16,0x13,0x42,0xcd,0x64,0x9d,0x43,0x42,0xc7,0x0e,0x42,0x9a,0x5b,
    0x9d,0x43,0x23,0x26,0x04,0x42,0xcd,0x64,0x9d,0x43,0x08,0xe6,0x91,0xeb,0x41,0x38,0x49,0x9d,0x43,0x73,
    0x7b,0xdb,0x41,0xf5,0x83,0x99,0x43,0x7f,0x60,0xe2,0x41,0x0b,0x0b,0x98,0x43,0x08,0x7f,0x60,0xe2,0x41,
    0xec,0x99,0x95,0x43,0xe3,0x5a,0xde,0x41,0xbe,0x7f,0x96,0x43,0xd0,0xfe,0xea,0x41,0x9f,0x0e,0x94,0x43,
    0x07,0xd0,0xfe,0xea,0x41,0x9f,0x0e,0x94,0x43,0x09,0x06,0x2a,0xf4,0x2e,0x42,0x6d,0xad,0xb0,0x43,0x08,
    0xd4,0x7e,0x29,0x42,0xab,0x6b,0xaf,0x43,0x4e,0x0c,0x26,0x42,0x44,0x6a,0xae,0x43,0x38,0x79,0x25,0x42,
    0xd4,0x96,0xad,0x43,0x08,0x25,0xbd,0x21,0x42,0xe2,0x4b,0xac,0x43,0x49,0x35,0x29,0x42,0x9a,0x97,0xa7,
    0x43,0x2a,0xf4,0x2e,0x42,0x61,0xa4,0xa3,0x43,0x07,0x2a,0xf4,0x2e,0x42,0x6d,0xad,0xb0,0x43,0x09,0x06,
    0x1d,0xe5,0x7f,0x43,0x87,0x4a,0xe6,0x43,0x08,0x86,0x20,0x80,0x43,0x57,0x41,0xe6,0x43,0x7d,0x4e,0x80,
    0x43,0x25,0x38,0xe6,0x43,0xa5,0x85,0x80,0x43,0xf3,0x2e,0xe6,0x43,0x08,0x35,0xca,0x83,0x43,0xd4,0xc9,
    0xe5,0x43,0x9c,0xd7,0x86,0x43,0x44,0x91,0xe4,0x43,0xd5,0xca,0x8a,0x43,0x91,0x1c,0xe6,0x43,0x08,0x53,
    0x5f,0x8c,0x43,0xf8,0x1d,0xe7,0x43,0x2f,0x17,0x8d,0x43,0x4e,0x7b,0xe8,0x43,0x92,0x29,0x8d,0x43,0x2f,
    0x22,0xea,0x43,0x07,0x92,0x29,0x8d,0x43,0x44,0xb5,0xea,0x43,0x08,0xfe,0x0d,0x8d,0x43,0x2a,0x4b,0xed,
    0x43,0xe3,0x8b,0x8b,0x43,0x55,0x7d,0xf0,0x43,0xec,0x51,0x89,0x43,0x72,0x0b,0xf4,0x43,0x08,0xcd,0xd4,
    0x84,0x43,0x9d,0x55,0xfb,0x43,0xc9,0xe5,0x83,0x43,0x74,0x1e,0xfb,0x43,0x73,0x94,0x84,0x43,0x5a,0x90,
    0xf7,0x43,0x08,0xe8,0x62,0x88,0x43,0xfd,0x30,0xee,0x43,0x39,0xc5,0x86,0x43,0xdd,0xbf,0xeb,0x43,0x35,
    0xbe,0x81,0x43,0x40,0xde,0xed,0x43,0x08,0x4f,0x34,0x81,0x43,0x36,0x0c,0xee,0x43,0x08,0x98,0x80,0x43,
    0xfd,0x30,0xee,0x43,0x1d,0xe5,0x7f,0x43,0x91,0x4c,0xee,0x43,0x07,0x1d,0xe5,0x7f,0x43,0x91,0x40,0xec,
    0x43,0x08,0x35,0xbe,0x81,0x43,0x06,0xf7,0xeb,0x43,0x15,0x65,0x83,0x43,0x49,0xa4,0xeb,0x43,0x1e,0x43,
    0x85,0x43,0xbe,0x5a,0xeb,0x43,0x08,0xae,0x93,0x8a,0x43,0xfd,0x18,0xea,0x43,0x42,0x97,0x86,0x43,0x5f,
    0x67,0xf4,0x43,0xa9,0x98,0x87,0x43,0xd4,0x1d,0xf4,0x43,0x08,0x5c,0x25,0x8a,0x43,0xcf,0x16,0xef,0x43,
    0x46,0xaa,0x8d,0x43,0x5a,0x3c,0xe9,0x43,0x19,0x6c,0x88,0x43,0x53,0x5e,0xe7,0x43,0x08,0xc4,0x02,0x85,
    0x43,0x96,0x0b,0xe7,0x43,0x85,0x2c,0x82,0x43,0x83,0x67,0xe7,0x43,0x1d,0xe5,0x7f,0x43,0x72,0xc3,0xe7,
    0x43,0x07,0x1d,0xe5,0x7f,0x43,0x87,0x4a,0xe6,0x43,0x09,0x06,0xfd,0x24,0x6c,0x43,0xd9,0x94,0xe0,0x43,
    0x08,0xfa,0x6c,0x78,0x43,0xd1,0xc2,0xe0,0x43,0x25,0x5c,0x6c,0x43,0x25,0x44,0xe8,0x43,0x1d,0xe5,0x7f,
    0x43,0x87,0x4a,0xe6,0x43,0x07,0x1d,0xe5,0x7f,0x43,0x72,0xc3,0xe7,0x43,0x08,0xa6,0x27,0x7b,0x43,0x91,
    0x28,0xe8,0x43,0xbc,0xa2,0x77,0x43,0xb0,0x8d,0xe8,0x43,0xc6,0x68,0x75,0x43,0x57,0x4d,0xe8,0x43,0x08,
    0xe0,0xd2,0x72,0x43,0xab,0x9e,0xe7,0x43,0x50,0x9a,0x71,0x43,0x2a,0x27,0xe7,0x43,0xea,0x98,0x70,0x43,
    0x57,0x35,0xe4,0x43,0x08,0x94,0x3b,0x6f,0x43,0x14,0x7c,0xe2,0x43,0xff,0x13,0x6d,0x43,0x06,0xbb,0xe1,
    0x43,0xcf,0xfe,0x6a,0x43,0x06,0xbb,0xe1,0x43,0x08,0x44,0x9d,0x66,0x43,0x77,0x8e,0xe2,0x43,0x3b,0xef,
    0x6c,0x43,0x91,0x10,0xe4,0x43,0xfd,0x24,0x6c,0x43,0xb0,0x81,0xe6,0x43,0x08,0x96,0x23,0x6b,0x43,0xee,
    0x57,0xe9,0x43,0xca,0x0f,0x6a,0x43,0x5f,0x37,0xec,0x43,0x55,0x71,0x6e,0x43,0x9f,0x01,0xed,0x43,0x08,
    0xdb,0xfb,0x75,0x43,0x3b,0xef,0xec,0x43,0x09,0x3a,0x7b,0x43,0xb0,0xa5,0xec,0x43,0x1d,0xe5,0x7f,0x43,
    0x91,0x40,0xec,0x43,0x07,0x1d,0xe5,0x7f,0x43,0x91,0x4c,0xee,0x43,0x08,0xa9,0x16,0x7c,0x43,0xb0,0xb1,
    0xee,0x43,0x47,0xec,0x77,0x43,0xd9,0xe8,0xee,0x43,0x1e,0x9d,0x73,0x43,0xcf,0x16,0xef,0x43,0x08,0x0e,
    0xc9,0x6b,0x43,0xee,0x7b,0xef,0x43,0x7e,0x90,0x6a,0x43,0xfd,0x30,0xee,0x43,0x01,0xfc,0x68,0x43,0x4e,
    0x93,0xec,0x43,0x08,0x31,0xf9,0x66,0x43,0x4e,0x87,0xea,0x43,0x31,0x11,0x6b,0x43,0xd4,0xd5,0xe7,0x43,
    0xd9,0xc4,0x68,0x43,0xd4,0xc9,0xe5,0x43,0x08,0xe5,0x79,0x67,0x43,0x77,0x9a,0xe4,0x43,0x44,0x9d,0x66,
    0x43,0xab,0x86,0xe3,0x43,0x7e,0x78,0x66,0x43,0x0b,0xaa,0xe2,0x43,0x07,0x7e,0x78,0x66,0x43,0x57,0x29,
    0xe2,0x43,0x08,0xa7,0xaf,0x66,0x43,0xbe,0x1e,0xe1,0x43,0x87,0x56,0x68,0x43,0x77,0x82,0xe0,0x43,0xfd,
    0x24,0x6c,0x43,0xd9,0x94,0xe0,0x43,0x09,0x06,0xc4,0x41,0xbf,0x43,0x85,0xc0,0x72,0x42,0x08,0x73,0xdf,
    0xc0,0x43,0xf4,0x76,0x72,0x42,0x97,0x33,0xc2,0x43,0x85,0xc0,0x72,0x42,0xb2,0xb5,0xc3,0x43,0x64,0x56,
    0x75,0x42,0x08,0x03,0x24,0xc4,0x43,0x5e,0x7f,0x78,0x42,0xfa,0x51,0xc4,0x43,0x01,0x85,0x7c,0x42,0x5c,
    0x64,0xc4,0x43,0xa0,0xb3,0x80,0x42,0x07,0x5c,0x64,0xc4,0x43,0x10,0x93,0x83,0x42,0x08,0xc8,0x48,0xc4,
    0x43,0x1c,0x78,0x8a,0x42,0x27,0x6c,0xc3,0x43,0xaf,0xcf,0x94,0x42,0x23,0x7d,0xc2,0x43,0x99,0x9c,0xa4,
    0x42,0x08,0x3d,0xe7,0xbf,0x43,0xfb,0xfd,0xb5,0x42,0xb3,0x9d,0xbf,0x43,0x88,0x17,0xae,0x42,0xc4,0x41,
    0xbf,0x43,0x69,0x76,0xa3,0x42,0x07,0xc4,0x41,0xbf,0x43,0xac,0xc8,0x8f,0x42,0x08,0x4f,0x8b,0xbf,0x43,
    0xed,0x81,0x91,0x42,0xe4,0xa6,0xbf,0x43,0x5d,0x61,0x94,0x42,0xfa,0x39,0xc0,0x43,0x3b,0x49,0x9d,0x42,
    0x08,0x2b,0x43,0xc0,0x43,0x28,0xed,0xa9,0x42,0x61,0x3b,0xc1,0x43,0x00,0x9e,0xa5,0x42,0xe4,0xb2,0xc1,
    0x43,0x5d,0x91,0x9c,0x42,0x08,0x78,0xce,0xc1,0x43,0xfd,0x36,0x90,0x42,0x22,0x89,0xc4,0x43,0x81,0x72,
    0x86,0x42,0xae,0xc6,0xc2,0x43,0xa0,0xb3,0x80,0x42,0x08,0x54,0x86,0xc2,0x43,0x58,0xd1,0x7e,0x42,0x30,
    0x32,0xc1,0x43,0xce,0x5e,0x7b,0x42,0xc4,0x41,0xbf,0x43,0xe8,0xf1,0x7b,0x42,0x07,0xc4,0x41,0xbf,0x43,
    0x85,0xc0,0x72,0x42,0x09,0x06,0xf6,0x32,0xbb,0x43,0x40,0xa7,0x60,0x42,0x08,0x35,0xfd,0xbb,0x43,0xa4,
    0xa1,0x5c,0x42,0x5e,0x34,0xbc,0x43,0x9d,0x2a,0x70,0x42,0x5e,0x40,0xbe,0x43,0x0e,0x0a,0x73,0x42,0x08,
    0x4c,0x9c,0xbe,0x43,0x0e,0x0a,0x73,0x42,0x08,0xef,0xbe,0x43,0x0e,0x0a,0x73,0x42,0xc4,0x41,0xbf,0x43,
    0x85,0xc0,0x72,0x42,0x07,0xc4,0x41,0xbf,0x43,0xe8,0xf1,0x7b,0x42,0x08,0xcd,0x13,0xbf,0x43,0xe8,0xf1,
    0x7b,0x42,0xd6,0xe5,0xbe,0x43,0x71,0x3b,0x7c,0x42,0xdf,0xb7,0xbe,0x43,0x71,0x3b,0x7c,0x42,0x08,0x08,
    0xe3,0xbc,0x43,0xa4,0x61,0x7d,0x42,0x28,0x3c,0xbb,0x43,0x91,0x45,0x69,0x42,0x28,0x3c,0xbb,0x43,0x58,
    0x71,0x6e,0x42,0x08,0xce,0xfb,0xba,0x43,0xd5,0x35,0x78,0x42,0x59,0x45,0xbb,0x43,0x58,0x23,0x82,0x42,
    0xa1,0xe1,0xbb,0x43,0xd7,0xbe,0x88,0x42,0x08,0xc9,0x18,0xbc,0x43,0xaf,0x9f,0x8c,0x42,0x1e,0x76,0xbd,
    0x43,0x51,0x7c,0x8d,0x42,0xd6,0xe5,0xbe,0x43,0xf4,0x58,0x8e,0x42,0x08,0x9c,0x0a,0xbf,0x43,0x45,0xc7,
    0x8e,0x42,0x30,0x26,0xbf,0x43,0x96,0x35,0x8f,0x42,0xc4,0x41,0xbf,0x43,0xac,0xc8,0x8f,0x42,0x07,0xc4,
    0x41,0xbf,0x43,0x69,0x76,0xa3,0x42,0x08,0x08,0xef,0xbe,0x43,0xb1,0xd6,0x99,0x42,0xe8,0x89,0xbe,0x43,
    0xde,0xc5,0x8d,0x42,0xc0,0x46,0xbc,0x43,0xc2,0x5b,0x90,0x42,0x08,0x9c,0xf2,0xba,0x43,0x86,0x80,0x90,
    0x42,0xf2,0x43,0xba,0x43,0xe8,0x73,0x87,0x42,0x8f,0x31,0xba,0x43,0xb6,0xf4,0x7d,0x42,0x07,0x8f,0x31,
    0xba,0x43,0x21,0xc6,0x76,0x42,0x08,0xc0,0x3a,0xba,0x43,0x5f,0x48,0x6b,0x42,0xae,0x96,0xba,0x43,0xe3,
    0x83,0x61,0x42,0xf6,0x32,0xbb,0x43,0x40,0xa7,0x60,0x42,0x09,0x06,0xea,0x74,0xea,0x43,0x61,0x44,0x93,
    0x43,0x08,0x24,0x5c,0xec,0x43,0x31,0x3b,0x93,0x43,0xfb,0x30,0xee,0x43,0x93,0x4d,0x93,0x43,0x0d,0xe1,
    0xef,0x43,0x80,0xa9,0x93,0x43,0x08,0x8f,0x58,0xf0,0x43,0xd1,0x17,0x94,0x43,0xb7,0x8f,0xf0,0x43,0x10,
    0xe2,0x94,0x43,0xea,0x98,0xf0,0x43,0xa9,0xec,0x95,0x43,0x07,0xea,0x98,0xf0,0x43,0x38,0x25,0x97,0x43,
    0x08,0x23,0x74,0xf0,0x43,0x9f,0x32,0x9a,0x43,0x5a,0x60,0xef,0x43,0x53,0xcb,0x9e,0x43,0x2d,0x3a,0xee,
    0x43,0xfd,0x91,0xa3,0x43,0x08,0xa2,0xf0,0xed,0x43,0xdd,0x38,0xa5,0x43,0x17,0xa7,0xed,0x43,0xbe,0xdf,
    0xa6,0x43,0x5a,0x54,0xed,0x43,0x9f,0x86,0xa8,0x43,0x08,0xfc,0x24,0xec,0x43,0xca,0xc4,0xad,0x43,0x48,
    0xa4,0xeb,0x43,0x40,0x6f,0xab,0x43,0x28,0x3f,0xeb,0x43,0x1c,0x0f,0xa8,0x43,0x08,0x1f,0x6d,0xeb,0x43,
    0x72,0x48,0xa3,0x43,0x67,0x09,0xec,0x43,0xd1,0x53,0x9e,0x43,0xea,0x74,0xea,0x43,0x1e,0xc7,0x9b,0x43,
    0x07,0xea,0x74,0xea,0x43,0x8a,0x9f,0x99,0x43,0x08,0x7e,0x90,0xea,0x43,0x8a,0x9f,0x99,0x43,0x12,0xac,
    0xea,0x43,0xbc,0xa8,0x99,0x43,0xa7,0xc7,0xea,0x43,0xbc,0xa8,0x99,0x43,0x08,0x51,0x76,0xeb,0x43,0x9f,
    0x32,0x9a,0x43,0x5e,0x37,0xec,0x43,0x49,0xed,0x9c,0x43,0xb0,0xa5,0xec,0x43,0x2a,0xa0,0xa0,0x43,0x08,
    0x09,0xe6,0xec,0x43,0xd1,0x77,0xa4,0x43,0x28,0x4b,0xed,0x43,0x61,0xa4,0xa3,0x43,0xab,0xc2,0xed,0x43,
    0x8e,0xb2,0xa0,0x43,0x08,0x70,0xe7,0xed,0x43,0xde,0x08,0x9d,0x43,0x87,0x86,0xf0,0x43,0x2f,0x53,0x97,
    0x43,0x87,0x7a,0xee,0x43,0xec,0x99,0x95,0x43,0x08,0xca,0x27,0xee,0x43,0xff,0x3d,0x95,0x43,0x74,0xca,
    0xec,0x43,0x55,0x8f,0x94,0x43,0xea,0x74,0xea,0x43,0xe7,0xaa,0x94,0x43,0x07,0xea,0x74,0xea,0x43,0x61,
    0x44,0x93,0x43,0x09,0x06,0x05,0xd3,0xe5,0x43,0x19,0x9c,0x90,0x43,0x08,0x09,0xc2,0xe6,0x43,0xd1,0xff,
    0x8f,0x43,0x4d,0x6f,0xe6,0x43,0x74,0xe8,0x92,0x43,0x3b,0xd7,0xe8,0x43,0xc3,0x56,0x93,0x43,0x08,0x1f,
    0x61,0xe9,0x43,0x93,0x4d,0x93,0x43,0x05,0xeb,0xe9,0x43,0x93,0x4d,0x93,0x43,0xea,0x74,0xea,0x43,0x61,
    0x44,0x93,0x43,0x07,0xea,0x74,0xea,0x43,0xe7,0xaa,0x94,0x43,0x08,0x24,0x50,0xea,0x43,0xe7,0xaa,0x94,
    0x43,0x2d,0x22,0xea,0x43,0xe7,0xaa,0x94,0x43,0x36,0xf4,0xe9,0x43,0xe7,0xaa,0x94,0x43,0x08,0xa2,0xcc,
    0xe7,0x43,0xe0,0xd8,0x94,0x43,0xd4,0xc9,0xe5,0x43,0x19,0xa8,0x92,0x43,0xd4,0xc9,0xe5,0x43,0x27,0x69,
    0x93,0x43,0x08,0x17,0x77,0xe5,0x43,0xe0,0xd8,0x94,0x43,0x67,0xe5,0xe5,0x43,0x47,0xda,0x95,0x43,0x43,
    0x9d,0xe6,0x43,0xe2,0xd3,0x97,0x43,0x08,0x9d,0xdd,0xe6,0x43,0xad,0xe7,0x98,0x43,0x09,0xce,0xe8,0x43,
    0xff,0x55,0x99,0x43,0xea,0x74,0xea,0x43,0x8a,0x9f,0x99,0x43,0x07,0xea,0x74,0xea,0x43,0x1e,0xc7,0x9b,
    0x43,0x08,0x71,0xcf,0xe9,0x43,0x53,0xb3,0x9a,0x43,0xa7,0xbb,0xe8,0x43,0xdb,0x0d,0x9a,0x43,0xc6,0x14,
    0xe7,0x43,0xdb,0x0d,0x9a,0x43,0x08,0x48,0x80,0xe5,0x43,0xdb,0x0d,0x9a,0x43,0x0a,0xb6,0xe4,0x43,0xc3,
    0x6e,0x97,0x43,0x76,0x9a,0xe4,0x43,0x74,0xf4,0x94,0x43,0x07,0x76,0x9a,0xe4,0x43,0x79,0xd7,0x93,0x43,
    0x08,0xd8,0xac,0xe4,0x43,0x66,0x27,0x92,0x43,0x29,0x1b,0xe5,0x43,0xe0,0xc0,0x90,0x43,0x05,0xd3,0xe5,
    0x43,0x19,0x9c,0x90,0x43,0x09,0x06,0x1b,0x66,0xe6,0x42,0xe3,0xa3,0x8f,0x42,0x08,0x71,0x0b,0xf4,0x42,
    0x00,0x0e,0x8d,0x42,0x8c,0x0f,0x01,0x43,0x3e,0xc0,0x89,0x42,0xf3,0x28,0x06,0x43,0x48,0x9e,0x8b,0x42,
    0x08,0x15,0x89,0x09,0x43,0x00,0x0e,0x8d,0x42,0xe0,0x9c,0x0a,0x43,0xc1,0x8b,0x98,0x42,0xa6,0xc1,0x0a,
    0x43,0x02,0xa5,0xaa,0x42,0x07,0xa6,0xc1,0x0a,0x43,0xf9,0xf6,0xb0,0x42,0x08,0xa6,0xc1,0x0a,0x43,0x47,
    0x8e,0xb4,0x42,0x42,0xaf,0x0a,0x43,0x1f,0x6f,0xb8,0x42,0xe0,0x9c,0x0a,0x43,0xba,0x74,0xbc,0x42,0x08,
    0xa1,0xd2,0x09,0x43,0x40,0x47,0xd0,0x42,0x0d,0xab,0x07,0x43,0x91,0xb5,0xd0,0x42,0x3b,0xb9,0x04,0x43,
    0xec,0x71,0xba,0x42,0x08,0xe5,0x5b,0x03,0x43,0xe3,0x33,0xa8,0x42,0x63,0xd8,0x00,0x43,0xce,0x70,0x9f,
    0x42,0x1b,0x66,0xe6,0x42,0xae,0x2f,0xa5,0x42,0x07,0x1b,0x66,0xe6,0x42,0xa2,0x4a,0x9e,0x42,0x08,0xed,
    0x6f,0xed,0x42,0x73,0x24,0x9d,0x42,0xd8,0x0c,0xf5,0x42,0x99,0x6c,0x9c,0x42,0x27,0xab,0xfd,0x42,0xea,
    0xda,0x9c,0x42,0x08,0x36,0xca,0x03,0x43,0x2b,0x94,0x9e,0x42,0x68,0xc7,0x01,0x43,0x8f,0xbe,0xa2,0x42,
    0xfa,0x06,0x08,0x43,0x73,0xb4,0xb5,0x42,0x08,0x8e,0x2e,0x0a,0x43,0x1f,0x6f,0xb8,0x42,0x9d,0xe3,0x08,
    0x43,0xd7,0x1e,0x99,0x42,0x28,0x15,0x05,0x43,0x32,0x3b,0x93,0x42,0x08,0x63,0xf0,0x04,0x43,0x70,0xed,
    0x8f,0x42,0x71,0x0b,0xf4,0x42,0x32,0x3b,0x93,0x42,0x1b,0x66,0xe6,0x42,0x73,0xf4,0x94,0x42,0x07,0x1b,
    0x66,0xe6,0x42,0xe3,0xa3,0x8f,0x42,0x09,0x06,0x5e,0x28,0xba,0x42,0x35,0xe2,0x87,0x42,0x08,0x8e,0x55,
    0xc0,0x42,0xb8,0x4d,0x86,0x42,0x60,0xbf,0xd7,0x42,0x3e,0xf0,0x91,0x42,0x63,0xf6,0xe4,0x42,0x70,0xed,
    0x8f,0x42,0x08,0x7a,0x89,0xe5,0x42,0xac,0xc8,0x8f,0x42,0xcc,0xf7,0xe5,0x42,0xac,0xc8,0x8f,0x42,0x1b,
    0x66,0xe6,0x42,0xe3,0xa3,0x8f,0x42,0x07,0x1b,0x66,0xe6,0x42,0x73,0xf4,0x94,0x42,0x08,0x63,0xf6,0xe4,
    0x42,0x3b,0x19,0x95,0x42,0xe6,0x61,0xe3,0x42,0x00,0x3e,0x95,0x42,0xf4,0x16,0xe2,0x42,0xc4,0x62,0x95,
    0x42,0x08,0x6e,0x74,0xd6,0x42,0x15,0xd1,0x95,0x42,0x97,0x63,0xca,0x42,0xaf,0xcf,0x94,0x42,0xfb,0x2d,
    0xbe,0x42,0x86,0x80,0x90,0x42,0x08,0x97,0x03,0xba,0x42,0xce,0x10,0x8f,0x42,0x5e,0x28,0xba,0x42,0x3e,
    0xf0,0x91,0x42,0xf2,0x4f,0xbc,0x42,0x45,0xf7,0x96,0x42,0x08,0x27,0x54,0xbf,0x42,0x73,0x24,0x9d,0x42,
    0xa5,0xe8,0xc0,0x42,0x86,0xe0,0xa0,0x42,0xe4,0xca,0xc5,0x42,0xed,0x11,0xaa,0x42,0x08,0x54,0xaa,0xc8,
    0x42,0x86,0x40,0xb1,0x42,0x59,0x81,0xc5,0x42,0xa1,0x11,0xc4,0x42,0x3e,0xe7,0xbf,0x42,0xfb,0x8d,0xce,
    0x42,0x08,0xb4,0x6d,0xb7,0x42,0x30,0xc2,0xd9,0x42,0x46,0xf5,0xc9,0x42,0xdf,0x53,0xd9,0x42,0x38,0x40,
    0xcb,0x42,0x62,0x8f,0xcf,0x42,0x08,0x7d,0xf9,0xcc,0x42,0xec,0xa1,0xc2,0x42,0x07,0x43,0xcd,0x42,0x6c,
    0xdd,0xb8,0x42,0x2b,0x8b,0xcc,0x42,0x92,0xf5,0xaf,0x42,0x08,0xf9,0x8d,0xce,0x42,0x41,0x57,0xa7,0x42,
    0x5b,0xb8,0xd2,0x42,0xae,0x2f,0xa5,0x42,0x18,0x2f,0xd9,0x42,0x13,0x2a,0xa1,0x42,0x08,0x41,0x7e,0xdd,
    0x42,0xe3,0x03,0xa0,0x42,0x2e,0xf2,0xe1,0x42,0x7c,0x02,0x9f,0x42,0x1b,0x66,0xe6,0x42,0xa2,0x4a,0x9e,
    0x42,0x07,0x1b,0x66,0xe6,0x42,0xae,0x2f,0xa5,0x42,0x08,0x4d,0x63,0xe4,0x42,0x00,0x9e,0xa5,0x42,0xf4,
    0x16,0xe2,0x42,0x15,0x31,0xa6,0x42,0x99,0xca,0xdf,0x42,0x2b,0xc4,0xa6,0x42,0x08,0xc0,0x82,0xc6,0x42,
    0xc4,0xc2,0xa5,0x42,0x57,0xe1,0xd5,0x42,0x91,0xb5,0xd0,0x42,0x54,0xda,0xd0,0x42,0x97,0x93,0xd2,0x42,
    0x08,0x9c,0x3a,0xc7,0x42,0x17,0x58,0xdc,0x42,0x9c,0x0a,0xbf,0x42,0x6e,0xa4,0xde,0x42,0x90,0x25,0xb8,
    0x42,0xdf,0x53,0xd9,0x42,0x08,0x59,0x21,0xb5,0x42,0xf2,0xdf,0xd4,0x42,0x51,0x43,0xb3,0x42,0x91,0xb5,
    0xd0,0x42,0xc5,0x29,0xbb,0x42,0x0e,0x1a,0xca,0x42,0x08,0x65,0x36,0xc4,0x42,0xd0,0x07,0xbd,0x42,0x3e,
    0xe7,0xbf,0x42,0x37,0x09,0xbe,0x42,0x0c,0xea,0xc1,0x42,0xcd,0xd0,0xaf,0x42,0x08,0x2b,0x5b,0xc4,0x42,
    0x18,0x08,0xa3,0x42,0x67,0xa6,0xab,0x42,0x99,0x3c,0x94,0x42,0x5e,0x28,0xba,0x42,0x35,0xe2,0x87,0x42,
    0x09,];
}


// ////////////////////////////////////////////////////////////////////////// //
final class SdpyDrawSdpyImage : SdpyDrawBase {
private:
  Image vbuf;

protected:
  // must be overriden
  override Color getpix (int x, int y) {
    static if (UsingSimpledisplayX11) {
      pragma(inline, true);
      const(uint)* dp = (cast(const(uint)*)vbuf.getDataPointer)+y*vbuf.width+x;
      return XlibImageTC.img2c(*dp);
    } else {
      return vbuf.getPixel(x, y);
    }
  }

  override void putpix (int x, int y, Color col) {
    static if (UsingSimpledisplayX11) {
      uint* dp = (cast(uint*)vbuf.getDataPointer)+y*vbuf.width+x;
      if (col.a == 255) *dp = XlibImageTC.c2img(col)|0xff_000000; else *dp = blendU32(*dp, XlibImageTC.c2img(col)|(col.a<<24));
    } else {
      vbuf.setPixel(x, y, col);
    }
  }

  // optionals
  override void hline (int x, int y, int len, Color col) {
    static if (UsingSimpledisplayX11) {
      uint* dp = (cast(uint*)vbuf.getDataPointer)+y*vbuf.width+x;
      uint uc = XlibImageTC.c2img(col);
      if (col.a == 255) {
        uc |= 0xff_000000;
        foreach (immutable _; 0..len) *dp++ = uc;
      } else {
        uc |= col.a<<24;
        foreach (immutable _; 0..len) { *dp = blendU32(*dp, uc); ++dp; }
      }
    } else {
      while (len-- > 0) vbuf.setPixel(x++, y, col);
    }
  }

public:
  this (Image img) {
    vbuf = img;
    super(img.width, img.height);
  }

  override TrueColorImage getBuffer () {
    auto img = new TrueColorImage(vbuf.width, vbuf.height);
    static if (UsingSimpledisplayX11) {
      const(uint)* sp = cast(const(uint)*)vbuf.getDataPointer;
      auto dp = img.imageData.colors.ptr;
      foreach (immutable y; 0..vbuf.height) {
        foreach (immutable x; 0..vbuf.width) {
          *dp++ = XlibImageTC.img2c(*sp++);
        }
      }
    } else {
      foreach (immutable y; 0..vbuf.height) {
        foreach (immutable x; 0..vbuf.width) {
          img.setPixel(x, y, vbuf.getPixel(x, y));
        }
      }
    }
    return img;
  }

  final @property Image imagebuf () pure nothrow @safe @nogc { pragma(inline, true); return vbuf; }
}


// ////////////////////////////////////////////////////////////////////////// //
// some "fastgfx" backend
/+
class SdpyAADrawBase(RendT) if (is(RT : Renderer!ST, ST)) {
protected:
  static T abs(T) (T n) pure nothrow @safe @nogc { pragma(inline, true); return (n < 0 ? -n : n); }

  version(Windows) {
    private static int lrintf (float f) nothrow @trusted @nogc { pragma(inline, true); return cast(int)(f+0.5f); }
    private static int lrintd (double f) nothrow @trusted @nogc { pragma(inline, true); return cast(int)(f+0.5); }
  } else {
    private import core.stdc.math : lrintf, lrintd = lrint;
  }
  private import core.stdc.math : sqrtf, sqrtd = sqrt;
  private import core.stdc.math : floorf, floord = floor;
  private import core.stdc.math : cosf, sinf;

public:
  GxSize dim;
  GxRect clip;
  RendT rend;

protected nothrow @trusted @nogc: // low-level methods; will always be called with valid coords
  // must be overriden
  // optionals
  final void hline (int x, int y, int len, Color c) {
    while (len-- > 0) rend.putPixel(x++, y, c);
  }

  final void vline (int x, int y, int len, Color c) {
    while (len-- > 0) rend.putPixel(x, y++, c);
  }

  final void fillrc (int x, int y, int w, int h, Color c) {
    while (h-- > 0) hline(x, y++, w, c);
  }

protected:
  Rasterizer rast;
  float tessTol = 0.25f;
  float angleTol = 0.0f; // 0.0f -- angle tolerance for McSeem Bezier rasterizer
  float cuspLimit = 0; // 0 -- cusp limit for McSeem Bezier rasterizer (0: real cusps)

public nothrow @trusted @nogc:
  this (int awdt, int ahgt) {
    if (awdt < 0) awdt = 0;
    if (ahgt < 0) ahgt = 0;
    dim = GxSize(awdt, ahgt);
    clip = GxRect(dim);
    rend.reset();
    rend.moveTo(0, 0);
  }

  final @property int width () const pure nothrow @safe @nogc { pragma(inline, true); return dim.width; }
  final @property int height () const pure nothrow @safe @nogc { pragma(inline, true); return dim.height; }

  void cls (Color clr=Color.white) { rend.clear(clr); beginPath(); }

  // can return null, yeah
  TrueColorImage getBuffer () { return null; }

final:
  Color getPixel (int x, int y) {
    pragma(inline, true);
    return (x >= 0 && y >= 0 && x < dim.width && y < dim.height && clip.inside(x, y) ? rend.getPixel(x, y) : Color.transparent);
  }

  void putPixel (int x, int y, Color c) {
    pragma(inline, true);
    if (x >= 0 && y >= 0 && x < dim.width && y < dim.height && clip.inside(x, y)) rend.putPixel(x, y, c);
  }

  // ////////////////////////////////////////////////////////////////////////// //
  // based on the ideas and code of Maxim Shemanarev. Rest in Peace, bro!
  // see http://www.antigrain.com/research/adaptive_bezier/index.html
  private void nvg__tesselateBezierMcSeem (in float x1, in float y1, in float x2, in float y2, in float x3, in float y3, in float x4, in float y4, in int level/*, in int type*/) {
    enum CollinearEPS = 0.00000001f; // 0.00001f;
    enum AngleTolEPS = 0.01f;

    static float distSquared (in float x1, in float y1, in float x2, in float y2) pure nothrow @safe @nogc {
      pragma(inline, true);
      immutable float dx = x2-x1;
      immutable float dy = y2-y1;
      return dx*dx+dy*dy;
    }

    if (level == 0) {
      rast.lineTo(x1, y1/*, 0*/);
      nvg__tesselateBezierMcSeem(ctx, x1, y1, x2, y2, x3, y3, x4, y4, 1/*, type*/);
      rast.lineTo(x4, y4/*, type*/);
      return;
    }

    if (level >= 32) return; // recurse limit; practically, it should be never reached, but...

    // calculate all the mid-points of the line segments
    immutable float x12 = (x1+x2)*0.5f;
    immutable float y12 = (y1+y2)*0.5f;
    immutable float x23 = (x2+x3)*0.5f;
    immutable float y23 = (y2+y3)*0.5f;
    immutable float x34 = (x3+x4)*0.5f;
    immutable float y34 = (y3+y4)*0.5f;
    immutable float x123 = (x12+x23)*0.5f;
    immutable float y123 = (y12+y23)*0.5f;
    immutable float x234 = (x23+x34)*0.5f;
    immutable float y234 = (y23+y34)*0.5f;
    immutable float x1234 = (x123+x234)*0.5f;
    immutable float y1234 = (y123+y234)*0.5f;

    // try to approximate the full cubic curve by a single straight line
    immutable float dx = x4-x1;
    immutable float dy = y4-y1;

    float d2 = nvg__absf(((x2-x4)*dy-(y2-y4)*dx));
    float d3 = nvg__absf(((x3-x4)*dy-(y3-y4)*dx));

    final switch ((cast(int)(d2 > CollinearEPS)<<1)+cast(int)(d3 > CollinearEPS)) {
      case 0:
        // all collinear or p1 == p4
        float k = dx*dx+dy*dy;
        if (k == 0) {
          d2 = distSquared(x1, y1, x2, y2);
          d3 = distSquared(x4, y4, x3, y3);
        } else {
          k = 1.0f/k;
          float da1 = x2-x1;
          float da2 = y2-y1;
          d2 = k*(da1*dx+da2*dy);
          da1 = x3-x1;
          da2 = y3-y1;
          d3 = k*(da1*dx+da2*dy);
          if (d2 > 0 && d2 < 1 && d3 > 0 && d3 < 1) {
            // Simple collinear case, 1---2---3---4
            // We can leave just two endpoints
            return;
          }
               if (d2 <= 0) d2 = distSquared(x2, y2, x1, y1);
          else if (d2 >= 1) d2 = distSquared(x2, y2, x4, y4);
          else d2 = distSquared(x2, y2, x1+d2*dx, y1+d2*dy);

               if (d3 <= 0) d3 = distSquared(x3, y3, x1, y1);
          else if (d3 >= 1) d3 = distSquared(x3, y3, x4, y4);
          else d3 = distSquared(x3, y3, x1+d3*dx, y1+d3*dy);
        }
        if (d2 > d3) {
          if (d2 < ctx.tessTol) {
            rast.lineTo(x2, y2/*, type*/);
            return;
          }
        } if (d3 < ctx.tessTol) {
          rast.lineTo(x3, y3/*, type*/);
          return;
        }
        break;
      case 1:
        // p1,p2,p4 are collinear, p3 is significant
        if (d3*d3 <= ctx.tessTol*(dx*dx+dy*dy)) {
          if (ctx.angleTol < AngleTolEPS) {
            rast.lineTo(x23, y23/*, type*/);
            return;
          } else {
            // angle condition
            float da1 = nvg__absf(nvg__atan2f(y4-y3, x4-x3)-nvg__atan2f(y3-y2, x3-x2));
            if (da1 >= NVG_PI) da1 = 2*NVG_PI-da1;
            if (da1 < ctx.angleTol) {
              rast.lineTo(x2, y2/*, type*/);
              rast.lineTo(x3, y3/*, type*/);
              return;
            }
            if (ctx.cuspLimit != 0.0) {
              if (da1 > ctx.cuspLimit) {
                rast.lineTo(x3, y3/*, type*/);
                return;
              }
            }
          }
        }
        break;
      case 2:
        // p1,p3,p4 are collinear, p2 is significant
        if (d2*d2 <= ctx.tessTol*(dx*dx+dy*dy)) {
          if (ctx.angleTol < AngleTolEPS) {
            rast.lineTo(x23, y23/*, type*/);
            return;
          } else {
            // angle condition
            float da1 = nvg__absf(nvg__atan2f(y3-y2, x3-x2)-nvg__atan2f(y2-y1, x2-x1));
            if (da1 >= NVG_PI) da1 = 2*NVG_PI-da1;
            if (da1 < ctx.angleTol) {
              rast.lineTo(x2, y2/*, type*/);
              rast.lineTo(x3, y3/*, type*/);
              return;
            }
            if (ctx.cuspLimit != 0.0) {
              if (da1 > ctx.cuspLimit) {
                rast.lineTo(x2, y2/*, type*/);
                return;
              }
            }
          }
        }
        break;
      case 3:
        // regular case
        if ((d2+d3)*(d2+d3) <= ctx.tessTol*(dx*dx+dy*dy)) {
          // if the curvature doesn't exceed the distance tolerance value, we tend to finish subdivisions
          if (ctx.angleTol < AngleTolEPS) {
            rast.lineTo(x23, y23/*, type*/);
            return;
          } else {
            // angle and cusp condition
            immutable float k = nvg__atan2f(y3-y2, x3-x2);
            float da1 = nvg__absf(k-nvg__atan2f(y2-y1, x2-x1));
            float da2 = nvg__absf(nvg__atan2f(y4-y3, x4-x3)-k);
            if (da1 >= NVG_PI) da1 = 2*NVG_PI-da1;
            if (da2 >= NVG_PI) da2 = 2*NVG_PI-da2;
            if (da1+da2 < ctx.angleTol) {
              // finally we can stop the recursion
              rast.lineTo(x23, y23/*, type*/);
              return;
            }
            if (ctx.cuspLimit != 0.0) {
              if (da1 > ctx.cuspLimit) {
                rast.lineTo(x2, y2/*, type*/);
                return;
              }
              if (da2 > ctx.cuspLimit) {
                rast.lineTo(x3, y3/*, type*/);
                return;
              }
            }
          }
        }
        break;
    }

    // continue subdivision
    nvg__tesselateBezierMcSeem(x1, y1, x12, y12, x123, y123, x1234, y1234, level+1/*, 0*/);
    nvg__tesselateBezierMcSeem(x1234, y1234, x234, y234, x34, y34, x4, y4, level+1/*, type*/);
  }

  @property float curX () const pure { pragma(inline, true); return rast.curX; }
  @property float curY () const pure { pragma(inline, true); return rast.curY; }

  void beginPath () { pragma(inline, true); rast.reset(); rast.moveTo(0, 0); }

  void moveTo (in float x, in float y) { pragma(inline, true); rast.moveTo(x, y); }
  void lineTo (in float x, in float y) { pragma(inline, true); rast.lineTo(x, y); }

  void bezierTo (in float x2, in float y2, in float x3, in float y3, in float x4, in float y4) {
    pragma(inline, true);
    nvg__tesselateBezierMcSeem(curX, curY, x2, y2, x3, y3, x4, y4);
  }

  void quadTo (in float cx, in float cy, in float x, in float y) {
    immutable float x0 = curX;
    immutable float y0 = curY;
    bezierTo(
      x0+2.0f/3.0f*(cx-x0), y0+2.0f/3.0f*(cy-y0),
      x+2.0f/3.0f*(cx-x), y+2.0f/3.0f*(cy-y),
      x, y,
    );
  }

  void fill (in Color c) {
    pragma(inline, true);
    rast.render(rend, c);
  }

  // ////////////////////////////////////////////////////////////////////////// //
  enum BaphometDims = 512; // [0..511]
  final void renderBaphomet (in Color fc, float ofsx=0, float ofsy=0, float scalex=1, float scaley=1) {
    auto path = cast(const(ubyte)[])baphometPath;
    immutable plen = path.length;
    uint ppos = 0;

    void drawLine (float x1, float y1, float x2, float y2, float width=0.2) {
      import std.math : sqrt;
      float dx = x2-x1;
      float dy = y2-y1;
      immutable float d = sqrtf(dx*dx+dy*dy);

      dx = width*(y2-y1)/d;
      dy = width*(x2-x1)/d;

      rast.moveTo(x1-dx, y1+dy);
      rast.lineTo(x2-dx, y2+dy);
      rast.lineTo(x2+dx, y2-dy);
      rast.lineTo(x1+dx, y1-dy);
    }

    enum Command {
      Bounds, // always first, has 4 args (x0, y0, x1, y1)
      StrokeMode,
      FillMode,
      StrokeFillMode,
      NormalStroke,
      ThinStroke,
      MoveTo,
      LineTo,
      CubicTo, // cubic bezier
      EndPath,
    }

    Command getCommand () nothrow @trusted @nogc {
      if (ppos >= plen) assert(0, "invalid path");
      return cast(Command)(path.ptr[ppos++]);
    }

    float getFloat () nothrow @trusted @nogc {
      if (ppos >= plen || plen-ppos < float.sizeof) assert(0, "invalid path");
      version(LittleEndian) {
        float res = *cast(const(float)*)(&path.ptr[ppos]);
        ppos += cast(uint)float.sizeof;
        return res;
      } else {
        static assert(float.sizeof == 4);
        uint xp = path.ptr[ppos]|(path.ptr[ppos+1]<<8)|(path.ptr[ppos+2]<<16)|(path.ptr[ppos+3]<<24);
        ppos += cast(uint)float.sizeof;
        return *cast(const(float)*)(&xp);
      }
    }

    int scaleX (float v) nothrow @trusted @nogc { pragma(inline, true); return lrintf(ofsx+v*scalex); }
    int scaleY (float v) nothrow @trusted @nogc { pragma(inline, true); return lrintf(ofsy+v*scaley); }

    int cx = 0, cy = 0;
    bool doStroke = false, doFill = false;
    while (ppos < plen) {
      auto cmd = getCommand();
      final switch (cmd) {
        case Command.Bounds: ppos += 4*cast(uint)float.sizeof; break;
        case Command.StrokeMode: doStroke = true; doFill = false; break;
        case Command.FillMode: doStroke = false; doFill = true;
        case Command.StrokeFillMode: break;
        case Command.NormalStroke: case Command.ThinStroke: break;
        case Command.MoveTo:
          cx = scaleX(getFloat());
          cy = scaleY(getFloat());
          rast.moveTo(cx, cy);
          break;
        case Command.LineTo:
          immutable int ex = scaleX(getFloat());
          immutable int ey = scaleY(getFloat());
          if (doFill) rast.lineTo(ex, ey); else if (doStroke) drawLine(cx, cy, ex, ey, fc);
          cx = ex;
          cy = ey;
          break;
        case Command.CubicTo: // cubic bezier
          immutable int x1 = scaleX(getFloat());
          immutable int y1 = scaleY(getFloat());
          immutable int x2 = scaleX(getFloat());
          immutable int y2 = scaleY(getFloat());
          immutable int ex = scaleX(getFloat());
          immutable int ey = scaleY(getFloat());
          if (doFill) drawCubicBezier(cx, cy, x1, y1, x2, y2, ex, ey, fc);
          cx = ex;
          cy = ey;
          break;
        case Command.EndPath: // don't close this path
          break;
      }
    }
  }
}


// ////////////////////////////////////////////////////////////////////////// //
private:
/* *****************************************************************************
  Anti-Grain Geometry - Version 2.1 Lite
  Copyright (C) 2002-2003 Maxim Shemanarev (McSeem)

  Permission to copy, use, modify, sell and distribute this software
  is granted provided this copyright notice appears in all copies.
  This software is provided "as is" without express or implied
  warranty, and with no claim as to its suitability for any purpose.

  The author gratefully acknowleges the support of David Turner,
  Robert Wilhelm, and Werner Lemberg - the authors of the FreeType
  libray - in producing this work. See http://www.freetype.org for details.

  Initially the rendering algorithm was designed by David Turner and the
  other authors of the FreeType library - see the above notice. I nearly
  created a similar renderer, but still I was far from David's work.
  I completely redesigned the original code and adapted it for Anti-Grain
  ideas. Two functions - renderLine and renderScanLine are the core of
  the algorithm - they calculate the exact coverage of each pixel cell
  of the polygon. I left these functions almost as is, because there's
  no way to improve the perfection - hats off to David and his group!

  All other code is very different from the original.
***************************************************************************** */
struct RenderingBuffer {
private:
  ubyte* mBuf; // Pointer to renrdering buffer
  ubyte** mRows; // Pointers to each row of the buffer
  uint mWidth; // Width in pixels
  uint mHeight; // Height in pixels
  int mStride; // Number of bytes per row. Can be < 0
  uint mMaxHeight; // Maximal current height

public nothrow @trusted @nogc:
  @disable this (this); // no copies

  this (ubyte* buf, uint width, uint height, int stride) {
    attach(buf, width, height, stride);
  }

  ~this () {
    import core.stdc.stdlib : free;
    free(mRows);
  }

  void attach (ubyte* buf, uint width, uint height, int stride) {
    import core.stdc.stdlib : realloc;
    if (width < 1 || height < 1 || width > short.max || height > short.max) assert(0, "invalid rendering buffer dimensions");
    mBuf = buf;
    mWidth = width;
    mHeight = height;
    mStride = stride;
    if (height > mMaxHeight || mRows is null) {
      mRows = cast(ubyte**)realloc(mRows, (ubyte*).sizeof*height);
      if (mRows is null) assert(0, "out of memory");
    }

    ubyte* rowPtr = mBuf;
    if (stride < 0) rowPtr = mBuf-cast(int)(height-1)*stride;

    ubyte** rows = mRows;
    while (height--) {
      *rows++ = rowPtr;
      rowPtr += stride;
    }
  }

  @property inout(ubyte)* buf () inout pure { pragma(inline, true); return mBuf; }
  uint width () const pure { pragma(inline, true); return mWidth; }
  uint height () const pure { pragma(inline, true); return mHeight; }
  int stride () const pure { pragma(inline, true); return mStride; }

  bool inbox (int x, int y) const pure { pragma(inline, true); return (x >= 0 && y >= 0 && x < cast(int)mWidth && y < cast(int)mHeight); }

  uint absStride() const pure { pragma(inline, true); return (mStride < 0 ? cast(uint)(-mStride) : cast(uint)mStride); }

  inout(ubyte)* row (uint y) inout pure { pragma(inline, true); return (y < mHeight ? mRows[y] : null); }

  inout(ubyte)[] opSlice () inout pure { pragma(inline, true); return mBuf[0..mHeight*absStride]; }
}


struct ScanLine {
private:
  int mMinX;
  uint mMaxLen;
  int mDX;
  int mDY;
  int mLastX = 0x7fff;
  int mLastY = 0x7fff;
  ubyte* mCovers;
  ubyte** mStartPtrs;
  ushort* mCounts;
  uint mNumSpans;
  ubyte** mCurStartPtr;
  ushort* mCurCount;

public:
  enum { AAShift = 8 }

  static struct Iterator {
  private:
    const(ubyte)* mCovers;
    const(ushort)* mCurCount;
    const(ubyte*)* mCurStartPtr;

  public nothrow @trusted @nogc:
    @disable this (this); // no copies

    this (in ref ScanLine sl) {
      mCovers = sl.mCovers;
      mCurCount = sl.mCounts;
      mCurStartPtr = sl.mStartPtrs;
    }

    int next () {
      ++mCurCount;
      ++mCurStartPtr;
      return cast(int)(*mCurStartPtr-mCovers);
    }

    @property int numPix () const pure { pragma(inline, true); return cast(int)(*mCurCount); }
    @property const(ubyte)* covers () const pure { pragma(inline, true); return *mCurStartPtr; }
  }

public nothrow @trusted @nogc:
  @disable this (this); // no copies

  ~this () {
    import core.stdc.stdlib : free;
    free(mCounts);
    free(mStartPtrs);
    free(mCovers);
  }

  auto iterator () const { pragma(inline, true); return Iterator(this); }

  void reset (int minX, int maxX, int dx=0, int dy=0) {
    uint maxLen = maxX-minX+2;
    if (maxLen > mMaxLen) {
      import core.stdc.stdlib : realloc;
      mCovers = cast(ubyte*)realloc(mCovers, maxLen);
      if (mCovers is null) assert(0, "out of memory");
      mStartPtrs = cast(ubyte**)realloc(mStartPtrs, (ubyte*).sizeof*maxLen);
      if (mStartPtrs is null) assert(0, "out of memory");
      mCounts = cast(ushort*)realloc(mCounts, ushort.sizeof*maxLen);
      if (mCounts is null) assert(0, "out of memory");
      mMaxLen = maxLen;
    }
    mDX = dx;
    mDY = dy;
    mLastX = 0x7fff;
    mLastY = 0x7fff;
    mMinX = minX;
    mCurCount = mCounts;
    mCurStartPtr = mStartPtrs;
    mNumSpans = 0;
  }

  void resetSpans () {
    pragma(inline, true);
    mLastX = 0x7fff;
    mLastY = 0x7fff;
    mCurCount = mCounts;
    mCurStartPtr = mStartPtrs;
    mNumSpans = 0;
  }

  void addSpan (int x, int y, uint num, uint cover) {
    import core.stdc.string : memset;
    x -= mMinX;
    memset(mCovers+x, cover, num);
    if (x == mLastX+1) {
      (*mCurCount) += cast(ushort)num;
    } else {
      *++mCurCount = cast(ushort)num;
      *++mCurStartPtr = mCovers+x;
      ++mNumSpans;
    }
    mLastX = x+num-1;
    mLastY = y;
  }

  void addCell (int x, int y, uint cover) {
    x -= mMinX;
    mCovers[x] = cast(ubyte)cover;
    if (x == mLastX+1) {
      ++(*mCurCount);
    } else {
      *++mCurCount = 1;
      *++mCurStartPtr = mCovers+x;
      ++mNumSpans;
    }
    mLastX = x;
    mLastY = y;
  }

  @property bool isReady (int y) const pure { pragma(inline, true); return (mNumSpans && (y^mLastY)); }
  @property int baseX () const pure { pragma(inline, true); return mMinX+mDX; }
  @property int y () const pure { pragma(inline, true); return mLastY+mDY; }
  @property uint numSpans () const pure { pragma(inline, true); return mNumSpans; }
}


public template isGoodSpan(T) {
  static if (is(T == struct)) {
    enum isGoodSpan = is(typeof((){
      T span;
      span.render(cast(ubyte*)0x29a, cast(int)0x29a, cast(uint)0x29a, cast(const(ubyte)*)0x29a, Color.red);
      span.hline(cast(ubyte*)0x29a, cast(int)0x29a, cast(uint)0x29a, Color.red);
      Color c = span.get(cast(const(ubyte)*)0x29a, cast(int)0x29a);
      // we should be able to copy it
      T spanNew = span;
    }));
  } else {
    enum isGoodSpan = false;
  }
}

public struct Renderer(Span) if (isGoodSpan!Span) {
private:
  RenderingBuffer mRBuf;
  Span mSpan;

public nothrow @trusted @nogc:
  this (ubyte* abuf, uint awidth, uint aheight, int astride) { mRBuf.attach(abuf, awidth, aheight, astride); }

  void attach (ubyte* abuf, uint awidth, uint aheight, int astride) { mRBuf.attach(abuf, awidth, aheight, astride); }

  void clear (in Color c) {
    foreach (immutable uint y; 0..mRBuf.height) {
      mSpan.hline(mRBuf.row(y), 0, mRBuf.width, c);
    }
  }

  void setPixel (int x, int y, in Color c) {
    if (mRBuf.inbox(x, y)) {
      mSpan.hline(mRBuf.row(y), x, 1, c);
    }
  }

  Color getPixel (int x, int y) const pure { pragma(inline, true); return (mRBuf.inbox(x, y) ? mSpan.get(mRBuf.row(y), x) : Color.transparent); }

  @property int width () const pure { pragma(inline, true); return mRBuf.width; }
  @property int height () const pure { pragma(inline, true); return mRBuf.height; }

  void render (in ref ScanLine sl, in Color c) {
    if (sl.y < 0 || sl.y >= cast(int)mRBuf.height) return;
    uint numSpans = sl.numSpans;
    int baseX = sl.baseX;
    ubyte* row = mRBuf.row(sl.y);
    auto span = sl.iterator;
    do {
      int x = span.next+baseX;
      const(ubyte)* covers = span.covers;
      int numPix = span.numPix;
      if (x < 0) {
        numPix += x;
        if (numPix <= 0) continue;
        covers -= x;
        x = 0;
      }
      if (x+numPix >= cast(int)mRBuf.width) {
        numPix = mRBuf.width-x;
        if (numPix <= 0) continue;
      }
      mSpan.render(row, x, numPix, covers, c);
    } while (--numSpans);
  }

  inout(ubyte)[] opSlice () inout pure { pragma(inline, true); return mRBuf[]; }
}


/* *****************************************************************************
  These constants determine the subpixel accuracy, to be more precise,
  the number of bits of the fractional part of the coordinates.
  The possible coordinate capacity in bits can be calculated by formula:
  sizeof(int) * 8 - PolyBaseShift * 2, i.e, for 32-bit integers and
  8-bits fractional part the capacity is 16 bits or [-32768...32767].
***************************************************************************** */
enum : uint {
  PolyBaseShift = 8U,
  PolyBaseSize = cast(uint)(1<<PolyBaseShift),
  PolyBaseMask = cast(uint)(PolyBaseSize-1),
}


int polyCoord (in double c) pure nothrow @safe @nogc { pragma(inline, true); return cast(int)(c*PolyBaseSize); }


// A pixel cell
struct Cell {
public:
  short x, y;
  int packedCoord;
  int cover;
  int area;

public nothrow @trusted @nogc:
  this (int cx, int cy, int c, int a) {
    pragma(inline, true);
    x = cast(short)cx;
    y = cast(short)cy;
    packedCoord = (cy<<16)+cx;
    cover = c;
    area = a;
  }

  void setCover (int c, int a) {
    pragma(inline, true);
    cover = c;
    area = a;
  }

  void addCover (int c, int a) {
    pragma(inline, true);
    cover += c;
    area += a;
  }

  void setCoord (int cx, int cy) {
    pragma(inline, true);
    x = cast(short)cx;
    y = cast(short)cy;
    packedCoord = (cy<<16)+cx;
  }

  void set (int cx, int cy, int c, int a) {
    pragma(inline, true);
    x = cast(short)cx;
    y = cast(short)cy;
    packedCoord = (cy<<16)+cx;
    cover = c;
    area = a;
  }
}


// An internal class that implements the main rasterization algorithm. Used in the rasterizer. Should not be used direcly.
struct Outline {
private:
  enum : uint {
    CellBlockShift = 12U,
    CellBlockSize = cast(uint)(1<<CellBlockShift),
    CellBlockMask = cast(uint)(CellBlockSize-1),
    CellBlockPool = 256U,
    CellBlockLimit = 1024U,
  }

  enum QSortThreshold = 9;

  enum : uint {
    NotClosed = 1U,
    SortRequired = 2U,
  }

private:
  uint mNumBlocks;
  uint mMaxBlocks;
  uint mCurBlock;
  uint mNumCells;
  Cell** mCells;
  Cell* mCurCellPtr;
  Cell** mSortedCells;
  uint mSortedSize;
  Cell mCurCell = Cell(0x7fff, 0x7fff, 0, 0);
  int mCurX;
  int mCurY;
  int mCloseX;
  int mCloseY;
  int mMinX = 0x7fffffff;
  int mMinY = 0x7fffffff;
  int mMaxX = -0x7fffffff;
  int mMaxY = -0x7fffffff;
  uint mFlags = SortRequired;

public nothrow @trusted @nogc:
  @disable this (this); // no copies

  ~this () {
    import core.stdc.stdlib : free;
    free(mSortedCells);
    if (mNumBlocks) {
      Cell** ptr = mCells+mNumBlocks-1;
      while (mNumBlocks--) {
        free(*ptr);
        --ptr;
      }
      free(mCells);
    }
  }

  void reset () {
    mNumCells = 0;
    mCurBlock = 0;
    mCurCell.set(0x7fff, 0x7fff, 0, 0);
    mFlags |= SortRequired;
    mFlags &= ~NotClosed;
    mMinX = 0x7fffffff;
    mMinY = 0x7fffffff;
    mMaxX = -0x7fffffff;
    mMaxY = -0x7fffffff;
  }

  void moveTo (int x, int y) {
    if ((mFlags&SortRequired) == 0) reset();
    if (mFlags&NotClosed) lineTo(mCloseX, mCloseY);
    setCurCell(x>>PolyBaseShift, y>>PolyBaseShift);
    mCloseX = mCurX = x;
    mCloseY = mCurY = y;
  }

  void lineTo (int x, int y) {
    if ((mFlags&SortRequired) && ((mCurX^x)|(mCurY^y))) {
      int c = mCurX>>PolyBaseShift;
      if (c < mMinX) mMinX = c;
      ++c;
      if (c > mMaxX) mMaxX = c;

      c = x>>PolyBaseShift;
      if (c < mMinX) mMinX = c;
      ++c;
      if (c > mMaxX) mMaxX = c;

      renderLine(mCurX, mCurY, x, y);
      mCurX = x;
      mCurY = y;
      mFlags |= NotClosed;
    }
  }

  @property double curX () const pure { pragma(inline, true); return cast(double)mCurX/cast(double)PolyBaseSize; }
  @property double curY () const pure { pragma(inline, true); return cast(double)mCurY/cast(double)PolyBaseSize; }

  @property int minX () const pure { pragma(inline, true); return mMinX; }
  @property int minY () const pure { pragma(inline, true); return mMinY; }
  @property int maxX () const pure { pragma(inline, true); return mMaxX; }
  @property int maxY () const pure { pragma(inline, true); return mMaxY; }

  @property uint numCells () const pure { pragma(inline, true); return mNumCells; }

  const(Cell)** cells () {
    if (mFlags&NotClosed) {
      lineTo(mCloseX, mCloseY);
      mFlags &= ~NotClosed;
    }
    // perform sort only the first time
    if (mFlags&SortRequired) {
      addCurCell();
      if (mNumCells == 0) return null;
      sortCells();
      mFlags &= ~SortRequired;
    }
    return cast(const(Cell)**)mSortedCells;
  }

private:
  void allocateBlock () {
    import core.stdc.stdlib : realloc;
    if (mCurBlock >= mNumBlocks) {
      import core.stdc.string : memset;
      if (mNumBlocks >= mMaxBlocks) {
        Cell** newCells = cast(Cell**)realloc(mCells, (mMaxBlocks+CellBlockPool)*(Cell*).sizeof);
        if (newCells is null) assert(0, "out of memory");
        mCells = newCells;
        mMaxBlocks += CellBlockPool;
      }
      auto cc = cast(Cell*)realloc(null, Cell.sizeof*CellBlockSize);
      if (cc is null) assert(0, "out of memory");
      memset(cc, 0, Cell.sizeof*CellBlockSize);
      foreach (ref c; cc[0..CellBlockSize]) c = Cell.init;
      mCells[mNumBlocks++] = cc;
    }
    mCurCellPtr = mCells[mCurBlock++];
  }

  void addCurCell () {
    if (mCurCell.area|mCurCell.cover) {
      if ((mNumCells&CellBlockMask) == 0) {
        if (mNumBlocks >= CellBlockLimit) return;
        allocateBlock();
      }
      *mCurCellPtr++ = mCurCell;
      ++mNumCells;
    }
  }

  void setCurCell (int x, int y) {
    if (mCurCell.packedCoord != (y<<16)+x) {
      addCurCell();
      mCurCell.set(x, y, 0, 0);
    }
  }

  void renderScanLine (int ey, int x1, int y1, int x2, int y2) {
    int ex1 = x1>>PolyBaseShift;
    int ex2 = x2>>PolyBaseShift;
    int fx1 = x1&PolyBaseMask;
    int fx2 = x2&PolyBaseMask;

    int delta, p, first, dx;
    int incr, lift, mod, rem;

    // trivial case; happens often
    if (y1 == y2) {
      setCurCell(ex2, ey);
      return;
    }

    // everything is located in a single cell: that is easy!
    if (ex1 == ex2) {
      delta = y2-y1;
      mCurCell.addCover(delta, (fx1+fx2)*delta);
      return;
    }

    // ok, we'll have to render a run of adjacent cells on the same scanline...
    p = (PolyBaseSize-fx1)*(y2-y1);
    first = PolyBaseSize;
    incr = 1;

    dx = x2-x1;

    if (dx < 0) {
      p = fx1*(y2-y1);
      first = 0;
      incr = -1;
      dx = -dx;
    }

    delta = p/dx;
    mod = p%dx;

    if (mod < 0) {
      --delta;
      mod += dx;
    }

    mCurCell.addCover(delta, (fx1+first)*delta);

    ex1 += incr;
    setCurCell(ex1, ey);
    y1 += delta;

    if (ex1 != ex2) {
      p = PolyBaseSize*(y2-y1+delta);
      lift = p/dx;
      rem = p%dx;

      if (rem < 0) {
        --lift;
        rem += dx;
      }

      mod -= dx;

      while (ex1 != ex2) {
        delta = lift;
        mod += rem;
        if (mod >= 0) {
          mod -= dx;
          ++delta;
        }
        mCurCell.addCover(delta, PolyBaseSize*delta);
        y1 += delta;
        ex1 += incr;
        setCurCell(ex1, ey);
      }
    }

    delta = y2-y1;
    mCurCell.addCover(delta, (fx2+PolyBaseSize-first)*delta);
  }

  void renderLine (int x1, int y1, int x2, int y2) {
    int ey1 = y1>>PolyBaseShift;
    int ey2 = y2>>PolyBaseShift;
    int fy1 = y1&PolyBaseMask;
    int fy2 = y2&PolyBaseMask;

    int dx, dy, xFrom, xTo;
    int p, rem, mod, lift, delta, first, incr;

    if (ey1 < mMinY) mMinY = ey1;
    if (ey1+1 > mMaxY) mMaxY = ey1+1;
    if (ey2 < mMinY) mMinY = ey2;
    if (ey2+1 > mMaxY) mMaxY = ey2+1;

    dx = x2-x1;
    dy = y2-y1;

    // everything is on a single scanline
    if (ey1 == ey2) {
      renderScanLine(ey1, x1, fy1, x2, fy2);
      return;
    }

    // vertical line: we have to calculate start and end cells,
    // and then the common values of the area and coverage for
    // all cells of the line. we know exactly there's only one
    // cell, so, we don't have to call renderScanLine().
    incr  = 1;
    if (dx == 0) {
      int ex = x1>>PolyBaseShift;
      int twoFx = (x1-(ex<<PolyBaseShift))<<1;
      int area;

      first = PolyBaseSize;
      if (dy < 0) {
        first = 0;
        incr = -1;
      }

      xFrom = x1;

      //renderScanLine(ey1, xFrom, fy1, xFrom, first);
      delta = first-fy1;
      mCurCell.addCover(delta, twoFx*delta);

      ey1 += incr;
      setCurCell(ex, ey1);

      delta = first+first-PolyBaseSize;
      area = twoFx*delta;
      while (ey1 != ey2) {
        //renderScanLine(ey1, xFrom, PolyBaseSize - first, xFrom, first);
        mCurCell.setCover(delta, area);
        ey1 += incr;
        setCurCell(ex, ey1);
      }
      //renderScanLine(ey1, xFrom, PolyBaseSize - first, xFrom, fy2);
      delta = fy2-PolyBaseSize+first;
      mCurCell.addCover(delta, twoFx*delta);
      return;
    }

    // ok, we have to render several scanlines
    p = (PolyBaseSize-fy1)*dx;
    first = PolyBaseSize;

    if (dy < 0) {
      p = fy1*dx;
      first = 0;
      incr = -1;
      dy = -dy;
    }

    delta = p/dy;
    mod = p%dy;

    if (mod < 0) {
      --delta;
      mod += dy;
    }

    xFrom = x1+delta;
    renderScanLine(ey1, x1, fy1, xFrom, first);

    ey1 += incr;
    setCurCell(xFrom>>PolyBaseShift, ey1);

    if (ey1 != ey2) {
      p = PolyBaseSize*dx;
      lift = p/dy;
      rem = p%dy;

      if (rem < 0) {
        --lift;
        rem += dy;
      }
      mod -= dy;

      while (ey1 != ey2) {
        delta = lift;
        mod += rem;
        if (mod >= 0) {
          mod -= dy;
          ++delta;
        }

        xTo = xFrom+delta;
        renderScanLine(ey1, xFrom, PolyBaseSize-first, xTo, first);
        xFrom = xTo;

        ey1 += incr;
        setCurCell(xFrom>>PolyBaseShift, ey1);
      }
    }

    renderScanLine(ey1, xFrom, PolyBaseSize-first, x2, fy2);
  }

  static void qsortCells (Cell** start, uint num) {
    static void swapCells (Cell** a, Cell** b) nothrow @trusted @nogc {
      pragma(inline, true);
      auto temp = *a;
      *a = *b;
      *b = temp;
    }

    static bool lessThan (Cell** a, Cell** b) nothrow @trusted @nogc { pragma(inline, true); return ((**a).packedCoord < (**b).packedCoord); }

    Cell**[80] stack = void;
    Cell*** top;
    Cell** limit;
    Cell** base;

    limit = start+num;
    base = start;
    top = stack.ptr;

    for (;;) {
      int len = cast(int)(limit-base);

      Cell** i;
      Cell** j;
      Cell** pivot;

      if (len > QSortThreshold) {
        // we use base + len/2 as the pivot
        pivot = base+len/2;
        swapCells(base, pivot);

        i = base+1;
        j = limit-1;

        // now ensure that *i <= *base <= *j
        if (lessThan(j, i)) swapCells(i, j);
        if (lessThan(base, i)) swapCells(base, i);
        if (lessThan(j, base)) swapCells(base, j);

        for (;;) {
          do { ++i; } while (lessThan(i, base));
          do { --j; } while (lessThan(base, j));
          if (i > j) break;
          swapCells(i, j);
        }

        swapCells(base, j);

        // now, push the largest sub-array
        if (j-base > limit-i) {
          top[0] = base;
          top[1] = j;
          base = i;
        } else {
          top[0] = i;
          top[1] = limit;
          limit = j;
        }
        top += 2;
      } else {
        // the sub-array is small, perform insertion sort
        j = base;
        i = j+1;
        for (; i < limit; j = i, ++i) {
          for (; lessThan(j+1, j); --j) {
            swapCells(j+1, j);
            if (j == base) break;
          }
        }
        if (top > stack.ptr) {
          top -= 2;
          base = top[0];
          limit = top[1];
        } else {
          break;
        }
      }
    }
  }

  void sortCells () {
    if (mNumCells == 0) return;

    if (mNumCells > mSortedSize) {
      import core.stdc.stdlib: realloc;
      mSortedSize = mNumCells;
      mSortedCells = cast(Cell**)realloc(mSortedCells, (mNumCells+1)*(Cell*).sizeof);
    }

    Cell** sortedPtr = mSortedCells;
    Cell** blockPtr = mCells;
    Cell* cellPtr;

    uint nb = mNumCells>>CellBlockShift;
    uint i;

    while (nb--) {
      cellPtr = *blockPtr++;
      i = CellBlockSize;
      while (i--) *sortedPtr++ = cellPtr++;
    }

    cellPtr = *blockPtr++;
    i = mNumCells&CellBlockMask;
    while (i--) *sortedPtr++ = cellPtr++;
    mSortedCells[mNumCells] = null;
    qsortCells(mSortedCells, mNumCells);
  }
}


/* *****************************************************************************
  Polygon rasterizer that is used to render filled polygons with
  high-quality Anti-Aliasing. Internally, by default, the class uses
  integer coordinates in format 24.8, i.e. 24 bits for integer part
  and 8 bits for fractional - see PolyBaseShift. This class can be
  used in the following  way:

  1. fillRule = FillRule.EvenOdd; // optional

  2. gamma() - optional.

  3. reset()

  4. moveTo(x, y) / lineTo(x, y) - make the polygon. One can create
     more than one contour, but each contour must consist of at least 3
     vertices, i.e. moveTo(x1, y1); lineTo(x2, y2); lineTo(x3, y3);
     is the absolute minimum of vertices that define a triangle.
     The algorithm does not check either the number of vertices nor
     coincidence of their coordinates, but in the worst case it just
     won't draw anything.
     The orger of the vertices (clockwise or counterclockwise)
     is important when using the non-zero filling rule (FillNonZero).
     In this case the vertex order of all the contours must be the same
     if you want your intersecting polygons to be without "holes".
     You actually can use different vertices order. If the contours do not
     intersect each other the order is not important anyway. If they do,
     contours with the same vertex order will be rendered without "holes"
     while the intersecting contours with different orders will have "holes".

  fillRule() and gamma() can be called anytime before "sweeping".
***************************************************************************** */
public struct Rasterizer {
public:
  enum : uint {
    AAShift = ScanLine.AAShift,
    AANum = 1<<AAShift,
    AAMask = AANum-1,
    AA2Num = AANum*2,
    AA2Mask = AA2Num-1,
  }

  enum FillRule {
    NonZero,
    EvenOdd,
  }

private:
  Outline mOutline;
  ScanLine mScanline;
  FillRule mFillingRule = FillRule.NonZero;
  ubyte[256] mGamma = DefaultGamma[];

public nothrow @trusted @nogc:
  void reset () { mOutline.reset(); }

  @property FillRule fillRule () const pure { pragma(inline, true); return mFillingRule; }
  @property void fillRule (FillRule v) { pragma(inline, true); mFillingRule = v; }

  void gamma (in double g) {
    foreach (immutable uint i; 0..256) {
      import std.math : pow;
      mGamma.ptr[i] = cast(ubyte)(pow(cast(double)i/255.0, g)*255.0);
    }
  }

  void gamma (const(ubyte)[] g) {
    if (g.length != 256) assert(0, "invalid gamma array");
    mGamma[] = g[0..256];
  }

  void moveTo (int x, int y) { mOutline.moveTo(x, y); }
  void lineTo (int x, int y) { mOutline.lineTo(x, y); }

  void moveTo (in double x, in double y) { mOutline.moveTo(polyCoord(x), polyCoord(y)); }
  void lineTo (in double x, in double y) { mOutline.lineTo(polyCoord(x), polyCoord(y)); }

  @property double curX () const pure { pragma(inline, true); return mOutline.curX; }
  @property double curY () const pure { pragma(inline, true); return mOutline.curY; }

  @property int minX () const pure { pragma(inline, true); return mOutline.minX; }
  @property int minY () const pure { pragma(inline, true); return mOutline.minY; }
  @property int maxX () const pure { pragma(inline, true); return mOutline.maxX; }
  @property int maxY () const pure { pragma(inline, true); return mOutline.maxY; }

  uint calculateAlpha (int area) const pure {
    int cover = area>>(PolyBaseShift*2+1-AAShift);
    if (cover < 0) cover = -cover;
    if (mFillingRule == FillRule.EvenOdd) {
      cover &= AA2Mask;
      if (cover > AANum) cover = AA2Num-cover;
    }
    if (cover > AAMask) cover = AAMask;
    return cover;
  }

  void render(RT) (ref RT r, in Color c, int dx=0, int dy=0) if (is(RT : Renderer!ST, ST)) {
    const(Cell)** cells = mOutline.cells();
    if (mOutline.numCells() == 0) return;

    int x, y;
    int cover;
    int alpha;
    int area;

    mScanline.reset(mOutline.minX(), mOutline.maxX(), dx, dy);

    cover = 0;
    const(Cell)* curCell = *cells++;
    for (;;) {
      const(Cell)* startCell = curCell;

      int coord = curCell.packedCoord;
      x = curCell.x;
      y = curCell.y;

      area = startCell.area;
      cover += startCell.cover;

      // accumulate all start cells
      while ((curCell = *cells++) !is null) {
        if (curCell.packedCoord != coord) break;
        area  += curCell.area;
        cover += curCell.cover;
      }

      if (area) {
        alpha = calculateAlpha((cover<<(PolyBaseShift+1))-area);
        if (alpha) {
          if (mScanline.isReady(y)) {
            r.render(mScanline, c);
            mScanline.resetSpans();
          }
          mScanline.addCell(x, y, mGamma[alpha]);
        }
        ++x;
      }

      if (!curCell) break;

      if (curCell.x > x) {
        alpha = calculateAlpha(cover<<(PolyBaseShift+1));
        if (alpha) {
          if (mScanline.isReady(y)) {
            r.render(mScanline, c);
            mScanline.resetSpans();
          }
          mScanline.addSpan(x, y, curCell.x-x, mGamma[alpha]);
        }
      }
    }

    if (mScanline.numSpans) r.render(mScanline, c);
  }

  bool hitTest (int tx, int ty) {
    const(Cell)** cells = mOutline.cells();
    if (mOutline.numCells == 0) return false;

    int x, y;
    int cover;
    int alpha;
    int area;

    cover = 0;
    const(Cell)* curCell = *cells++;
    for (;;) {
      const(Cell)* startCell = curCell;

      int coord = curCell.packedCoord;
      x = curCell.x;
      y = curCell.y;

      if (y > ty) return false;

      area = startCell.area;
      cover += startCell.cover;

      while ((curCell = *cells++) !is null) {
        if (curCell.packedCoord != coord) break;
        area += curCell.area;
        cover += curCell.cover;
      }

      if (area) {
        alpha = calculateAlpha((cover<<(PolyBaseShift+1))-area);
        if (alpha) {
          if (tx == x && ty == y) return true;
        }
        ++x;
      }

      if (!curCell) break;

      if (curCell.x > x) {
        alpha = calculateAlpha(cover<<(PolyBaseShift+1));
        if (alpha) {
          if (ty == y && tx >= x && tx <= curCell.x) return true;
        }
      }
    }
    return false;
  }

private:
  static immutable ubyte[256] DefaultGamma = [
      0,  0,  1,  1,  2,  2,  3,  4,  4,  5,  5,  6,  7,  7,  8,  8,
      9, 10, 10, 11, 11, 12, 13, 13, 14, 14, 15, 16, 16, 17, 18, 18,
     19, 19, 20, 21, 21, 22, 22, 23, 24, 24, 25, 25, 26, 27, 27, 28,
     29, 29, 30, 30, 31, 32, 32, 33, 34, 34, 35, 36, 36, 37, 37, 38,
     39, 39, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 47, 48, 49,
     49, 50, 51, 51, 52, 53, 53, 54, 55, 55, 56, 57, 57, 58, 59, 60,
     60, 61, 62, 62, 63, 64, 65, 65, 66, 67, 68, 68, 69, 70, 71, 71,
     72, 73, 74, 74, 75, 76, 77, 78, 78, 79, 80, 81, 82, 83, 83, 84,
     85, 86, 87, 88, 89, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,
    100,101,101,102,103,104,105,106,107,108,109,110,111,112,114,115,
    116,117,118,119,120,121,122,123,124,126,127,128,129,130,131,132,
    134,135,136,137,139,140,141,142,144,145,146,147,149,150,151,153,
    154,155,157,158,159,161,162,164,165,166,168,169,171,172,174,175,
    177,178,180,181,183,184,186,188,189,191,192,194,195,197,199,200,
    202,204,205,207,209,210,212,214,215,217,219,220,222,224,225,227,
    229,230,232,234,236,237,239,241,242,244,246,248,249,251,253,255
  ];
}


// ////////////////////////////////////////////////////////////////////////// //
// X11 image: "bgra"; TrueColorImage: "rgba"
public struct SimpleSpan(string mode)
if (mode == "bgra" || mode == "rgba" || mode == "x11" || mode == "X11" || mode == "arsd" || mode == "bgr" || mode == "rgb")
{
  static if (mode == "bgra" || mode == "x11" || mode == "X11") {
    enum IsBGRA = true;
    enum Is32Bit = true;
  } else static if (mode == "rgba" || mode == "arsd") {
    enum IsBGRA = false;
    enum Is32Bit = true;
  } else static if (mode == "bgr") {
    enum IsBGRA = true;
    enum Is32Bit = false;
  } else static if (mode == "rgb") {
    enum IsBGRA = false;
    enum Is32Bit = false;
  } else {
    static assert(0, "invalid mode");
  }

  static void render (ubyte* ptr, int x, uint count, const(ubyte)* covers, in Color c) {
    static if (Is32Bit) {
      ubyte* p = ptr+(x<<2);
    } else {
      ubyte* p = ptr+x+x+x;
    }
    do {
      int alpha = (*covers++)*c.a;
      static if (IsBGRA) {
        int b = p[0];
        int g = p[1];
        int r = p[2];
        static if (Is32Bit) int a = p[3];
        *p++ = cast(ubyte)((((c.b-b)*alpha)+(b<<16))>>16);
        *p++ = cast(ubyte)((((c.g-g)*alpha)+(g<<16))>>16);
        *p++ = cast(ubyte)((((c.r-r)*alpha)+(r<<16))>>16);
        static if (Is32Bit) *p++ = cast(ubyte)((((c.a-a)*alpha)+(a<<16))>>16);
      } else {
        int r = p[0];
        int g = p[1];
        int b = p[2];
        static if (Is32Bit) int a = p[3];
        *p++ = cast(ubyte)((((c.r-r)*alpha)+(r<<16))>>16);
        *p++ = cast(ubyte)((((c.g-g)*alpha)+(g<<16))>>16);
        *p++ = cast(ubyte)((((c.b-b)*alpha)+(b<<16))>>16);
        static if (Is32Bit) *p++ = cast(ubyte)((((c.a-a)*alpha)+(a<<16))>>16);
      }
    } while (--count);
  }

  static void hline (ubyte* ptr, int x, uint count, in Color c) {
    static if (!IsBGRA && Is32Bit) {
      // fastest case
      uint* p = cast(uint*)(ptr+(x<<2));
      p[0..count] = c.asUint;
    } else {
      static if (Is32Bit) {
        ubyte* p = ptr+(x<<2);
      } else {
        ubyte* p = ptr+x+x+x;
      }
      do {
        static if (IsBGRA) {
          *p++ = c.b;
          *p++ = c.g;
          *p++ = c.r;
        } else {
          *p++ = c.r;
          *p++ = c.g;
          *p++ = c.b;
        }
        static if (Is32Bit) *p++ = c.a;
      } while (--count);
    }
  }

  static Color get (const(ubyte)* ptr, int x) {
    static if (Is32Bit) {
      const(ubyte)* p = ptr+(x<<2);
    } else {
      const(ubyte)* p = ptr+x+x+x;
    }
    static if (IsBGRA) {
      static if (Is32Bit) {
        return Color(p[2], p[1], p[0], p[3]);
      } else {
        return Color(p[2], p[1], p[0], 255);
      }
    } else {
      static if (Is32Bit) {
        return Color(p[0], p[1], p[2], p[3]);
      } else {
        return Color(p[0], p[1], p[2]);
      }
    }
  }
}
+/


// ////////////////////////////////////////////////////////////////////////// //
/+
version(linux) final class SdpyDrawVBuf : SdpyDrawBase {
private:
  XImageTC vbuf;

protected:
  // must be overriden
  override Color getpix (int x, int y) {
    pragma(inline, true);
    return XlibImageTC.img2c(vbuf.data[y*vbuf.width+x]);
  }

  override void putpix (int x, int y, Color col) {
    uint* dp = vbuf.data+y*vbuf.width+x;
    if (col.a == 255) *dp = XlibImageTC.c2img(col)|0xff_000000; else *dp = blendU32(*dp, XlibImageTC.c2img(col)|(col.a<<24));
  }

  // optionals
  override void hline (int x, int y, int len, Color col) {
    uint* dp = vbuf.data+y*vbuf.width+x;
    uint uc = XlibImageTC.c2img(col);
    if (col.a == 255) {
      uc |= 0xff_000000;
      foreach (immutable _; 0..len) *dp++ = uc;
    } else {
      uc |= col.a<<24;
      foreach (immutable _; 0..len) { *dp = blendU32(*dp, uc); ++dp; }
    }
  }

public:
  this (XImageTC img) {
    vbuf = img;
    super(img.width, img.height);
  }

  override TrueColorImage getBuffer () {
    auto img = new TrueColorImage(vbuf.width, vbuf.height);
    const(uint)* sp = cast(const(uint)*)vbuf.data;
    auto dp = img.imageData.colors.ptr;
    foreach (immutable y; 0..vbuf.height) {
      foreach (immutable x; 0..vbuf.width) {
        *dp++ = XlibImageTC.img2c(*sp++);
      }
    }
    return img;
  }

  final @property XImageTC imagebuf () pure nothrow @safe @nogc { pragma(inline, true); return vbuf; }

  final void cls (Color clr) {
    import core.stdc.string : memset;
    if (!vbuf.valid) return;
    if (clr.r == 0 && clr.g == 0 && clr.b == 0) {
      memset(vbuf.data, 0, vbuf.width*vbuf.height*uint.sizeof);
    } else {
      drawRect!true(0, 0, vbuf.width, vbuf.height);
    }
  }

  void blitFrom (DFImage src, int x0, int y0, int subalpha=-1, int cx0=0, int cy0=0, int cx1=int.max, int cy1=int.max) {
    if (src is null || !src.valid || !vbuf.valid) return;
    if (cx1 >= vbuf.width) cx1 = vbuf.width-1;
    if (cy1 >= vbuf.height) cy1 = vbuf.height-1;
    if (cx0 < 0) cx0 = 0;
    if (cy0 < 0) cy0 = 0;
    if (cx1 < cx0 || cy1 < cy0 || cx1 < 0 || cy1 < 0 || cx0 >= vbuf.width || cy0 >= vbuf.height) return; // nothing to do here

    void doBlit(bool doSrcAlpha, bool doSubAlpha) (int x, int y, int xofs, int yofs, int wdt, int hgt, int subalpha=0) {
      auto sc = cast(const(uint)*)src.data.ptr;
      auto dc = vbuf.data;
      sc += yofs*src.width+xofs;
      dc += y*vbuf.width+x;
      foreach (immutable dy; 0..hgt) {
        static if (!doSubAlpha && !doSrcAlpha) {
          // fastest path
          import core.stdc.string : memcpy;
          memcpy(dc, sc, wdt*uint.sizeof);
        } else {
          auto scl = sc;
          auto dcl = dc;
          foreach (immutable dx; 0..wdt) {
            static if (doSubAlpha) {
              static assert(!doSrcAlpha);
              *dcl = XlibImageTC.icRGB(
                XlibImageTC.icR(*dcl)+XlibImageTC.icR(*scl)*(255-subalpha)/255,
                XlibImageTC.icG(*dcl)+XlibImageTC.icG(*scl)*(255-subalpha)/255,
                XlibImageTC.icB(*dcl)+XlibImageTC.icB(*scl)*(255-subalpha)/255,
              );
            } else {
              static assert(doSrcAlpha);
              if (XlibImageTC.icA(*scl) == 255) {
                *dcl = *scl;
              } else if (XlibImageTC.icA(*scl)) {
                *dcl = (*dcl).blendU32(*scl);
              }
            }
            ++scl;
            ++dcl;
          }
        }
        sc += src.width;
        dc += vbuf.width;
      }
    }

    int swdt = src.width, shgt = src.height, xofs = 0, yofs = 0, x = x0, y = y0;
    if (!GxRect(cx0, cy0, cx1-cx0+1, cy1-cy0+1).clipHVStripes(x, y, swdt, shgt, &xofs, &yofs)) return; // nothing to do here
    if (!src.hasAlpha && subalpha < 0) {
      doBlit!(false, false)(x, y, xofs, yofs, swdt, shgt);
    } else if (subalpha >= 0) {
      doBlit!(false, true)(x, y, xofs, yofs, swdt, shgt, subalpha);
    } else if (src.hasAlpha) {
      doBlit!(true, false)(x, y, xofs, yofs, swdt, shgt);
    } else {
      assert(0, "wtf?!");
    }
  }

  void blendRect (int x0, int y0, int w, int h, Color clr) {
    if (clr.a == 0 || !vbuf.valid) return;
    if (!GxRect(0, 0, vbuf.width, vbuf.height).clipHVStripes(x0, y0, w, h)) return; // nothing to do here
    auto dc = vbuf.data;
    dc += y0*vbuf.width+x0;
    if (clr.a == 255) {
      uint c = XlibImageTC.c2img(clr);
      foreach (immutable dy; 0..h) {
        auto dcl = dc;
        foreach (immutable dx; 0..w) *dcl++ = c;
        dc += vbuf.width;
      }
    } else {
      uint c = XlibImageTC.icRGBA(clr.r, clr.g, clr.b, clr.a);
      foreach (immutable dy; 0..h) {
        auto dcl = dc;
        foreach (immutable dx; 0..w) {
          *dcl = (*dcl).blendU32(c);
          ++dcl;
        }
        dc += vbuf.width;
      }
    }
  }
}
+/
