/* coded by Ketmar // Invisible Vector <ketmar@ketmar.no-ip.org>
 * Understanding is not required. Only obedience.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/// DO NOT USE YET!
module iv.glkgi;

import core.atomic;
import std.concurrency;

public import arsd.simpledisplay;
//public import arsd.color;
//public import arsd.image;

import iv.bclamp;
public import iv.cmdcongl;
import iv.glbinds;

//version=glkgi_rgba; // default, has priority
//version=glkgi_bgra;

version(BigEndian) static assert(0, "sorry, big-endian platforms aren't supported yet");

version(aliced) {} else private alias usize = size_t;

version(glkgi_rgba) {
  public enum KGIRGBA = true;
} else version(glkgi_bgra) {
  public enum KGIRGBA = false;
} else {
  public enum KGIRGBA = true;
}


// ////////////////////////////////////////////////////////////////////////// //
public enum kgiMaxCurW = 64;
public enum kgiMaxCurH = 64;


// ////////////////////////////////////////////////////////////////////////// //
// 0:b; 1:g; 2:r; 3: nothing
private __gshared int vbufW = 800, vbufH = 600;
__gshared uint* vbuf; // see KGIRGBA
__gshared uint* vbufsaved; // saved before updating texture
private __gshared uint* vcurbuf;
private __gshared bool blit2x = false;
//private enum BlitType { normal, bw, green, red }
//private __gshared BlitType blitType = BlitType.normal;
private __gshared bool scanlines = false;
private __gshared SimpleWindow vbwin;
private __gshared uint vbTexId = 0;
private __gshared uint vbCurTexId = 0;
private __gshared uint sdrScanlineId = 0;
private __gshared int shaderVersionOk = -1; // <0: not checked; 0: fail; >0: ok
private __gshared string kgiTitle = "KGI Graphics";
private __gshared uint vupcounter = 0;
private __gshared uint vupcounterlast = 0;
private shared bool updateTexture = true;
private shared bool updateCurTexture = true;
private __gshared uint fps = 35; // average FPS
private __gshared bool showShaderWarnings = false;

private __gshared int mcurX = 0, mcurY = 0;
private __gshared int mhotX = 0, mhotY = 0;
private __gshared int mcurHidden = 1;

private shared bool vWantMotionEvents = false;
private shared bool vWantCharEvents = false;


public @property bool kgiMotionEvents () nothrow @trusted @nogc { pragma(inline, true); return atomicLoad(vWantMotionEvents); } ///
public @property bool kgiCharEvents () nothrow @trusted @nogc { pragma(inline, true); return atomicLoad(vWantCharEvents); } ///

public @property void kgiMotionEvents (bool v) nothrow @trusted @nogc { pragma(inline, true); atomicStore(vWantMotionEvents, v); } ///
public @property void kgiCharEvents (bool v) nothrow @trusted @nogc { pragma(inline, true); atomicStore(vWantCharEvents, v); } ///

public @property int kgiWidth () nothrow @trusted @nogc { pragma(inline, true); return vbufW; }
public @property int kgiHeight () nothrow @trusted @nogc { pragma(inline, true); return vbufH; }


//FIXME! turn this to proper setter
public __gshared bool delegate () onKGICloseRequest;


shared static this () {
  conRegVar!blit2x("v_scale2x", "video window scale");
  conRegVar!scanlines("v_scanlines", "emulate old CRT scanline effect");
  conRegVar!vbufW(64, 4096, "v_width", "video window width");
  conRegVar!vbufH(64, 4096, "v_height", "video window height");
  conRegVar!fps(1, 60, "v_fps", "video update rate");
  conRegVar!kgiTitle("v_title", "video window title");
  conRegVar!showShaderWarnings("v_shader_warnings", "show warnings from shader compilation");
}


private void setUpdateTextureFlag () {
  pragma(inline, true);
  if (vbuf !is null) {
    atomicFence();
    auto c = vupcounter;
    if (vupcounterlast != c) {
      vupcounterlast = c;
      vbufsaved[0..vbufW*vbufH] = vbuf[0..vbufW*vbufH];
    }
    atomicStore(updateTexture, true);
  }
}


///
public void kgiHideCursor () {
  bool csc;
  {
    consoleLock();
    scope(exit) consoleUnlock();
    ++mcurHidden;
    csc = (vbwin !is null && (mcurHidden == -1 || mcurHidden == 1));
  }
  if (csc) vbwin.showCursor();
}


///
public void kgiShowCursor () {
  bool csc;
  {
    consoleLock();
    scope(exit) consoleUnlock();
    --mcurHidden;
    csc = (vbwin !is null && mcurHidden == 0);
  }
  if (csc) vbwin.hideCursor();
}


///
public void kgiSetCursor (int wdt, int hgt, const(VColor)[] img, int hotx=0, int hoty=0) nothrow @trusted @nogc {
  consoleLock();
  scope(exit) consoleUnlock();
  mhotX = hotx;
  mhotY = hoty;
  if (vcurbuf is null) return;
  vcurbuf[0..kgiMaxCurW*kgiMaxCurH] = 0;
  if (wdt < 1 || hgt < 1) return;
  foreach (immutable dy; 0..64) {
    if (dy >= hgt) break;
    foreach (immutable dx; 0..64) {
      if (dx >= wdt) break;
      uint sp = dy*wdt+dx;
      if (sp >= img.length) break;
      vcurbuf[dy*kgiMaxCurW+dx] = img.ptr[sp];
    }
  }
  atomicStore(updateCurTexture, true);
}


///
public void kgiSetDefaultCursor () nothrow @trusted @nogc {
  consoleLock();
  scope(exit) consoleUnlock();
  mhotX = 2;
  mhotY = 0;
  if (vcurbuf is null) return;
  vcurbuf[0..kgiMaxCurW*kgiMaxCurH] = 0;
  foreach (immutable dy; 0..defaultCurHeight) {
    foreach (immutable dx; 0..defaultCurWidth) {
      uint sp = dy*defaultCurWidth+dx;
      vcurbuf[dy*kgiMaxCurW+dx] = defaultCurPal.ptr[defaultCurImg.ptr[sp]];
    }
  }
  atomicStore(updateCurTexture, true);
}


public void kgiSetBlankCursor () nothrow @trusted @nogc {
  consoleLock();
  scope(exit) consoleUnlock();
  mhotX = mhotY = 0;
  if (vcurbuf is null) return;
  vcurbuf[0..kgiMaxCurW*kgiMaxCurH] = 0;
  atomicStore(updateCurTexture, true);
}


// ////////////////////////////////////////////////////////////////////////// //
///
public struct KGIEvent {
  enum Type { None, Key, Mouse, Char, Close }
  Type type = Type.None;
  union {
    KeyEvent k;
    MouseEvent m;
    dchar ch;
  }
@property const pure nothrow @trusted @nogc:
  bool isMouse () { pragma(inline, true); return (type == Type.Mouse); }
  bool isKey () { pragma(inline, true); return (type == Type.Key); }
  bool isChar () { pragma(inline, true); return (type == Type.Char); }
  bool isNone () { pragma(inline, true); return (type == Type.None); }
  bool isClose () { pragma(inline, true); return (type == Type.Close); }
}


private __gshared KGIEvent[] evbuf;
private __gshared uint evbufused;


///
public bool kgiHasEvent () {
  consoleLock();
  scope(exit) consoleUnlock();
  version(LDC) {} else atomicFence();
  if (vupcounter) setUpdateTextureFlag(); // just in case
  return (evbufused > 0 || vbwin is null); // no vbwin --> always has Quit
}


///
public KGIEvent kgiPeekEvent () {
  consoleLock();
  scope(exit) consoleUnlock();
  version(LDC) {} else atomicFence();
  if (vupcounter) setUpdateTextureFlag(); // just in case
  if (evbufused > 0) return evbuf[0];
  if (vbwin is null) return KGIEvent(KGIEvent.Type.Close);
  return KGIEvent();
}


///
public KGIEvent kgiGetEvent () {
  import core.thread;
  import core.time;
  version(LDC) {} else atomicFence();
  if (vupcounter) setUpdateTextureFlag(); // just in case
  for (;;) {
    {
      consoleLock();
      scope(exit) consoleUnlock();
      if (evbufused > 0) {
        auto ev = evbuf[0];
        if (evbufused > 1) {
          import core.stdc.string : memmove;
          memmove(evbuf.ptr, evbuf.ptr+1, KGIEvent.sizeof*(evbufused-1));
        }
        --evbufused;
        evbuf[evbufused].type = KGIEvent.Type.None;
        return ev;
      } else if (vbwin is null) {
        return KGIEvent(KGIEvent.Type.Close);
      }
    }
    Thread.sleep(10.msecs);
  }
}


private void pushEventIntr (ref KGIEvent ev) {
  if (evbufused >= evbuf.length) evbuf.length += 256;
  evbuf[evbufused++] = ev;
}


///
public void kgiPushEvent (KeyEvent e) {
  KGIEvent ev = void;
  ev.type = KGIEvent.Type.Key;
  ev.k = e;
  consoleLock();
  scope(exit) consoleUnlock();
  pushEventIntr(ev);
}

///
public void kgiPushEvent (MouseEvent e) {
  KGIEvent ev = void;
  ev.type = KGIEvent.Type.Mouse;
  ev.m = e;
  consoleLock();
  scope(exit) consoleUnlock();
  pushEventIntr(ev);
}

///
public void kgiPushEvent (dchar ch) {
  KGIEvent ev = void;
  ev.type = KGIEvent.Type.Char;
  ev.ch = ch;
  consoleLock();
  scope(exit) consoleUnlock();
  pushEventIntr(ev);
}


/// remove all keypresses from input queue
public void kgiKeyFlush () {
  uint sidx = 0, didx = 0;
  consoleLock();
  scope(exit) consoleUnlock();
  while (sidx < evbufused) {
    if (!evbuf[sidx].isKey) {
      if (sidx != didx) evbuf[didx] = evbuf[sidx];
      ++didx;
    }
    ++sidx;
  }
  evbufused = didx;
}


/// wait for keypress (and eat it)
public void kgiWaitKey () {
  for (;;) {
    auto ev = kgiGetEvent();
    if (ev.isClose) {
      consoleLock();
      scope(exit) consoleUnlock();
      evbufused = 1;
      evbuf[0] = ev;
      return;
    }
    if (!ev.isKey) continue;
    if (!ev.k.pressed) continue;
    break;
  }
}


/// flush drawing buffer (copy it to actual screen)
public void kgiFlush () {
  setUpdateTextureFlag();
  while (atomicLoad(updateTexture)) {
    import core.thread;
    import core.time;
    Thread.sleep(1.msecs);
  }
}


// ////////////////////////////////////////////////////////////////////////// //
///
public void kgiDeinit () {
  concmd("quit");
}


private void kgiThread (Tid starterTid) {
  try {
    vbwin = new SimpleWindow(vbufW*(blit2x ? 2 : 1), vbufH*(blit2x ? 2 : 1), kgiTitle, OpenGlOptions.yes, Resizablity.fixedSize);
    if (mcurHidden == 0) vbwin.hideCursor();

    vbwin.redrawOpenGlScene = delegate () {
      glgfxBlit();
      glconDraw();
    };

    vbwin.closeQuery = delegate () {
      if (onKGICloseRequest !is null) try { if (!onKGICloseRequest()) return; } catch (Throwable e) {}
      concmd("quit");
    };

    vbwin.visibleForTheFirstTime = delegate () {
      vbwin.setAsCurrentOpenGlContext();
      /+
      {
        import core.stdc.stdio;
        printf("GL version: %s\n", glGetString(GL_VERSION));
        GLint l, h;
        glGetIntegerv(GL_MAJOR_VERSION, &h);
        glGetIntegerv(GL_MINOR_VERSION, &l);
        printf("version: %d.%d\n", h, l);
        printf("shader version: %s\n", glGetString(GL_SHADING_LANGUAGE_VERSION));
        GLint svcount;
        glGetIntegerv(GL_NUM_SHADING_LANGUAGE_VERSIONS, &svcount);
        if (svcount > 0) {
          printf("%d shader versions supported:\n", svcount);
          foreach (GLuint n; 0..svcount) printf("  %d: %s\n", n, glGetStringi(GL_SHADING_LANGUAGE_VERSION, n));
        }
        /*
        GLint ecount;
        glGetIntegerv(GL_NUM_EXTENSIONS, &ecount);
        if (ecount > 0) {
          printf("%d extensions supported:\n", ecount);
          foreach (GLuint n; 0..ecount) printf("  %d: %s\n", n, glGetStringi(GL_EXTENSIONS, n));
        }
        */
      }
      +/
      glgfxInitTexture();
      glconInit(vbufW, vbufH, (blit2x ? 2 : 1));
      glgfxUpdateTexture();
      vbwin.redrawOpenGlSceneNow();

      send(starterTid, 42);
    };

    bool receiveMessages () {
      bool res = false;
      for (;;) {
        import core.time : Duration;
        auto got = receiveTimeout(
          Duration.zero, // don't wait
          (OwnerTerminated e) {
            //conwriteln("OWNER IS TERMINATED!");
            res = true;
          },
          (Variant v) {
            conwriteln("WARNING: unknown thread message received and ignored: ", v.toString);
          },
        );
        if (!got) break; // no more messages
      }
      return res;
    }

    void processConsoleCommands () {
      consoleLock();
      scope(exit) consoleUnlock();
      conProcessQueue();
    }

    bool lastConVisible = isConsoleVisible;

    vbwin.eventLoop(1000/fps,
      delegate () {
        if (vbwin.closed) return;
        if (isQuitRequested) { vbwin.close(); return; }
        if (receiveMessages()) { vbwin.close(); return; }
        processConsoleCommands();
        if (lastConVisible != isConsoleVisible) {
          lastConVisible = !lastConVisible;
          setUpdateTextureFlag();
          consoleLock();
          scope(exit) consoleUnlock();
          if (evbufused == 0) {
            KGIEvent kev;
            pushEventIntr(kev);
          }
        }
        if (atomicLoad(updateTexture)) {
          glgfxUpdateTexture();
          vbwin.redrawOpenGlSceneNow();
        } else if (mcurHidden == 0) {
          glgfxUpdateCurTexture();
          vbwin.redrawOpenGlSceneNow();
        }
      },
      delegate (KeyEvent event) {
        if (vbwin.closed) return;
        if (isQuitRequested) { vbwin.close(); return; }
        if (glconKeyEvent(event)) return;
        //if (event.pressed && event.key == Key.Escape) { concmd("quit"); return; }
        kgiPushEvent(event);
      },
      delegate (MouseEvent event) {
        if (vbwin.closed) return;
        mcurX = event.x/(blit2x ? 2 : 1);
        mcurY = event.y/(blit2x ? 2 : 1);
        if (event.type == MouseEventType.motion && !kgiMotionEvents) return;
        if (blit2x) { event.x /= 2; event.y /= 2; }
        kgiPushEvent(event);
      },
      delegate (dchar ch) {
        if (vbwin.closed) return;
        if (glconCharEvent(ch)) return;
        if (ch == '`') concmd("r_console tan");
        if (!kgiCharEvents) return;
        kgiPushEvent(ch);
      },
    );
  } catch (Throwable e) {
    // here, we are dead and fucked (the exact order doesn't matter)
    import core.stdc.stdlib : abort;
    import core.stdc.stdio : fprintf, stderr;
    import core.memory : GC;
    import core.thread;
    GC.disable(); // yeah
    thread_suspendAll(); // stop right here, you criminal scum!
    auto s = e.toString();
    fprintf(stderr, "\n=== FATAL ===\n%.*s\n", cast(uint)s.length, s.ptr);
    abort(); // die, you bitch!
  }
  flushGui();
  vbwin = null;
  /*
  {
    import core.stdc.stdlib : exit;
    exit(0);
  }
  */
  {
    consoleLock();
    scope(exit) consoleUnlock();
    KGIEvent ev;
    ev.type = KGIEvent.Type.Close;
    evbufused = 0;
    pushEventIntr(ev);
  }
  //atomicSet(kgiThreadStarted, false);
}


// ////////////////////////////////////////////////////////////////////////// //
private __gshared Tid kgiTid;
private shared bool kgiThreadStarted = false;


private void startKGIThread () {
  //if (!cas(&kgiThreadStarted, false, true)) assert(0, "render thread already started!");
  kgiTid = spawn(&kgiThread, thisTid);
  setMaxMailboxSize(kgiTid, 1024, OnCrowding.throwException); //FIXME
  // wait for "i'm ready" signal
  receive(
    (int ok) {
      if (ok != 42) assert(0, "wtf?!");
    },
  );
  //conwriteln("rendering thread started");
}


///
public bool kgiInitEx (int awdt, int ahgt, string title, bool a2x, uint afps) {
  import core.stdc.stdlib : malloc;
  import arsd.simpledisplay;

  if (awdt < 1 || ahgt < 1 || awdt > 4096 || ahgt > 4096) {
    return false;
    //assert(0, "invalid dimensions");
  }

  if (!cas(&kgiThreadStarted, false, true)) return false;

  if (vbwin !is null) assert(0, "double initialization");

  if (afps < 1) afps = 1; else if (afps > 60) afps = 60;

  conSealVar("v_scale2x");
  conSealVar("v_width");
  conSealVar("v_height");
  conSealVar("v_title");
  conSealVar("v_fps");

  vbuf = cast(typeof(vbuf))malloc(vbuf[0].sizeof*awdt*ahgt);
  if (vbuf is null) assert(0, "KGI: out of memory");
  vbuf[0..awdt*ahgt] = 0;

  vbufsaved = cast(typeof(vbuf))malloc(vbufsaved[0].sizeof*awdt*ahgt);
  if (vbufsaved is null) assert(0, "KGI: out of memory");
  vbufsaved[0..awdt*ahgt] = vbuf[0..awdt*ahgt];

  vcurbuf = cast(typeof(vcurbuf))malloc(vcurbuf[0].sizeof*kgiMaxCurW*kgiMaxCurH);
  if (vbuf is null) assert(0, "KGI: out of memory");
  vcurbuf[0..kgiMaxCurW*kgiMaxCurH] = 0;

  vbufW = awdt;
  vbufH = ahgt;
  blit2x = a2x;
  fps = afps;
  kgiTitle = title;

  setOpenGLContextVersion(3, 2); // up to GLSL 150
  //openGLContextCompatible = false;

  startKGIThread();

  return true;
}


public bool kgiInit () { return kgiInitEx(vbufW, vbufH, kgiTitle, blit2x, fps); }
public bool kgiInit (int awdt, int ahgt) { return kgiInitEx(awdt, ahgt, kgiTitle, blit2x, fps); }
public bool kgiInit (int awdt, int ahgt, string title) { return kgiInitEx(awdt, ahgt, title, blit2x, fps); }
public bool kgiInit (int awdt, int ahgt, string title, bool a2x) { return kgiInitEx(awdt, ahgt, title, a2x, fps); }
public bool kgiInit (int awdt, int ahgt, string title, bool a2x, uint afps) { return kgiInitEx(awdt, ahgt, title, a2x, afps); }


// ////////////////////////////////////////////////////////////////////////// //
private uint glgfxCompileShader (const(char)[] src) nothrow @trusted @nogc {
  import iv.glbinds;

  if (shaderVersionOk < 0) {
    // check if we have sufficient shader version here
    shaderVersionOk = 0;
    bool found = false;
    GLint svcount;
    glGetIntegerv(GL_NUM_SHADING_LANGUAGE_VERSIONS, &svcount);
    if (svcount > 0) {
      foreach (GLuint n; 0..svcount) {
        import core.stdc.string : strncmp;
        auto v = glGetStringi(GL_SHADING_LANGUAGE_VERSION, n);
        if (v is null) continue;
        //if (strncmp(v, "130", 3) != 0) continue;
        if (strncmp(v, "150", 3) != 0) continue;
        if (v[3] > ' ') continue;
        found = true;
        break;
      }
    }
    if (!found) return 0; //assert(0, "can't find OpenGL GLSL 150");
    /*
    {
      auto adr = glGetProcAddress("glTexParameterf");
      if (adr is null) return 0;
    }
    */
    shaderVersionOk = 1;
  }
  if (shaderVersionOk == 0) return 0;
  return compileShaders(src);
}


private void glgfxInitTexture () nothrow @trusted @nogc {
  import iv.glbinds;

  //if (vbTexId) { glDeleteTextures(1, &vbTexId); vbTexId = 0; }

  enum wrapOpt = GL_REPEAT;
  enum filterOpt = GL_NEAREST; //GL_LINEAR;
  enum ttype = GL_UNSIGNED_BYTE;

  glGenTextures(1, &vbTexId);
  if (vbTexId == 0) assert(0, "can't create kgi texture");

  glGenTextures(1, &vbCurTexId);
  if (vbTexId == 0) assert(0, "can't create kgicursor texture");

  GLint gltextbinding;
  glGetIntegerv(GL_TEXTURE_BINDING_2D, &gltextbinding);
  scope(exit) glBindTexture(GL_TEXTURE_2D, gltextbinding);

  glBindTexture(GL_TEXTURE_2D, vbTexId);
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrapOpt);
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrapOpt);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, filterOpt);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, filterOpt);
  //glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
  //glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

  GLfloat[4] bclr = 0.0;
  glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, bclr.ptr);

  static if (KGIRGBA) enum TexType = GL_RGBA; else enum TexType = GL_BGRA;
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, vbufW, vbufH, 0, TexType, GL_UNSIGNED_BYTE, vbufsaved);


  glBindTexture(GL_TEXTURE_2D, vbCurTexId);
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrapOpt);
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrapOpt);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, filterOpt);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, filterOpt);
  //glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
  //glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

  //GLfloat[4] bclr = 0.0;
  glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, bclr.ptr);

  //static if (KGIRGBA) enum TexType = GL_RGBA; else enum TexType = GL_BGRA;
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, kgiMaxCurW, kgiMaxCurH, 0, TexType, GL_UNSIGNED_BYTE, vcurbuf);
}


private void glgfxUpdateTexture () nothrow @trusted @nogc {
  import iv.glbinds;

  consoleLock();
  scope(exit) consoleUnlock();

  version(LDC) {} else atomicFence();
  vupcounter = 0;

  static if (KGIRGBA) enum TexType = GL_RGBA; else enum TexType = GL_BGRA;
  glTextureSubImage2D(vbTexId, 0, 0/*x*/, 0/*y*/, vbufW, vbufH, TexType, GL_UNSIGNED_BYTE, vbufsaved);
  atomicStore(updateTexture, false);
  vupcounterlast = vupcounterlast.max;

  if (atomicLoad(updateCurTexture)) {
    glTextureSubImage2D(vbCurTexId, 0, 0/*x*/, 0/*y*/, kgiMaxCurW, kgiMaxCurH, TexType, GL_UNSIGNED_BYTE, vcurbuf);
    atomicStore(updateCurTexture, false);
  }
}


private void glgfxUpdateCurTexture () nothrow @trusted @nogc {
  import iv.glbinds;

  if (atomicLoad(updateCurTexture)) {
    consoleLock();
    scope(exit) consoleUnlock();

    static if (KGIRGBA) enum TexType = GL_RGBA; else enum TexType = GL_BGRA;
    glTextureSubImage2D(vbCurTexId, 0, 0/*x*/, 0/*y*/, kgiMaxCurW, kgiMaxCurH, TexType, GL_UNSIGNED_BYTE, vcurbuf);

    atomicStore(updateCurTexture, false);
  }
}


private void glgfxBlit () nothrow @trusted @nogc {
  import iv.glbinds;

  consoleLock();
  scope(exit) consoleUnlock();

  //if (vbwin is null || vbwin.closed || vbTexId == 0) return;

  /+
  GLint glmatmode;
  GLint gltextbinding;
  GLint oldprg;
  GLint oldfbr, oldfbw;
  GLint[4] glviewport;
  glGetIntegerv(GL_MATRIX_MODE, &glmatmode);
  glGetIntegerv(GL_TEXTURE_BINDING_2D, &gltextbinding);
  glGetIntegerv(GL_VIEWPORT, glviewport.ptr);
  glGetIntegerv(GL_CURRENT_PROGRAM, &oldprg);
  glGetIntegerv(GL_READ_FRAMEBUFFER_BINDING, &oldfbr);
  glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &oldfbw);
  glMatrixMode(GL_PROJECTION); glPushMatrix();
  glMatrixMode(GL_MODELVIEW); glPushMatrix();
  glMatrixMode(GL_TEXTURE); glPushMatrix();
  glMatrixMode(GL_COLOR); glPushMatrix();
  glPushAttrib(/*GL_ENABLE_BIT|GL_COLOR_BUFFER_BIT|GL_CURRENT_BIT*/GL_ALL_ATTRIB_BITS); // let's play safe
  // restore on exit
  scope(exit) {
    glPopAttrib(/*GL_ENABLE_BIT*/);
    glMatrixMode(GL_PROJECTION); glPopMatrix();
    glMatrixMode(GL_MODELVIEW); glPopMatrix();
    glMatrixMode(GL_TEXTURE); glPopMatrix();
    glMatrixMode(GL_COLOR); glPopMatrix();
    glMatrixMode(glmatmode);
    glBindFramebufferEXT(GL_READ_FRAMEBUFFER_EXT, oldfbr);
    glBindFramebufferEXT(GL_DRAW_FRAMEBUFFER_EXT, oldfbw);
    glBindTexture(GL_TEXTURE_2D, gltextbinding);
    glUseProgram(oldprg);
    glViewport(glviewport.ptr[0], glviewport.ptr[1], glviewport.ptr[2], glviewport.ptr[3]);
  }
  +/

  enum x = 0;
  enum y = 0;
  immutable w = vbufW;
  immutable h = vbufH;

  glBindTexture(GL_TEXTURE_CUBE_MAP, 0);
  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);

  if (scanlines && shaderVersionOk < 0) sdrScanlineId = glgfxCompileShader(sdrScanlineSrc);
  glUseProgram(scanlines ? sdrScanlineId : 0);

  glMatrixMode(GL_PROJECTION); // for ortho camera
  glLoadIdentity();
  // left, right, bottom, top, near, far
  glViewport(0, 0, w*(blit2x ? 2 : 1), h*(blit2x ? 2 : 1));
  glOrtho(0, w, h, 0, -1, 1); // top-to-bottom
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();

  glEnable(GL_TEXTURE_2D);
  glDisable(GL_LIGHTING);
  glDisable(GL_DITHER);
  //glDisable(GL_BLEND);
  glDisable(GL_DEPTH_TEST);
  //glEnable(GL_BLEND);
  //glBlendFunc(GL_SRC_ALPHA, GL_ONE);
  //glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glDisable(GL_BLEND);
  glDisable(GL_STENCIL_TEST);

  glColor4f(1, 1, 1, 1);
  glBindTexture(GL_TEXTURE_2D, vbTexId);
  //scope(exit) glBindTexture(GL_TEXTURE_2D, 0);
  glBegin(GL_QUADS);
    glTexCoord2f(0.0f, 0.0f); glVertex2i(x, y); // top-left
    glTexCoord2f(1.0f, 0.0f); glVertex2i(w, y); // top-right
    glTexCoord2f(1.0f, 1.0f); glVertex2i(w, h); // bottom-right
    glTexCoord2f(0.0f, 1.0f); glVertex2i(x, h); // bottom-left
  glEnd();

  if (mcurHidden == 0) {
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glBindTexture(GL_TEXTURE_2D, vbCurTexId);

    int cx0 = mcurX-mhotX;
    int cy0 = mcurY-mhotY;

    glBegin(GL_QUADS);
      glTexCoord2f(0.0f, 0.0f); glVertex2i(cx0, cy0); // top-left
      glTexCoord2f(1.0f, 0.0f); glVertex2i(cx0+kgiMaxCurW, cy0); // top-right
      glTexCoord2f(1.0f, 1.0f); glVertex2i(cx0+kgiMaxCurW, cy0+kgiMaxCurH); // bottom-right
      glTexCoord2f(0.0f, 1.0f); glVertex2i(cx0, cy0+kgiMaxCurH); // bottom-left
    glEnd();

    glDisable(GL_BLEND);
  }
}


// ////////////////////////////////////////////////////////////////////////// //
alias VColor = uint;

/// vlRGBA struct to ease color components extraction/replacing
align(1) struct vlRGBA {
align(1):
  static if (KGIRGBA) {
    ubyte b, g, r, a;
  } else {
    ubyte r, g, b, a;
  }
}
static assert(vlRGBA.sizeof == VColor.sizeof);


static if (KGIRGBA) {
  enum : VColor {
    vlAShift = 24,
    vlRShift = 0,
    vlGShift = 8,
    vlBShift = 16,
  }
} else {
  enum : VColor {
    vlAShift = 24,
    vlRShift = 16,
    vlGShift = 8,
    vlBShift = 0,
  }
}
static assert(vlAShift == 24, "invalid A position in color"); // alas


enum : VColor {
  vlAMask = 0xffu<<vlAShift,
  vlRMask = 0xffu<<vlRShift,
  vlGMask = 0xffu<<vlGShift,
  vlBMask = 0xffu<<vlBShift,
  vlColorMask = vlRMask|vlGMask|vlBMask,
}


enum VColor Transparent = vlAMask; /// completely transparent pixel color


bool isTransparent(T : VColor) (T col) pure nothrow @safe @nogc {
  pragma(inline, true);
  return ((col&vlAMask) == vlAMask);
}

bool isOpaque(T : VColor) (T col) pure nothrow @safe @nogc {
  pragma(inline, true);
  return ((col&vlAMask) == 0);
}

// a=0: opaque
VColor rgbcol(TR, TG, TB, TA=ubyte) (TR r, TG g, TB b, TA a=0) pure nothrow @safe @nogc
if (__traits(isIntegral, TR) && __traits(isIntegral, TG) && __traits(isIntegral, TB) && __traits(isIntegral, TA)) {
  pragma(inline, true);
  return
    (clampToByte(a)<<vlAShift)|
    (clampToByte(r)<<vlRShift)|
    (clampToByte(g)<<vlGShift)|
    (clampToByte(b)<<vlBShift);
}

alias rgbacol = rgbcol;


// generate some templates (rgbRed, rgbSetRed, etc.)
private enum genRGBGetSet(string cname) =
  "ubyte rgb"~cname~"() (VColor clr) pure nothrow @safe @nogc {\n"~
  "  pragma(inline, true);\n"~
  "  return ((clr>>vl"~cname[0]~"Shift)&0xff);\n"~
  "}\n"~
  "VColor rgbSet"~cname~"(T) (VColor clr, T v) pure nothrow @safe @nogc if (__traits(isIntegral, T)) {\n"~
  "  pragma(inline, true);\n"~
  "  return (clr&~vl"~cname[0]~"Mask)|(clampToByte(v)<<vl"~cname[0]~"Shift);\n"~
  "}\n";

mixin(genRGBGetSet!"Alpha");
mixin(genRGBGetSet!"Red");
mixin(genRGBGetSet!"Green");
mixin(genRGBGetSet!"Blue");


// ////////////////////////////////////////////////////////////////////////// //
nothrow @trusted @nogc:

private void putPixelIntrNoCheck (in int xx, in int yy, in VColor col) {
  pragma(inline, true);
  uint* da = vbuf+yy*vbufW+xx;
  if (col&vlAMask) {
    immutable uint a = 256-(col>>24); // to not loose bits
    immutable uint dc = (*da)&0xffffff;
    immutable uint srb = (col&0xff00ff);
    immutable uint sg = (col&0x00ff00);
    immutable uint drb = (dc&0xff00ff);
    immutable uint dg = (dc&0x00ff00);
    immutable uint orb = (drb+(((srb-drb)*a+0x800080)>>8))&0xff00ff;
    immutable uint og = (dg+(((sg-dg)*a+0x008000)>>8))&0x00ff00;
    *da = orb|og;
  } else {
    *da = col;
  }
}

private void putPixelIntr (int xx, int yy, VColor col) {
  pragma(inline, true);
  if ((col&vlAMask) != vlAMask && xx >= 0 && yy >= 0 && xx < vbufW && yy < vbufH) {
    uint* da = vbuf+yy*vbufW+xx;
    if (col&vlAMask) {
      immutable uint a = 256-(col>>24); // to not loose bits
      immutable uint dc = (*da)&0xffffff;
      immutable uint srb = (col&0xff00ff);
      immutable uint sg = (col&0x00ff00);
      immutable uint drb = (dc&0xff00ff);
      immutable uint dg = (dc&0x00ff00);
      immutable uint orb = (drb+(((srb-drb)*a+0x800080)>>8))&0xff00ff;
      immutable uint og = (dg+(((sg-dg)*a+0x008000)>>8))&0x00ff00;
      *da = orb|og;
    } else {
      *da = col;
    }
  }
}

void putPixel (int xx, int yy, VColor col) {
  pragma(inline, true);
  if ((col&vlAMask) != vlAMask && xx >= 0 && yy >= 0 && xx < vbufW && yy < vbufH) {
    uint* da = vbuf+yy*vbufW+xx;
    if (col&vlAMask) {
      immutable uint a = 256-(col>>24); // to not loose bits
      immutable uint dc = (*da)&0xffffff;
      immutable uint srb = (col&0xff00ff);
      immutable uint sg = (col&0x00ff00);
      immutable uint drb = (dc&0xff00ff);
      immutable uint dg = (dc&0x00ff00);
      immutable uint orb = (drb+(((srb-drb)*a+0x800080)>>8))&0xff00ff;
      immutable uint og = (dg+(((sg-dg)*a+0x008000)>>8))&0x00ff00;
      *da = orb|og;
    } else {
      *da = col;
    }
    version(LDC) {} else atomicFence();
    ++vupcounter;
  }
}

private void setPixelIntr (int xx, int yy, VColor col) {
  pragma(inline, true);
  if (xx >= 0 && yy >= 0 && xx < vbufW && yy < vbufH) {
    uint* da = vbuf+yy*vbufW+xx;
    *da = col;
  }
}

void setPixel (int xx, int yy, VColor col) {
  pragma(inline, true);
  if (xx >= 0 && yy >= 0 && xx < vbufW && yy < vbufH) {
    uint* da = vbuf+yy*vbufW+xx;
    *da = col;
    version(LDC) {} else atomicFence();
    ++vupcounter;
  }
}


VColor getPixel (int xx, int yy) {
  pragma(inline, true);
  return (xx >= 0 && yy >= 0 && xx < vbufW && yy < vbufH ? vbuf[yy*vbufW+xx]&vlColorMask : Transparent);
}


// ////////////////////////////////////////////////////////////////////////// //
void cls (VColor col) {
  vbuf[0..vbufW*vbufH] = col;
  version(LDC) {} else atomicFence();
  ++vupcounter;
}


// ////////////////////////////////////////////////////////////////////////// //
void drawRect (int x, int y, int w, int h, immutable VColor col) {
  if (w < 1 || h < 1) return;
  if (x <= -w || y <= -h || x >= vbufW || y >= vbufH || isTransparent(col)) return;
  if (x < 0) { w += x; x = 0; }
  if (y < 0) { h += y; h = 0; }
  if (x+w >= vbufW) w = vbufW-x;
  if (y+h >= vbufH) h = vbufH-y;
  assert(x >= 0 && y >= 0 && x < vbufW && y < vbufH && w > 0 && h > 0 && x+w <= vbufW && y+h <= vbufH);
  if (isOpaque(col)) {
    uint d = y*vbufW+x;
    vbuf[d..d+w] = col;
    d += vbufW;
    foreach (immutable yy; y+1..y+h-1) {
      vbuf[d] = col;
      vbuf[d+w-1] = col;
      d += vbufW;
    }
    if (h > 1) vbuf[d..d+w] = col;
  } else {
    foreach (immutable yy; y..y+h) {
      putPixelIntr(x, yy, col);
      putPixelIntr(x+w-1, yy, col);
    }
    foreach (immutable xx; x+1..x+w-1) {
      putPixelIntr(xx, y, col);
      if (h > 1) putPixelIntr(xx, y+h-1, col);
    }
  }
  version(LDC) {} else atomicFence();
  ++vupcounter;
}

void fillRect (int x, int y, int w, int h, immutable VColor col) {
  if (w < 1 || h < 1) return;
  if (x <= -w || y <= -h || x >= vbufW || y >= vbufH || isTransparent(col)) return;
  if (x < 0) { w += x; x = 0; }
  if (y < 0) { h += y; h = 0; }
  if (x+w >= vbufW) w = vbufW-x;
  if (y+h >= vbufH) h = vbufH-y;
  assert(x >= 0 && y >= 0 && x < vbufW && y < vbufH && w > 0 && h > 0 && x+w <= vbufW && y+h <= vbufH);
  if (isOpaque(col)) {
    uint d = y*vbufW+x;
    foreach (immutable yy; y..y+h) {
      vbuf[d..d+w] = col;
      d += vbufW;
    }
  } else {
    foreach (immutable yy; y..y+h) {
      foreach (immutable xx; x..x+w) {
        putPixelIntr(xx, yy, col);
      }
    }
  }
  version(LDC) {} else atomicFence();
  ++vupcounter;
}

void hline (int x, int y, int len, immutable VColor col) { drawRect(x, y, len, 1, col); }
void vline (int x, int y, int len, immutable VColor col) { drawRect(x, y, 1, len, col); }


// ////////////////////////////////////////////////////////////////////////// //
void drawLine(bool lastPoint=true) (int x0, int y0, int x1, int y1, immutable VColor col) {
  enum swap(string a, string b) = "{int tmp_="~a~";"~a~"="~b~";"~b~"=tmp_;}";

  if ((col&vlAMask) == vlAMask) return;

  if (x0 == x1 && y0 == y1) {
    static if (lastPoint) putPixel(x0, y0, col);
    return;
  }

  // clip rectange
  int wx0 = 0, wy0 = 0, wx1 = vbufW-1, wy1 = vbufH-1;
  // other vars
  int stx, sty; // "steps" for x and y axes
  int dsx, dsy; // "lengthes" for x and y axes
  int dx2, dy2; // "double lengthes" for x and y axes
  int xd, yd; // current coord
  int e; // "error" (as in bresenham algo)
  int rem;
  int term;
  int *d0, d1;
  // horizontal setup
  if (x0 < x1) {
    // from left to right
    if (x0 > wx1 || x1 < wx0) return; // out of screen
    stx = 1; // going right
  } else {
    // from right to left
    if (x1 > wx1 || x0 < wx0) return; // out of screen
    stx = -1; // going left
    x0 = -x0;
    x1 = -x1;
    wx0 = -wx0;
    wx1 = -wx1;
    mixin(swap!("wx0", "wx1"));
  }
  // vertical setup
  if (y0 < y1) {
    // from top to bottom
    if (y0 > wy1 || y1 < wy0) return; // out of screen
    sty = 1; // going down
  } else {
    // from bottom to top
    if (y1 > wy1 || y0 < wy0) return; // out of screen
    sty = -1; // going up
    y0 = -y0;
    y1 = -y1;
    wy0 = -wy0;
    wy1 = -wy1;
    mixin(swap!("wy0", "wy1"));
  }
  dsx = x1-x0;
  dsy = y1-y0;
  if (dsx < dsy) {
    d0 = &yd;
    d1 = &xd;
    mixin(swap!("x0", "y0"));
    mixin(swap!("x1", "y1"));
    mixin(swap!("dsx", "dsy"));
    mixin(swap!("wx0", "wy0"));
    mixin(swap!("wx1", "wy1"));
    mixin(swap!("stx", "sty"));
  } else {
    d0 = &xd;
    d1 = &yd;
  }
  dx2 = 2*dsx;
  dy2 = 2*dsy;
  xd = x0;
  yd = y0;
  e = 2*dsy-dsx;
  term = x1;
  bool xfixed = false;
  if (y0 < wy0) {
    // clip at top
    int temp = dx2*(wy0-y0)-dsx;
    xd += temp/dy2;
    rem = temp%dy2;
    if (xd > wx1) return; // x is moved out of clipping rect, nothing to do
    if (xd+1 >= wx0) {
      yd = wy0;
      e -= rem+dsx;
      if (rem > 0) { ++xd; e += dy2; }
      xfixed = true;
    }
  }
  if (!xfixed && x0 < wx0) {
    // clip at left
    int temp = dy2*(wx0-x0);
    yd += temp/dx2;
    rem = temp%dx2;
    if (yd > wy1 || yd == wy1 && rem >= dsx) return;
    xd = wx0;
    e += rem;
    if (rem >= dsx) { ++yd; e -= dx2; }
  }
  if (y1 > wy1) {
    // clip at bottom
    int temp = dx2*(wy1-y0)+dsx;
    term = x0+temp/dy2;
    rem = temp%dy2;
    if (rem == 0) --term;
  }
  if (term > wx1) term = wx1; // clip at right
  static if (lastPoint) {
    // draw last point
    ++term;
  } else {
    if (term == xd) return; // this is the only point, get out of here
  }
  if (sty == -1) yd = -yd;
  if (stx == -1) { xd = -xd; term = -term; }
  dx2 -= dy2;
  // draw it; `putPixel()` can omit checks
  while (xd != term) {
    putPixelIntrNoCheck(*d0, *d1, col);
    // done drawing, move coords
    if (e >= 0) {
      yd += sty;
      e -= dx2;
    } else {
      e += dy2;
    }
    xd += stx;
  }
  version(LDC) {} else atomicFence();
  ++vupcounter;
}


// ////////////////////////////////////////////////////////////////////////// //
private void plot4points() (int cx, int cy, int x, int y, VColor clr) @trusted {
  putPixelIntr(cx+x, cy+y, clr);
  if (x != 0) putPixelIntr(cx-x, cy+y, clr);
  if (y != 0) putPixelIntr(cx+x, cy-y, clr);
  putPixelIntr(cx-x, cy-y, clr);
}


void drawCircle (int cx, int cy, int radius, VColor clr) @trusted {
  if (radius > 0 && !isTransparent(clr)) {
    int error = -radius, x = radius, y = 0;
    if (radius == 1) { putPixelIntr(cx, cy, clr); return; }
    while (x > y) {
      plot4points(cx, cy, x, y, clr);
      plot4points(cx, cy, y, x, clr);
      error += y*2+1;
      ++y;
      if (error >= 0) { --x; error -= x*2; }
    }
    plot4points(cx, cy, x, y, clr);
    version(LDC) {} else atomicFence();
    ++vupcounter;
  }
}

void fillCircle (int cx, int cy, int radius, VColor clr) @trusted {
  if (radius > 0 && !isTransparent(clr)) {
    int error = -radius, x = radius, y = 0;
    if (radius == 1) { putPixelIntr(cx, cy, clr); return; }
    while (x >= y) {
      int last_y = y;
      error += y;
      ++y;
      error += y;
      hline(cx-x, cy+last_y, 2*x+1, clr);
      if (x != 0 && last_y != 0) hline(cx-x, cy-last_y, 2*x+1, clr);
      if (error >= 0) {
        if (x != last_y) {
          hline(cx-last_y, cy+x, 2*last_y+1, clr);
          if (last_y != 0 && x != 0) hline(cx-last_y, cy-x, 2*last_y+1, clr);
        }
        error -= x;
        --x;
        error -= x;
      }
    }
    version(LDC) {} else atomicFence();
    ++vupcounter;
  }
}


void drawEllipse (int x0, int y0, int w, int h, VColor clr) @trusted {
  import std.math : abs;
  if (w == 0 && h == 0) return;
  if (w == 1) { vline(x0, y0, h, clr); return; }
  if (h == 1) { hline(x0, y0, w, clr); return; }
  int x1 = x0+w-1;
  int y1 = y0+h-1;
  int a = abs(x1-x0), b = abs(y1-y0), b1 = b&1; // values of diameter
  long dx = 4*(1-a)*b*b, dy = 4*(b1+1)*a*a; // error increment
  long err = dx+dy+b1*a*a; // error of 1.step
  if (x0 > x1) { x0 = x1; x1 += a; } // if called with swapped points...
  if (y0 > y1) y0 = y1; // ...exchange them
  y0 += (b+1)/2; y1 = y0-b1;  // starting pixel
  a *= 8*a; b1 = 8*b*b;
  do {
    long e2;
    putPixelIntr(x1, y0, clr); //   I. Quadrant
    putPixelIntr(x0, y0, clr); //  II. Quadrant
    putPixelIntr(x0, y1, clr); // III. Quadrant
    putPixelIntr(x1, y1, clr); //  IV. Quadrant
    e2 = 2*err;
    if (e2 >= dx) { ++x0; --x1; err += dx += b1; } // x step
    if (e2 <= dy) { ++y0; --y1; err += dy += a; }  // y step
  } while (x0 <= x1);
  while (y0-y1 < b) {
    // too early stop of flat ellipses a=1
    putPixelIntr(x0-1, ++y0, clr); // complete tip of ellipse
    putPixelIntr(x0-1, --y1, clr);
  }
  version(LDC) {} else atomicFence();
  ++vupcounter;
}

void fillEllipse (int x0, int y0, int w, int h, VColor clr) @trusted {
  import std.math : abs;
  if (w == 0 && h == 0) return;
  if (w == 1) { vline(x0, y0, h, clr); return; }
  if (h == 1) { hline(x0, y0, w, clr); return; }
  int x1 = x0+w-1;
  int y1 = y0+h-1;
  int a = abs(x1-x0), b = abs(y1-y0), b1 = b&1; // values of diameter
  long dx = 4*(1-a)*b*b, dy = 4*(b1+1)*a*a; // error increment
  long err = dx+dy+b1*a*a; // error of 1.step
  int prev_y0 = -1, prev_y1 = -1;
  if (x0 > x1) { x0 = x1; x1 += a; } // if called with swapped points...
  if (y0 > y1) y0 = y1; // ...exchange them
  y0 += (b+1)/2; y1 = y0-b1; // starting pixel
  a *= 8*a; b1 = 8*b*b;
  do {
    long e2;
    if (y0 != prev_y0) { hline(x0, y0, x1-x0+1, clr); prev_y0 = y0; }
    if (y1 != y0 && y1 != prev_y1) { hline(x0, y1, x1-x0+1, clr); prev_y1 = y1; }
    e2 = 2*err;
    if (e2 >= dx) { ++x0; --x1; err += dx += b1; } // x step
    if (e2 <= dy) { ++y0; --y1; err += dy += a; }  // y step
  } while (x0 <= x1);
  while (y0-y1 < b) {
    // too early stop of flat ellipses a=1
    putPixelIntr(x0-1, ++y0, clr); // complete tip of ellipse
    putPixelIntr(x0-1, --y1, clr);
  }
  version(LDC) {} else atomicFence();
  ++vupcounter;
}


// //////////////////////////////////////////////////////////////////////// //
int charWidth(string type="msx") () {
       static if (type == "msx") return 6;
  else static if (type == "dos") return 8;
  else static if (type == "d10") return 10;
  else static assert(0, "invalid font type");
}

int charHeight(string type="msx") () {
       static if (type == "msx") return 8;
  else static if (type == "dos") return 8;
  else static if (type == "d10") return 10;
  else static assert(0, "invalid font type");
}

void drawCharWdt(string type="msx") (int x, int y, int wdt, int shift, char ch, VColor fgcol, VColor bgcol=Transparent) @trusted {
       static if (type == "msx") { alias fontb8 = kgiFont6; enum fwdt = 8; enum fhgt = 8; enum fmask = 0x80; }
  else static if (type == "dos") { alias fontb8 = kgiFont8; enum fwdt = 8; enum fhgt = 8; enum fmask = 0x80; }
  else static if (type == "d10") { alias fontb8 = kgiFont10; enum fwdt = 10; enum fhgt = 10; enum fmask = 0x8000; }
  else static assert(0, "invalid font type");
  size_t pos = ch*fhgt;
  if (wdt < 1 || shift >= fwdt) return;
  if (fgcol == Transparent && bgcol == Transparent) return;
  if (wdt > fwdt) wdt = fwdt;
  if (shift < 0) shift = 0;
  foreach (immutable int dy; 0..fhgt) {
    ushort b = cast(ushort)(fontb8.ptr[pos++]<<shift);
    foreach (immutable int dx; 0..wdt) {
      VColor c = (b&fmask ? fgcol : bgcol);
      putPixelIntr(x+dx, y+dy, c);
      b <<= 1;
    }
  }
  version(LDC) {} else atomicFence();
  ++vupcounter;
}

// outline types
enum : ubyte {
  OutLeft   = 0x01,
  OutRight  = 0x02,
  OutUp     = 0x04,
  OutDown   = 0x08,
  OutLU     = 0x10, // left-up
  OutRU     = 0x20, // right-up
  OutLD     = 0x40, // left-down
  OutRD     = 0x80, // right-down
  OutAll    = 0xff,
}

void drawCharWdtOut(string type="msx") (int x, int y, int wdt, int shift, char ch, VColor fgcol, VColor outcol=Transparent, ubyte ot=0) @trusted {
       static if (type == "msx") { alias fontb8 = kgiFont6; enum fwdt = 8; enum fhgt = 8; enum fmask = 0x80; }
  else static if (type == "dos") { alias fontb8 = kgiFont8; enum fwdt = 8; enum fhgt = 8; enum fmask = 0x80; }
  else static if (type == "d10") { alias fontb8 = kgiFont10; enum fwdt = 10; enum fhgt = 10; enum fmask = 0x8000; }
  else static assert(0, "invalid font type");
  if (fgcol == Transparent && outcol == Transparent) return;
  if (ot == 0 || outcol == Transparent) {
    // no outline? simple draw
    drawCharWdt(x, y, wdt, shift, ch, fgcol, Transparent);
    return;
  }
  size_t pos = ch*fhgt;
  if (wdt < 1 || shift >= fwdt) return;
  if (wdt > 8) wdt = fwdt;
  if (shift < 0) shift = 0;
  ubyte[fhgt+2][fwdt+2] bmp = 0; // char bitmap; 0: empty; 1: char; 2: outline
  foreach (immutable dy; 1..fhgt+1) {
    ushort b = cast(ushort)(fontb8.ptr[pos++]<<shift);
    foreach (immutable dx; 1..wdt+1) {
      if (b&fmask) {
        // put pixel
        bmp[dy][dx] = 1;
        // put outlines
        if ((ot&OutUp) && bmp[dy-1][dx] == 0) bmp[dy-1][dx] = 2;
        if ((ot&OutDown) && bmp[dy+1][dx] == 0) bmp[dy+1][dx] = 2;
        if ((ot&OutLeft) && bmp[dy][dx-1] == 0) bmp[dy][dx-1] = 2;
        if ((ot&OutRight) && bmp[dy][dx+1] == 0) bmp[dy][dx+1] = 2;
        if ((ot&OutLU) && bmp[dy-1][dx-1] == 0) bmp[dy-1][dx-1] = 2;
        if ((ot&OutRU) && bmp[dy-1][dx+1] == 0) bmp[dy-1][dx+1] = 2;
        if ((ot&OutLD) && bmp[dy+1][dx-1] == 0) bmp[dy+1][dx-1] = 2;
        if ((ot&OutRD) && bmp[dy+1][dx+1] == 0) bmp[dy+1][dx+1] = 2;
      }
      b <<= 1;
    }
  }
  // now draw it
  --x;
  --y;
  foreach (immutable int dy; 0..fhgt+2) {
    foreach (immutable int dx; 0..fwdt+2) {
      if (auto t = bmp[dy][dx]) putPixelIntr(x+dx, y+dy, (t == 1 ? fgcol : outcol));
    }
  }
  version(LDC) {} else atomicFence();
  ++vupcounter;
}

void drawChar(string type="msx") (int x, int y, char ch, VColor fgcol, VColor bgcol=Transparent) @trusted {
  drawCharWdt!type(x, y, charWidth!type, 0, ch, fgcol, bgcol);
}

void drawCharOut(string type="msx") (int x, int y, char ch, VColor fgcol, VColor outcol=Transparent, ubyte ot=OutAll) @trusted {
  drawCharWdtOut!type(x, y, charWidth!type, 0, ch, fgcol, outcol, ot);
}

void drawStr(string type="msx") (int x, int y, const(char)[] str, VColor fgcol, VColor bgcol=Transparent) @trusted {
  foreach (immutable char ch; str) {
    drawChar!type(x, y, ch, fgcol, bgcol);
    x += charWidth!type;
  }
}

void drawStrOut(string type="msx") (int x, int y, const(char)[] str, VColor fgcol, VColor outcol=Transparent, ubyte ot=OutAll) @trusted {
  foreach (immutable char ch; str) {
    drawCharOut!type(x, y, ch, fgcol, outcol, ot);
    x += charWidth!type;
  }
}

int strWidth(string type="msx") (const(char)[] str) {
  return cast(int)str.length*charWidth!type;
}

int charWidthProp(string type="msx") (char ch) @trusted pure {
       static if (type == "msx") { alias fontw8 = kgiFont6PropWidth; }
  else static if (type == "dos") { alias fontw8 = kgiFont8PropWidth; }
  else static assert(0, "invalid font type");
  return (fontw8.ptr[ch]&0x0f);
}

int strWidthProp(string type="msx") (const(char)[] str) @trusted pure {
       static if (type == "msx") { alias fontw8 = kgiFont6PropWidth; }
  else static if (type == "dos") { alias fontw8 = kgiFont8PropWidth; }
  else static assert(0, "invalid font type");
  int wdt = 0;
  foreach (immutable char ch; str) wdt += (fontw8[ch]&0x0f)+1;
  if (wdt > 0) --wdt; // don't count last empty pixel
  return wdt;
}

int drawCharProp(string type="msx") (int x, int y, char ch, VColor fgcol, VColor bgcol=Transparent) @trusted {
       static if (type == "msx") { alias fontw8 = kgiFont6PropWidth; }
  else static if (type == "dos") { alias fontw8 = kgiFont8PropWidth; }
  else static assert(0, "invalid font type");
  immutable int wdt = (fontw8[ch]&0x0f);
  drawCharWdt!type(x, y, wdt, fontw8[ch]>>4, ch, fgcol, bgcol);
  return wdt;
}

int drawCharPropOut(string type="msx") (int x, int y, char ch, VColor fgcol, VColor outcol=Transparent, ubyte ot=OutAll) @trusted {
       static if (type == "msx") { alias fontw8 = kgiFont6PropWidth; }
  else static if (type == "dos") { alias fontw8 = kgiFont8PropWidth; }
  else static assert(0, "invalid font type");
  immutable int wdt = (fontw8[ch]&0x0f);
  drawCharWdtOut!type(x, y, wdt, fontw8[ch]>>4, ch, fgcol, outcol, ot);
  return wdt;
}

int drawStrProp(string type="msx") (int x, int y, const(char)[] str, VColor fgcol, VColor bgcol=Transparent) @trusted {
  bool vline = false;
  int sx = x;
  foreach (immutable char ch; str) {
    if (vline) {
      if (!isTransparent(bgcol)) {
        foreach (int dy; 0..8) putPixelIntr(x, y+dy, bgcol);
        // no need to advance vupcounter, 'cause `drawCharProp` will do it
        //version(LDC) {} else atomicFence();
        //++vupcounter;
      }
      ++x;
    }
    vline = true;
    x += drawCharProp!type(x, y, ch, fgcol, bgcol);
  }
  return x-sx;
}

int drawStrPropOut(string type="msx") (int x, int y, const(char)[] str, VColor fgcol, VColor outcol=Transparent, ubyte ot=OutAll) @trusted {
  int sx = x;
  foreach (immutable char ch; str) {
    x += drawCharPropOut!type(x, y, ch, fgcol, outcol, ot)+1;
  }
  if (x > sx) --x; // don't count last empty pixel
  return x-sx;
}


// ////////////////////////////////////////////////////////////////////////// //
/** floodfill area; based on Tarry's maze algorithm.
 *
 * fill area with color/pattern. trades memory for speed: doesn't recurse, doesn't allocate.
 * will use "transparency" byte as temporary, and will leave it dirty.
 *
 * NOTES:
 *   neither `isBorder` nor `patColor` will be called with out-of-range coordinates.
 */
void floodFillEx (int x, int y, scope bool delegate (int x, int y) nothrow @nogc isBorder, scope VColor delegate (int x, int y) nothrow @nogc patColor) nothrow @trusted @nogc {
  enum : ubyte {
    DirMask = 0x03,
    Seed = 0x10,
    Scanned = 0x80,
  }

  static ubyte getmark (int x, int y) nothrow @trusted @nogc {
    pragma(inline, true);
    return cast(ubyte)(x >= 0 && y >= 0 && x < vbufW && y < vbufH ? vbuf[y*vbufW+x]>>vlAShift : Scanned);
  }

  static void setmark (int x, int y, ubyte mark) nothrow @trusted @nogc {
    pragma(inline, true);
    if (x >= 0 && y >= 0 && x < vbufW && y < vbufH) vbuf[y*vbufW+x] = (vbuf[y*vbufW+x]&vlColorMask)|(mark<<vlAShift);
  }

  if (x < 0 || y < 0 || x >= vbufW || y >= vbufH) return; // nothing to do
  if (isBorder(x, y)) return; // nothing to do

  //setPixel(x, y, getPixel(x, y)); // set update flag

  // one can mark bounding rectangle with Scanned
  // reset flags
  auto p = vbuf;
  foreach (immutable dy; 0..vbufH) {
    foreach (immutable dx; 0..vbufW) {
      *p &= vlColorMask; // "not visited" mark
      ++p;
    }
  }

  //setmark(x, y, Scanned|Fill|Seed);
  VColor pc = patColor(x, y);
  if (isOpaque(pc)) {
    vbuf[y*vbufW+x] = (pc&vlColorMask)|((Scanned|Seed)<<vlAShift);
  } else {
    // do alpha
    putPixelIntrNoCheck(x, y, pc);
    setmark(x, y, Scanned|Seed);
  }

  ubyte dir = 0; // direction: right, left, up, down
  for (;;) {
    x += (dir == 0 ? 1 : dir == 1 ? -1 : 0);
    y += (dir == 3 ? 1 : dir == 2 ? -1 : 0);
    auto mk = getmark(x, y);
    if (mk == 0) {
      // not yet visited, check for border
      if (isBorder(x, y)) {
        mk = Scanned;
        setmark(x, y, Scanned);
      }
    }
    if ((mk&Scanned) == 0) {
      // not scanned
      //setmark(x, y, Scanned|Fill|dir);
      pc = patColor(x, y);
      if (isOpaque(pc)) {
        vbuf[y*vbufW+x] = (pc&vlColorMask)|((Scanned|dir)<<vlAShift);
      } else {
        // do alpha
        putPixelIntrNoCheck(x, y, pc);
        setmark(x, y, Scanned|dir);
      }
      if (dir != 1) dir = 0; // make exit direction
    } else {
      // already scanned
      for (;;) {
        x -= (dir == 0 ? 1 : dir == 1 ? -1 : 0);
        y -= (dir == 3 ? 1 : dir == 2 ? -1 : 0);
        mk = getmark(x, y);
        if (mk&Seed) {
          // done, fill pixels (you can set Fill flag and check all pixels here)
          if ((mk&DirMask) == 3) {
            // set update flag
            version(LDC) {} else atomicFence();
            ++vupcounter;
            return;
          }
          // remember new dir
          ++mk;
          setmark(x, y, mk);
          dir = mk&DirMask;
          break; // next pixel
        }
        ++dir;
        if ((mk&DirMask) == (dir^1)) ++dir; // skip entry-direction
        if (dir <= 3) break; // next pixel
        dir = mk&DirMask;
      }
    }
  }
}


// ////////////////////////////////////////////////////////////////////////// //
// fonts
static public immutable ubyte[256*8] kgiFont6 = [
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3c,0x42,0xa5,0x81,0xa5,0x99,0x42,0x3c,0x3c,0x7e,0xdb,0xff,0xff,0xdb,0x66,0x3c,0x6c,0xfe,
0xfe,0xfe,0x7c,0x38,0x10,0x00,0x10,0x38,0x7c,0xfe,0x7c,0x38,0x10,0x00,0x10,0x38,0x54,0xfe,0x54,0x10,0x38,0x00,0x10,0x38,0x7c,0xfe,
0xfe,0x10,0x38,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0xff,0xff,0xff,0xe7,0xe7,0xff,0xff,0xff,0x38,0x44,0x82,0x82,0x82,0x44,
0x38,0x00,0xc7,0xbb,0x7d,0x7d,0x7d,0xbb,0xc7,0xff,0x0f,0x03,0x05,0x79,0x88,0x88,0x88,0x70,0x38,0x44,0x44,0x44,0x38,0x10,0x7c,0x10,
0x30,0x28,0x24,0x24,0x28,0x20,0xe0,0xc0,0x3c,0x24,0x3c,0x24,0x24,0xe4,0xdc,0x18,0x10,0x54,0x38,0xee,0x38,0x54,0x10,0x00,0x10,0x10,
0x10,0x7c,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0xf0,
0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x1f,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0xff,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
0x10,0x10,0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x10,0x10,0x10,0x10,0x00,0x00,0x00,0xf0,0x10,0x10,0x10,0x10,
0x10,0x10,0x10,0x1f,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0xf0,0x00,0x00,0x00,0x00,0x81,0x42,0x24,0x18,0x18,0x24,0x42,0x81,0x01,0x02,
0x04,0x08,0x10,0x20,0x40,0x80,0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,0x00,0x10,0x10,0xff,0x10,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x20,0x20,0x20,0x20,0x00,0x00,0x20,0x00,0x50,0x50,0x50,0x00,0x00,0x00,0x00,0x00,0x50,0x50,0xf8,0x50,0xf8,0x50,
0x50,0x00,0x20,0x78,0xa0,0x70,0x28,0xf0,0x20,0x00,0xc0,0xc8,0x10,0x20,0x40,0x98,0x18,0x00,0x40,0xa0,0x40,0xa8,0x90,0x98,0x60,0x00,
0x10,0x20,0x40,0x00,0x00,0x00,0x00,0x00,0x10,0x20,0x40,0x40,0x40,0x20,0x10,0x00,0x40,0x20,0x10,0x10,0x10,0x20,0x40,0x00,0x88,0x50,
0x20,0xf8,0x20,0x50,0x88,0x00,0x00,0x20,0x20,0xf8,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x40,0x00,0x00,0x00,0x78,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x60,0x00,0x00,0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x70,0x88,0x98,0xa8,0xc8,0x88,
0x70,0x00,0x20,0x60,0xa0,0x20,0x20,0x20,0xf8,0x00,0x70,0x88,0x08,0x10,0x60,0x80,0xf8,0x00,0x70,0x88,0x08,0x30,0x08,0x88,0x70,0x00,
0x10,0x30,0x50,0x90,0xf8,0x10,0x10,0x00,0xf8,0x80,0xe0,0x10,0x08,0x10,0xe0,0x00,0x30,0x40,0x80,0xf0,0x88,0x88,0x70,0x00,0xf8,0x88,
0x10,0x20,0x20,0x20,0x20,0x00,0x70,0x88,0x88,0x70,0x88,0x88,0x70,0x00,0x70,0x88,0x88,0x78,0x08,0x10,0x60,0x00,0x00,0x00,0x20,0x00,
0x00,0x20,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x20,0x40,0x18,0x30,0x60,0xc0,0x60,0x30,0x18,0x00,0x00,0x00,0xf8,0x00,0xf8,0x00,
0x00,0x00,0xc0,0x60,0x30,0x18,0x30,0x60,0xc0,0x00,0x70,0x88,0x08,0x10,0x20,0x00,0x20,0x00,0x70,0x88,0x08,0x68,0xa8,0xa8,0x70,0x00,
0x20,0x50,0x88,0x88,0xf8,0x88,0x88,0x00,0xf0,0x48,0x48,0x70,0x48,0x48,0xf0,0x00,0x30,0x48,0x80,0x80,0x80,0x48,0x30,0x00,0xe0,0x50,
0x48,0x48,0x48,0x50,0xe0,0x00,0xf8,0x80,0x80,0xf0,0x80,0x80,0xf8,0x00,0xf8,0x80,0x80,0xf0,0x80,0x80,0x80,0x00,0x70,0x88,0x80,0xb8,
0x88,0x88,0x70,0x00,0x88,0x88,0x88,0xf8,0x88,0x88,0x88,0x00,0x70,0x20,0x20,0x20,0x20,0x20,0x70,0x00,0x38,0x10,0x10,0x10,0x90,0x90,
0x60,0x00,0x88,0x90,0xa0,0xc0,0xa0,0x90,0x88,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0xf8,0x00,0x88,0xd8,0xa8,0xa8,0x88,0x88,0x88,0x00,
0x88,0xc8,0xc8,0xa8,0x98,0x98,0x88,0x00,0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x00,0xf0,0x88,0x88,0xf0,0x80,0x80,0x80,0x00,0x70,0x88,
0x88,0x88,0xa8,0x90,0x68,0x00,0xf0,0x88,0x88,0xf0,0xa0,0x90,0x88,0x00,0x70,0x88,0x80,0x70,0x08,0x88,0x70,0x00,0xf8,0x20,0x20,0x20,
0x20,0x20,0x20,0x00,0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00,0x88,0x88,0x88,0x88,0x50,0x50,0x20,0x00,0x88,0x88,0x88,0xa8,0xa8,0xd8,
0x88,0x00,0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x00,0x88,0x88,0x88,0x70,0x20,0x20,0x20,0x00,0xf8,0x08,0x10,0x20,0x40,0x80,0xf8,0x00,
0x70,0x40,0x40,0x40,0x40,0x40,0x70,0x00,0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x70,0x10,0x10,0x10,0x10,0x10,0x70,0x00,0x20,0x50,
0x88,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0x00,0x40,0x20,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x08,
0x78,0x88,0x78,0x00,0x80,0x80,0xb0,0xc8,0x88,0xc8,0xb0,0x00,0x00,0x00,0x70,0x88,0x80,0x88,0x70,0x00,0x08,0x08,0x68,0x98,0x88,0x98,
0x68,0x00,0x00,0x00,0x70,0x88,0xf8,0x80,0x70,0x00,0x10,0x28,0x20,0xf8,0x20,0x20,0x20,0x00,0x00,0x00,0x68,0x98,0x98,0x68,0x08,0x70,
0x80,0x80,0xf0,0x88,0x88,0x88,0x88,0x00,0x20,0x00,0x60,0x20,0x20,0x20,0x70,0x00,0x10,0x00,0x30,0x10,0x10,0x10,0x90,0x60,0x40,0x40,
0x48,0x50,0x60,0x50,0x48,0x00,0x60,0x20,0x20,0x20,0x20,0x20,0x70,0x00,0x00,0x00,0xd0,0xa8,0xa8,0xa8,0xa8,0x00,0x00,0x00,0xb0,0xc8,
0x88,0x88,0x88,0x00,0x00,0x00,0x70,0x88,0x88,0x88,0x70,0x00,0x00,0x00,0xb0,0xc8,0xc8,0xb0,0x80,0x80,0x00,0x00,0x68,0x98,0x98,0x68,
0x08,0x08,0x00,0x00,0xb0,0xc8,0x80,0x80,0x80,0x00,0x00,0x00,0x78,0x80,0xf0,0x08,0xf0,0x00,0x40,0x40,0xf0,0x40,0x40,0x48,0x30,0x00,
0x00,0x00,0x90,0x90,0x90,0x90,0x68,0x00,0x00,0x00,0x88,0x88,0x88,0x50,0x20,0x00,0x00,0x00,0x88,0xa8,0xa8,0xa8,0x50,0x00,0x00,0x00,
0x88,0x50,0x20,0x50,0x88,0x00,0x00,0x00,0x88,0x88,0x98,0x68,0x08,0x70,0x00,0x00,0xf8,0x10,0x20,0x40,0xf8,0x00,0x18,0x20,0x20,0x40,
0x20,0x20,0x18,0x00,0x20,0x20,0x20,0x00,0x20,0x20,0x20,0x00,0xc0,0x20,0x20,0x10,0x20,0x20,0xc0,0x00,0x40,0xa8,0x10,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x20,0x50,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xf0,0xf0,0xf0,0xf0,0x0f,0x0f,0x0f,0x0f,
0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3c,0x3c,0x00,0x00,0x00,0xff,0xff,
0xff,0xff,0xff,0xff,0x00,0x00,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0x0f,0x0f,0x0f,0x0f,0xf0,0xf0,0xf0,0xf0,0xfc,0xfc,0xfc,0xfc,
0xfc,0xfc,0xfc,0xfc,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x11,0x22,0x44,0x88,0x11,0x22,
0x44,0x88,0x88,0x44,0x22,0x11,0x88,0x44,0x22,0x11,0xfe,0x7c,0x38,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x38,0x7c,0xfe,
0x80,0xc0,0xe0,0xf0,0xe0,0xc0,0x80,0x00,0x01,0x03,0x07,0x0f,0x07,0x03,0x01,0x00,0xff,0x7e,0x3c,0x18,0x18,0x3c,0x7e,0xff,0x81,0xc3,
0xe7,0xff,0xff,0xe7,0xc3,0x81,0xf0,0xf0,0xf0,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0xf0,0xf0,0xf0,0x33,0x33,0xcc,0xcc,0x33,0x33,0xcc,0xcc,0x00,0x20,0x20,0x50,0x50,0x88,
0xf8,0x00,0x20,0x20,0x70,0x20,0x70,0x20,0x20,0x00,0x00,0x00,0x00,0x50,0x88,0xa8,0x50,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0xff,0xff,
0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x68,0x90,0x90,0x90,0x68,0x00,0x30,0x48,0x48,0x70,0x48,0x48,0x70,0xc0,0xf8,0x88,0x80,0x80,
0x80,0x80,0x80,0x00,0x00,0x50,0x70,0x88,0xf8,0x80,0x70,0x00,0x00,0x00,0x78,0x80,0xf0,0x80,0x78,0x00,0x00,0x00,0x78,0x90,0x90,0x90,
0x60,0x00,0x20,0x00,0x60,0x20,0x20,0x20,0x70,0x00,0x50,0x00,0x70,0x20,0x20,0x20,0x70,0x00,0xf8,0x20,0x70,0xa8,0xa8,0x70,0x20,0xf8,
0x20,0x50,0x88,0xf8,0x88,0x50,0x20,0x00,0x70,0x88,0x88,0x88,0x50,0x50,0xd8,0x00,0x30,0x40,0x40,0x20,0x50,0x50,0x50,0x20,0x00,0x00,
0x00,0x50,0xa8,0xa8,0x50,0x00,0x08,0x70,0xa8,0xa8,0xa8,0x70,0x80,0x00,0x38,0x40,0x80,0xf8,0x80,0x40,0x38,0x00,0x70,0x88,0x88,0x88,
0x88,0x88,0x88,0x00,0x00,0xf8,0x00,0xf8,0x00,0xf8,0x00,0x00,0x20,0x20,0xf8,0x20,0x20,0x00,0xf8,0x00,0xc0,0x30,0x08,0x30,0xc0,0x00,
0xf8,0x00,0x50,0xf8,0x80,0xf0,0x80,0x80,0xf8,0x00,0x78,0x80,0x80,0xf0,0x80,0x80,0x78,0x00,0x20,0x20,0x20,0x20,0x20,0x20,0xa0,0x40,
0x70,0x20,0x20,0x20,0x20,0x20,0x70,0x00,0x50,0x70,0x20,0x20,0x20,0x20,0x70,0x00,0x00,0x18,0x24,0x24,0x18,0x00,0x00,0x00,0x00,0x30,
0x78,0x78,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x3e,0x20,0x20,0x20,0xa0,0x60,0x20,0x00,0xa0,0x50,0x50,0x50,
0x00,0x00,0x00,0x00,0x40,0xa0,0x20,0x40,0xe0,0x00,0x00,0x00,0x00,0x38,0x38,0x38,0x38,0x38,0x38,0x00,0x3c,0x42,0x99,0xa1,0xa1,0x99,
0x42,0x3c,0x00,0x00,0x90,0xa8,0xe8,0xa8,0x90,0x00,0x00,0x00,0x60,0x10,0x70,0x90,0x68,0x00,0x00,0x00,0xf0,0x80,0xf0,0x88,0xf0,0x00,
0x00,0x00,0x90,0x90,0x90,0xf8,0x08,0x00,0x00,0x00,0x30,0x50,0x50,0x70,0x88,0x00,0x00,0x00,0x70,0x88,0xf8,0x80,0x70,0x00,0x00,0x20,
0x70,0xa8,0xa8,0x70,0x20,0x00,0x00,0x00,0x78,0x48,0x40,0x40,0x40,0x00,0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x00,0x00,0x00,0x88,0x98,
0xa8,0xc8,0x88,0x00,0x00,0x50,0x20,0x00,0x98,0xa8,0xc8,0x00,0x00,0x00,0x90,0xa0,0xc0,0xa0,0x90,0x00,0x00,0x00,0x38,0x28,0x28,0x48,
0x88,0x00,0x00,0x00,0x88,0xd8,0xa8,0x88,0x88,0x00,0x00,0x00,0x88,0x88,0xf8,0x88,0x88,0x00,0x00,0x00,0x70,0x88,0x88,0x88,0x70,0x00,
0x00,0x00,0x78,0x48,0x48,0x48,0x48,0x00,0x00,0x00,0x78,0x88,0x78,0x28,0x48,0x00,0x00,0x00,0xf0,0x88,0xf0,0x80,0x80,0x00,0x00,0x00,
0x78,0x80,0x80,0x80,0x78,0x00,0x00,0x00,0xf8,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0x88,0x50,0x20,0x40,0x80,0x00,0x00,0x00,0xa8,0x70,
0x20,0x70,0xa8,0x00,0x00,0x00,0xf0,0x48,0x70,0x48,0xf0,0x00,0x00,0x00,0x40,0x40,0x70,0x48,0x70,0x00,0x00,0x00,0x88,0x88,0xc8,0xa8,
0xc8,0x00,0x00,0x00,0xf0,0x08,0x70,0x08,0xf0,0x00,0x00,0x00,0xa8,0xa8,0xa8,0xa8,0xf8,0x00,0x00,0x00,0x70,0x88,0x38,0x88,0x70,0x00,
0x00,0x00,0xa8,0xa8,0xa8,0xf8,0x08,0x00,0x00,0x00,0x48,0x48,0x78,0x08,0x08,0x00,0x00,0x00,0xc0,0x40,0x70,0x48,0x70,0x00,0x90,0xa8,
0xa8,0xe8,0xa8,0xa8,0x90,0x00,0x20,0x50,0x88,0x88,0xf8,0x88,0x88,0x00,0xf8,0x88,0x80,0xf0,0x88,0x88,0xf0,0x00,0x90,0x90,0x90,0x90,
0x90,0xf8,0x08,0x00,0x38,0x28,0x28,0x48,0x48,0xf8,0x88,0x00,0xf8,0x80,0x80,0xf0,0x80,0x80,0xf8,0x00,0x20,0x70,0xa8,0xa8,0xa8,0x70,
0x20,0x00,0xf8,0x88,0x88,0x80,0x80,0x80,0x80,0x00,0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x00,0x88,0x88,0x98,0xa8,0xc8,0x88,0x88,0x00,
0x50,0x20,0x88,0x98,0xa8,0xc8,0x88,0x00,0x88,0x90,0xa0,0xc0,0xa0,0x90,0x88,0x00,0x18,0x28,0x48,0x48,0x48,0x48,0x88,0x00,0x88,0xd8,
0xa8,0xa8,0x88,0x88,0x88,0x00,0x88,0x88,0x88,0xf8,0x88,0x88,0x88,0x00,0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x00,0xf8,0x88,0x88,0x88,
0x88,0x88,0x88,0x00,0x78,0x88,0x88,0x78,0x28,0x48,0x88,0x00,0xf0,0x88,0x88,0xf0,0x80,0x80,0x80,0x00,0x70,0x88,0x80,0x80,0x80,0x88,
0x70,0x00,0xf8,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x88,0x88,0x88,0x50,0x20,0x40,0x80,0x00,0xa8,0xa8,0x70,0x20,0x70,0xa8,0xa8,0x00,
0xf0,0x48,0x48,0x70,0x48,0x48,0xf0,0x00,0x80,0x80,0x80,0xf0,0x88,0x88,0xf0,0x00,0x88,0x88,0x88,0xc8,0xa8,0xa8,0xc8,0x00,0xf0,0x08,
0x08,0x30,0x08,0x08,0xf0,0x00,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xf8,0x00,0x70,0x88,0x08,0x78,0x08,0x88,0x70,0x00,0xa8,0xa8,0xa8,0xa8,
0xa8,0xf8,0x08,0x00,0x88,0x88,0x88,0x88,0x78,0x08,0x08,0x00,0xc0,0x40,0x40,0x70,0x48,0x48,0x70,0x00,
];

static public immutable ubyte[256*8] kgiFont8 = [
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7e,0x81,0xa5,0x81,0xbd,0x99,0x81,0x7e,0x7e,0xff,0xdb,0xff,0xc3,0xe7,0xff,0x7e,0x6c,0xfe,
0xfe,0xfe,0x7c,0x38,0x10,0x00,0x10,0x38,0x7c,0xfe,0x7c,0x38,0x10,0x00,0x38,0x7c,0x38,0xfe,0xfe,0xd6,0x10,0x38,0x10,0x10,0x38,0x7c,
0xfe,0x7c,0x10,0x38,0x00,0x00,0x18,0x3c,0x3c,0x18,0x00,0x00,0xff,0xff,0xe7,0xc3,0xc3,0xe7,0xff,0xff,0x00,0x3c,0x66,0x42,0x42,0x66,
0x3c,0x00,0xff,0xc3,0x99,0xbd,0xbd,0x99,0xc3,0xff,0x0f,0x07,0x0f,0x7d,0xcc,0xcc,0xcc,0x78,0x3c,0x66,0x66,0x66,0x3c,0x18,0x7e,0x18,
0x3f,0x33,0x3f,0x30,0x30,0x70,0xf0,0xe0,0x7f,0x63,0x7f,0x63,0x63,0x67,0xe6,0xc0,0x99,0x5a,0x3c,0xe7,0xe7,0x3c,0x5a,0x99,0x80,0xe0,
0xf8,0xfe,0xf8,0xe0,0x80,0x00,0x02,0x0e,0x3e,0xfe,0x3e,0x0e,0x02,0x00,0x18,0x3c,0x7e,0x18,0x18,0x7e,0x3c,0x18,0x66,0x66,0x66,0x66,
0x66,0x00,0x66,0x00,0x7f,0xdb,0xdb,0x7b,0x1b,0x1b,0x1b,0x00,0x7e,0xc3,0x78,0xcc,0xcc,0x78,0x8c,0xf8,0x00,0x00,0x00,0x00,0x7e,0x7e,
0x7e,0x00,0x18,0x3c,0x7e,0x18,0x7e,0x3c,0x18,0xff,0x18,0x3c,0x7e,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x7e,0x3c,0x18,0x00,
0x00,0x18,0x0c,0xfe,0x0c,0x18,0x00,0x00,0x00,0x30,0x60,0xfe,0x60,0x30,0x00,0x00,0x00,0x00,0xc0,0xc0,0xc0,0xfe,0x00,0x00,0x00,0x24,
0x66,0xff,0x66,0x24,0x00,0x00,0x00,0x18,0x3c,0x7e,0xff,0xff,0x00,0x00,0x00,0xff,0xff,0x7e,0x3c,0x18,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x30,0x78,0x78,0x30,0x30,0x00,0x30,0x00,0x6c,0x6c,0x6c,0x00,0x00,0x00,0x00,0x00,0x6c,0x6c,0xfe,0x6c,0xfe,0x6c,
0x6c,0x00,0x30,0x7c,0xc0,0x78,0x0c,0xf8,0x30,0x00,0x00,0xc6,0xcc,0x18,0x30,0x66,0xc6,0x00,0x38,0x6c,0x38,0x76,0xdc,0xcc,0x76,0x00,
0x60,0x60,0xc0,0x00,0x00,0x00,0x00,0x00,0x18,0x30,0x60,0x60,0x60,0x30,0x18,0x00,0x60,0x30,0x18,0x18,0x18,0x30,0x60,0x00,0x00,0x66,
0x3c,0xff,0x3c,0x66,0x00,0x00,0x00,0x30,0x30,0xfc,0x30,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x30,0x60,0x00,0x00,0x00,0xfc,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x06,0x0c,0x18,0x30,0x60,0xc0,0x80,0x00,0x78,0xcc,0xdc,0xfc,0xec,0xcc,
0x78,0x00,0x30,0xf0,0x30,0x30,0x30,0x30,0xfc,0x00,0x78,0xcc,0x0c,0x38,0x60,0xcc,0xfc,0x00,0x78,0xcc,0x0c,0x38,0x0c,0xcc,0x78,0x00,
0x1c,0x3c,0x6c,0xcc,0xfe,0x0c,0x0c,0x00,0xfc,0xc0,0xf8,0x0c,0x0c,0xcc,0x78,0x00,0x38,0x60,0xc0,0xf8,0xcc,0xcc,0x78,0x00,0xfc,0xcc,
0x0c,0x18,0x30,0x60,0x60,0x00,0x78,0xcc,0xcc,0x78,0xcc,0xcc,0x78,0x00,0x78,0xcc,0xcc,0x7c,0x0c,0x18,0x70,0x00,0x00,0x00,0x30,0x30,
0x00,0x30,0x30,0x00,0x00,0x00,0x30,0x30,0x00,0x70,0x30,0x60,0x18,0x30,0x60,0xc0,0x60,0x30,0x18,0x00,0x00,0x00,0xfc,0x00,0xfc,0x00,
0x00,0x00,0x60,0x30,0x18,0x0c,0x18,0x30,0x60,0x00,0x78,0xcc,0x0c,0x18,0x30,0x00,0x30,0x00,0x7c,0xc6,0xde,0xde,0xde,0xc0,0x78,0x00,
0x30,0x78,0xcc,0xcc,0xfc,0xcc,0xcc,0x00,0xfc,0x66,0x66,0x7c,0x66,0x66,0xfc,0x00,0x3c,0x66,0xc0,0xc0,0xc0,0x66,0x3c,0x00,0xfc,0x6c,
0x66,0x66,0x66,0x6c,0xfc,0x00,0xfe,0x62,0x68,0x78,0x68,0x62,0xfe,0x00,0xfe,0x62,0x68,0x78,0x68,0x60,0xf0,0x00,0x3c,0x66,0xc0,0xc0,
0xce,0x66,0x3e,0x00,0xcc,0xcc,0xcc,0xfc,0xcc,0xcc,0xcc,0x00,0x78,0x30,0x30,0x30,0x30,0x30,0x78,0x00,0x1e,0x0c,0x0c,0x0c,0xcc,0xcc,
0x78,0x00,0xe6,0x66,0x6c,0x78,0x6c,0x66,0xe6,0x00,0xf0,0x60,0x60,0x60,0x62,0x66,0xfe,0x00,0xc6,0xee,0xfe,0xd6,0xc6,0xc6,0xc6,0x00,
0xc6,0xe6,0xf6,0xde,0xce,0xc6,0xc6,0x00,0x38,0x6c,0xc6,0xc6,0xc6,0x6c,0x38,0x00,0xfc,0x66,0x66,0x7c,0x60,0x60,0xf0,0x00,0x78,0xcc,
0xcc,0xcc,0xdc,0x78,0x1c,0x00,0xfc,0x66,0x66,0x7c,0x78,0x6c,0xe6,0x00,0x78,0xcc,0xe0,0x38,0x1c,0xcc,0x78,0x00,0xfc,0xb4,0x30,0x30,
0x30,0x30,0x78,0x00,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xfc,0x00,0xcc,0xcc,0xcc,0xcc,0xcc,0x78,0x30,0x00,0xc6,0xc6,0xc6,0xd6,0xfe,0xee,
0xc6,0x00,0xc6,0xc6,0x6c,0x38,0x6c,0xc6,0xc6,0x00,0xcc,0xcc,0xcc,0x78,0x30,0x30,0x78,0x00,0xfe,0xcc,0x98,0x30,0x62,0xc6,0xfe,0x00,
0x78,0x60,0x60,0x60,0x60,0x60,0x78,0x00,0xc0,0x60,0x30,0x18,0x0c,0x06,0x02,0x00,0x78,0x18,0x18,0x18,0x18,0x18,0x78,0x00,0x10,0x38,
0x6c,0xc6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x0c,
0x7c,0xcc,0x76,0x00,0xe0,0x60,0x7c,0x66,0x66,0x66,0xbc,0x00,0x00,0x00,0x78,0xcc,0xc0,0xcc,0x78,0x00,0x1c,0x0c,0x0c,0x7c,0xcc,0xcc,
0x76,0x00,0x00,0x00,0x78,0xcc,0xfc,0xc0,0x78,0x00,0x38,0x6c,0x60,0xf0,0x60,0x60,0xf0,0x00,0x00,0x00,0x76,0xcc,0xcc,0x7c,0x0c,0xf8,
0xe0,0x60,0x6c,0x76,0x66,0x66,0xe6,0x00,0x30,0x00,0x70,0x30,0x30,0x30,0x78,0x00,0x18,0x00,0x78,0x18,0x18,0x18,0xd8,0x70,0xe0,0x60,
0x66,0x6c,0x78,0x6c,0xe6,0x00,0x70,0x30,0x30,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0xec,0xfe,0xd6,0xc6,0xc6,0x00,0x00,0x00,0xf8,0xcc,
0xcc,0xcc,0xcc,0x00,0x00,0x00,0x78,0xcc,0xcc,0xcc,0x78,0x00,0x00,0x00,0xdc,0x66,0x66,0x7c,0x60,0xf0,0x00,0x00,0x76,0xcc,0xcc,0x7c,
0x0c,0x1e,0x00,0x00,0xd8,0x6c,0x6c,0x60,0xf0,0x00,0x00,0x00,0x7c,0xc0,0x78,0x0c,0xf8,0x00,0x10,0x30,0x7c,0x30,0x30,0x34,0x18,0x00,
0x00,0x00,0xcc,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0xcc,0xcc,0xcc,0x78,0x30,0x00,0x00,0x00,0xc6,0xc6,0xd6,0xfe,0x6c,0x00,0x00,0x00,
0xc6,0x6c,0x38,0x6c,0xc6,0x00,0x00,0x00,0xcc,0xcc,0xcc,0x7c,0x0c,0xf8,0x00,0x00,0xfc,0x98,0x30,0x64,0xfc,0x00,0x1c,0x30,0x30,0xe0,
0x30,0x30,0x1c,0x00,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00,0xe0,0x30,0x30,0x1c,0x30,0x30,0xe0,0x00,0x76,0xdc,0x00,0x00,0x00,0x00,
0x00,0x00,0x10,0x38,0x6c,0xc6,0xc6,0xc6,0xfe,0x00,0x78,0xcc,0xc0,0xcc,0x78,0x18,0x0c,0x78,0x00,0xcc,0x00,0xcc,0xcc,0xcc,0x7e,0x00,
0x1c,0x00,0x78,0xcc,0xfc,0xc0,0x78,0x00,0x7e,0xc3,0x3c,0x06,0x3e,0x66,0x3f,0x00,0xcc,0x00,0x78,0x0c,0x7c,0xcc,0x7e,0x00,0xe0,0x00,
0x78,0x0c,0x7c,0xcc,0x7e,0x00,0x30,0x30,0x78,0x0c,0x7c,0xcc,0x7e,0x00,0x00,0x00,0x7c,0xc0,0xc0,0x7c,0x06,0x3c,0x7e,0xc3,0x3c,0x66,
0x7e,0x60,0x3c,0x00,0xcc,0x00,0x78,0xcc,0xfc,0xc0,0x78,0x00,0xe0,0x00,0x78,0xcc,0xfc,0xc0,0x78,0x00,0xcc,0x00,0x70,0x30,0x30,0x30,
0x78,0x00,0x7c,0xc6,0x38,0x18,0x18,0x18,0x3c,0x00,0xe0,0x00,0x70,0x30,0x30,0x30,0x78,0x00,0xcc,0x30,0x78,0xcc,0xcc,0xfc,0xcc,0x00,
0x30,0x30,0x00,0x78,0xcc,0xfc,0xcc,0x00,0x1c,0x00,0xfc,0x60,0x78,0x60,0xfc,0x00,0x00,0x00,0x7f,0x0c,0x7f,0xcc,0x7f,0x00,0x3e,0x6c,
0xcc,0xfe,0xcc,0xcc,0xce,0x00,0x78,0xcc,0x00,0x78,0xcc,0xcc,0x78,0x00,0x00,0xcc,0x00,0x78,0xcc,0xcc,0x78,0x00,0x00,0xe0,0x00,0x78,
0xcc,0xcc,0x78,0x00,0x78,0xcc,0x00,0xcc,0xcc,0xcc,0x7e,0x00,0x00,0xe0,0x00,0xcc,0xcc,0xcc,0x7e,0x00,0x00,0xcc,0x00,0xcc,0xcc,0xfc,
0x0c,0xf8,0xc6,0x38,0x7c,0xc6,0xc6,0x7c,0x38,0x00,0xcc,0x00,0xcc,0xcc,0xcc,0xcc,0x78,0x00,0x18,0x18,0x7e,0xc0,0xc0,0x7e,0x18,0x18,
0x38,0x6c,0x64,0xf0,0x60,0xe6,0xfc,0x00,0xcc,0xcc,0x78,0xfc,0x30,0xfc,0x30,0x00,0xf0,0xd8,0xd8,0xf4,0xcc,0xde,0xcc,0x0e,0x0e,0x1b,
0x18,0x7e,0x18,0x18,0xd8,0x70,0x1c,0x00,0x78,0x0c,0x7c,0xcc,0x7e,0x00,0x38,0x00,0x70,0x30,0x30,0x30,0x78,0x00,0x00,0x1c,0x00,0x78,
0xcc,0xcc,0x78,0x00,0x00,0x1c,0x00,0xcc,0xcc,0xcc,0x7e,0x00,0x00,0xf8,0x00,0xf8,0xcc,0xcc,0xcc,0x00,0xfc,0x00,0xcc,0xec,0xfc,0xdc,
0xcc,0x00,0x3c,0x6c,0x6c,0x3e,0x00,0x7e,0x00,0x00,0x3c,0x66,0x66,0x3c,0x00,0x7e,0x00,0x00,0x30,0x00,0x30,0x60,0xc0,0xcc,0x78,0x00,
0x00,0x00,0x00,0xfc,0xc0,0xc0,0x00,0x00,0x00,0x00,0x00,0xfc,0x0c,0x0c,0x00,0x00,0xc6,0xcc,0xd8,0x3e,0x63,0xce,0x98,0x1f,0xc6,0xcc,
0xd8,0xf3,0x67,0xcf,0x9f,0x03,0x00,0x18,0x00,0x18,0x18,0x3c,0x3c,0x18,0x00,0x33,0x66,0xcc,0x66,0x33,0x00,0x00,0x00,0xcc,0x66,0x33,
0x66,0xcc,0x00,0x00,0x22,0x88,0x22,0x88,0x22,0x88,0x22,0x88,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0xdc,0x76,0xdc,0x76,0xdc,0x76,
0xdc,0x76,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xf8,0x18,0x18,0x18,0x18,0x18,0xf8,0x18,0xf8,0x18,0x18,0x18,
0x36,0x36,0x36,0x36,0xf6,0x36,0x36,0x36,0x00,0x00,0x00,0x00,0xfe,0x36,0x36,0x36,0x00,0x00,0xf8,0x18,0xf8,0x18,0x18,0x18,0x36,0x36,
0xf6,0x06,0xf6,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x00,0x00,0xfe,0x06,0xf6,0x36,0x36,0x36,0x36,0x36,0xf6,0x06,
0xfe,0x00,0x00,0x00,0x36,0x36,0x36,0x36,0xfe,0x00,0x00,0x00,0x18,0x18,0xf8,0x18,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0x18,
0x18,0x18,0x18,0x18,0x18,0x18,0x1f,0x00,0x00,0x00,0x18,0x18,0x18,0x18,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x1f,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x18,0x18,0x18,0x18,0xff,0x18,0x18,0x18,0x18,0x18,
0x1f,0x18,0x1f,0x18,0x18,0x18,0x36,0x36,0x36,0x36,0x37,0x36,0x36,0x36,0x36,0x36,0x37,0x30,0x3f,0x00,0x00,0x00,0x00,0x00,0x3f,0x30,
0x37,0x36,0x36,0x36,0x36,0x36,0xf7,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0xff,0x00,0xf7,0x36,0x36,0x36,0x36,0x36,0x37,0x30,0x37,0x36,
0x36,0x36,0x00,0x00,0xff,0x00,0xff,0x00,0x00,0x00,0x36,0x36,0xf7,0x00,0xf7,0x36,0x36,0x36,0x18,0x18,0xff,0x00,0xff,0x00,0x00,0x00,
0x36,0x36,0x36,0x36,0xff,0x00,0x00,0x00,0x00,0x00,0xff,0x00,0xff,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0xff,0x36,0x36,0x36,0x36,0x36,
0x36,0x36,0x3f,0x00,0x00,0x00,0x18,0x18,0x1f,0x18,0x1f,0x00,0x00,0x00,0x00,0x00,0x1f,0x18,0x1f,0x18,0x18,0x18,0x00,0x00,0x00,0x00,
0x3f,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xf7,0x36,0x36,0x36,0x18,0x18,0xff,0x00,0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xf8,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x18,0x18,0x18,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,
0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,
0x76,0xdc,0xc8,0xdc,0x76,0x00,0x00,0x78,0xcc,0xf8,0xcc,0xf8,0xc0,0xc0,0x00,0xfe,0xc6,0xc0,0xc0,0xc0,0xc0,0x00,0x00,0xfe,0x6c,0x6c,
0x6c,0x6c,0x6c,0x00,0xfe,0x66,0x30,0x18,0x30,0x66,0xfe,0x00,0x00,0x00,0x7e,0xcc,0xcc,0xcc,0x78,0x00,0x00,0x66,0x66,0x66,0x66,0x7c,
0x60,0xc0,0x00,0x76,0xdc,0x18,0x18,0x18,0x18,0x00,0xfc,0x30,0x78,0xcc,0xcc,0x78,0x30,0xfc,0x38,0x6c,0xc6,0xfe,0xc6,0x6c,0x38,0x00,
0x38,0x6c,0xc6,0xc6,0x6c,0x6c,0xee,0x00,0x1c,0x30,0x18,0x7c,0xcc,0xcc,0x78,0x00,0x00,0x00,0x7e,0xdb,0xdb,0x7e,0x00,0x00,0x06,0x0c,
0x7e,0xdb,0xdb,0x7e,0x60,0xc0,0x3c,0x60,0xc0,0xfc,0xc0,0x60,0x3c,0x00,0x78,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0x00,0x00,0xfc,0x00,0xfc,
0x00,0xfc,0x00,0x00,0x30,0x30,0xfc,0x30,0x30,0x00,0xfc,0x00,0x60,0x30,0x18,0x30,0x60,0x00,0xfc,0x00,0x18,0x30,0x60,0x30,0x18,0x00,
0xfc,0x00,0x0e,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xd8,0xd8,0x70,0x30,0x30,0x00,0xfc,0x00,0x30,0x30,0x00,
0x00,0x72,0x9c,0x00,0x72,0x9c,0x00,0x00,0x38,0x6c,0x6c,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x18,0x00,0x00,0x00,0x0f,0x0c,0x0c,0x0c,0xec,0x6c,0x3c,0x1c,0x78,0x6c,0x6c,0x6c,0x6c,0x00,0x00,0x00,0x78,0x0c,0x38,0x60,
0x7c,0x00,0x00,0x00,0x00,0x00,0x3c,0x3c,0x3c,0x3c,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
];

static public immutable ushort[256*10] kgiFont10 = [
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x3f00,0x4080,0x5280,0x4080,0x5e80,0x4c80,0x2100,0x1e00,
0x0000,0x0000,0x3f00,0x7f80,0x6d80,0x7f80,0x6180,0x7380,0x3f00,0x1e00,0x0000,0x0000,0x3b80,0x7fc0,0x7fc0,0x7fc0,0x3f80,0x1f00,0x0e00,
0x0400,0x0000,0x0400,0x0e00,0x1f00,0x3f80,0x7fc0,0x3f80,0x1f00,0x0e00,0x0400,0x0000,0x0000,0x0e00,0x1f00,0x0e00,0x3f80,0x7fc0,0x3580,
0x0400,0x0e00,0x0000,0x0400,0x0e00,0x1f00,0x3f80,0x7fc0,0x7fc0,0x3580,0x0400,0x0e00,0x0000,0x0000,0x0000,0x0000,0x0c00,0x1e00,0x1e00,
0x0c00,0x0000,0x0000,0x0000,0xffc0,0xffc0,0xffc0,0xf3c0,0xe1c0,0xe1c0,0xf3c0,0xffc0,0xffc0,0xffc0,0x0000,0x0000,0x1e00,0x3300,0x2100,
0x2100,0x3300,0x1e00,0x0000,0x0000,0xffc0,0xffc0,0xe1c0,0xccc0,0xdec0,0xdec0,0xccc0,0xe1c0,0xffc0,0xffc0,0x0000,0x0780,0x0380,0x0780,
0x3e80,0x6600,0x6600,0x6600,0x3c00,0x0000,0x0000,0x1e00,0x3300,0x3300,0x3300,0x1e00,0x0c00,0x3f00,0x0c00,0x0000,0x0400,0x0600,0x0700,
0x0500,0x0500,0x0400,0x1c00,0x3c00,0x1800,0x0000,0x0000,0x1f80,0x1f80,0x1080,0x1080,0x1180,0x3380,0x7100,0x2000,0x0000,0x0000,0x0c00,
0x6d80,0x1e00,0x7380,0x7380,0x1e00,0x6d80,0x0c00,0x0000,0x1000,0x1800,0x1c00,0x1e00,0x1f00,0x1e00,0x1c00,0x1800,0x1000,0x0000,0x0100,
0x0300,0x0700,0x0f00,0x1f00,0x0f00,0x0700,0x0300,0x0100,0x0000,0x0000,0x0c00,0x1e00,0x3f00,0x0c00,0x0c00,0x3f00,0x1e00,0x0c00,0x0000,
0x0000,0x3300,0x3300,0x3300,0x3300,0x3300,0x0000,0x3300,0x0000,0x0000,0x0000,0x3f80,0x6d80,0x6d80,0x3d80,0x0d80,0x0d80,0x0d80,0x0000,
0x0000,0x0000,0x1f00,0x3000,0x1f00,0x3180,0x1f00,0x0180,0x1f00,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7f80,0x7f80,0x7f80,
0x0000,0x0000,0x0000,0x0c00,0x1e00,0x3f00,0x0c00,0x0c00,0x3f00,0x1e00,0x0c00,0xffc0,0x0000,0x0c00,0x1e00,0x3f00,0x0c00,0x0c00,0x0c00,
0x0c00,0x0c00,0x0000,0x0000,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x3f00,0x1e00,0x0c00,0x0000,0x0000,0x0000,0x0600,0x0300,0x7f80,0x0300,
0x0600,0x0000,0x0000,0x0000,0x0000,0x0000,0x1800,0x3000,0x7f80,0x3000,0x1800,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x6000,
0x6000,0x6000,0x7f80,0x0000,0x0000,0x0000,0x0000,0x1100,0x3180,0x7fc0,0x3180,0x1100,0x0000,0x0000,0x0000,0x0000,0x0000,0x0400,0x0e00,
0x1f00,0x3f80,0x7fc0,0x0000,0x0000,0x0000,0x0000,0x0000,0x7fc0,0x3f80,0x1f00,0x0e00,0x0400,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0c00,0x1e00,0x1e00,0x0c00,0x0c00,0x0000,0x0c00,0x0000,0x0000,0x0000,0x1b00,
0x1b00,0x1b00,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1b00,0x1b00,0x7fc0,0x1b00,0x7fc0,0x1b00,0x1b00,0x0000,0x0000,0x0400,
0x1f00,0x3580,0x3400,0x1f00,0x0580,0x3580,0x1f00,0x0400,0x0000,0x0000,0x3180,0x3300,0x0600,0x0c00,0x1980,0x3180,0x0000,0x0000,0x0000,
0x0000,0x1c00,0x3300,0x3300,0x1f80,0x3300,0x3300,0x1d80,0x0000,0x0000,0x0000,0x0e00,0x0c00,0x1800,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0600,0x0c00,0x1800,0x1800,0x1800,0x0c00,0x0600,0x0000,0x0000,0x0000,0x1800,0x0c00,0x0600,0x0600,0x0600,0x0c00,0x1800,
0x0000,0x0000,0x0000,0x0000,0x3300,0x1e00,0x7f80,0x1e00,0x3300,0x0000,0x0000,0x0000,0x0000,0x0000,0x0c00,0x0c00,0x3f00,0x0c00,0x0c00,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0c00,0x0c00,0x1800,0x0000,0x0000,0x0000,0x0000,0x0000,0x3f00,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0c00,0x0c00,0x0000,0x0000,0x0000,0x0180,0x0300,0x0600,0x0c00,
0x1800,0x3000,0x6000,0x0000,0x0000,0x0000,0x1f00,0x3380,0x3780,0x3f80,0x3d80,0x3980,0x1f00,0x0000,0x0000,0x0000,0x0c00,0x1c00,0x0c00,
0x0c00,0x0c00,0x0c00,0x3f00,0x0000,0x0000,0x0000,0x1f00,0x3180,0x0180,0x0f00,0x1800,0x3180,0x3f80,0x0000,0x0000,0x0000,0x1f00,0x3180,
0x0180,0x0700,0x0180,0x3180,0x1f00,0x0000,0x0000,0x0000,0x0700,0x0f00,0x1b00,0x3300,0x3f80,0x0300,0x0780,0x0000,0x0000,0x0000,0x3f80,
0x3000,0x3000,0x3f00,0x0180,0x3180,0x1f00,0x0000,0x0000,0x0000,0x0f00,0x1800,0x3000,0x3f00,0x3180,0x3180,0x1f00,0x0000,0x0000,0x0000,
0x3f80,0x3180,0x0180,0x0300,0x0600,0x0c00,0x0c00,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3180,0x1f00,0x3180,0x3180,0x1f00,0x0000,0x0000,
0x0000,0x1f00,0x3180,0x3180,0x1f80,0x0180,0x0300,0x1e00,0x0000,0x0000,0x0000,0x0000,0x0c00,0x0c00,0x0000,0x0000,0x0c00,0x0c00,0x0000,
0x0000,0x0000,0x0000,0x0c00,0x0c00,0x0000,0x0000,0x0c00,0x0c00,0x1800,0x0000,0x0000,0x0300,0x0600,0x0c00,0x1800,0x0c00,0x0600,0x0300,
0x0000,0x0000,0x0000,0x0000,0x0000,0x3f00,0x0000,0x3f00,0x0000,0x0000,0x0000,0x0000,0x0000,0x1800,0x0c00,0x0600,0x0300,0x0600,0x0c00,
0x1800,0x0000,0x0000,0x0000,0x1e00,0x3300,0x0300,0x0300,0x0600,0x0c00,0x0000,0x0c00,0x0000,0x0000,0x3f00,0x6180,0x6780,0x6d80,0x6780,
0x6000,0x3f00,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3180,0x3f80,0x3180,0x3180,0x3180,0x0000,0x0000,0x0000,0x3f00,0x3180,0x3180,0x3f00,
0x3180,0x3180,0x3f00,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3000,0x3000,0x3000,0x3180,0x1f00,0x0000,0x0000,0x0000,0x3e00,0x3300,0x3180,
0x3180,0x3180,0x3300,0x3e00,0x0000,0x0000,0x0000,0x3f80,0x3000,0x3000,0x3f00,0x3000,0x3000,0x3f80,0x0000,0x0000,0x0000,0x3f80,0x3000,
0x3000,0x3f00,0x3000,0x3000,0x3000,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3000,0x3380,0x3180,0x3180,0x1f00,0x0000,0x0000,0x0000,0x3180,
0x3180,0x3180,0x3f80,0x3180,0x3180,0x3180,0x0000,0x0000,0x0000,0x1e00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x1e00,0x0000,0x0000,0x0000,
0x0700,0x0300,0x0300,0x0300,0x3300,0x3300,0x1e00,0x0000,0x0000,0x0000,0x3180,0x3180,0x3300,0x3e00,0x3300,0x3180,0x3180,0x0000,0x0000,
0x0000,0x3000,0x3000,0x3000,0x3000,0x3000,0x3000,0x3f80,0x0000,0x0000,0x0000,0x6180,0x7380,0x7f80,0x6d80,0x6180,0x6180,0x6180,0x0000,
0x0000,0x0000,0x3180,0x3980,0x3d80,0x3780,0x3380,0x3180,0x3180,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3180,0x3180,0x3180,0x3180,0x1f00,
0x0000,0x0000,0x0000,0x3f00,0x3180,0x3180,0x3f00,0x3000,0x3000,0x3000,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3180,0x3180,0x3180,0x3380,
0x1f00,0x0380,0x0000,0x0000,0x3f00,0x3180,0x3180,0x3f00,0x3300,0x3180,0x3180,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3000,0x1f00,0x0180,
0x3180,0x1f00,0x0000,0x0000,0x0000,0x7f80,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0000,0x0000,0x0000,0x3180,0x3180,0x3180,0x3180,
0x3180,0x3180,0x1f00,0x0000,0x0000,0x0000,0x3180,0x3180,0x3180,0x3180,0x1b00,0x0e00,0x0400,0x0000,0x0000,0x0000,0x6180,0x6180,0x6180,
0x6d80,0x7f80,0x7380,0x6180,0x0000,0x0000,0x0000,0x6180,0x3300,0x1e00,0x0c00,0x1e00,0x3300,0x6180,0x0000,0x0000,0x0000,0x6180,0x6180,
0x3300,0x1e00,0x0c00,0x0c00,0x0c00,0x0000,0x0000,0x0000,0x3f80,0x0300,0x0600,0x0c00,0x1800,0x3000,0x3f80,0x0000,0x0000,0x0000,0x1e00,
0x1800,0x1800,0x1800,0x1800,0x1800,0x1e00,0x0000,0x0000,0x0000,0x6000,0x3000,0x1800,0x0c00,0x0600,0x0300,0x0000,0x0000,0x0000,0x0000,
0x1e00,0x0600,0x0600,0x0600,0x0600,0x0600,0x1e00,0x0000,0x0000,0x0000,0x0400,0x0e00,0x1b00,0x3180,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xffc0,0x0000,0x0000,0x1c00,0x0c00,0x0600,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x1f00,0x0180,0x1f80,0x3180,0x1f80,0x0000,0x0000,0x0000,0x3000,0x3000,0x3f00,0x3180,0x3180,0x3180,0x3f00,
0x0000,0x0000,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3000,0x3180,0x1f00,0x0000,0x0000,0x0000,0x0180,0x0180,0x1f80,0x3180,0x3180,0x3180,
0x1f80,0x0000,0x0000,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3f80,0x3000,0x1f00,0x0000,0x0000,0x0000,0x0f00,0x1800,0x1800,0x3e00,0x1800,
0x1800,0x1800,0x0000,0x0000,0x0000,0x0000,0x0000,0x1f80,0x3180,0x3180,0x3180,0x1f80,0x0180,0x1f00,0x0000,0x3000,0x3000,0x3f00,0x3180,
0x3180,0x3180,0x3180,0x0000,0x0000,0x0000,0x0c00,0x0000,0x1c00,0x0c00,0x0c00,0x0c00,0x1e00,0x0000,0x0000,0x0000,0x0600,0x0000,0x0e00,
0x0600,0x0600,0x0600,0x0600,0x0600,0x1c00,0x0000,0x3000,0x3000,0x3180,0x3300,0x3e00,0x3300,0x3180,0x0000,0x0000,0x0000,0x1c00,0x0c00,
0x0c00,0x0c00,0x0c00,0x0c00,0x0700,0x0000,0x0000,0x0000,0x0000,0x0000,0x3300,0x7f80,0x6d80,0x6d80,0x6180,0x0000,0x0000,0x0000,0x0000,
0x0000,0x3f00,0x3180,0x3180,0x3180,0x3180,0x0000,0x0000,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3180,0x3180,0x1f00,0x0000,0x0000,0x0000,
0x0000,0x0000,0x3f00,0x3180,0x3180,0x3f00,0x3000,0x3000,0x0000,0x0000,0x0000,0x0000,0x1f80,0x3180,0x3180,0x1f80,0x0180,0x01c0,0x0000,
0x0000,0x0000,0x0000,0x3f00,0x3180,0x3000,0x3000,0x3000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1f80,0x3000,0x1f00,0x0180,0x3f00,0x0000,
0x0000,0x0000,0x1800,0x1800,0x3e00,0x1800,0x1800,0x1800,0x0f00,0x0000,0x0000,0x0000,0x0000,0x0000,0x3180,0x3180,0x3180,0x3180,0x1f80,
0x0000,0x0000,0x0000,0x0000,0x0000,0x3180,0x3180,0x1b00,0x0e00,0x0400,0x0000,0x0000,0x0000,0x0000,0x0000,0x6180,0x6d80,0x6d80,0x7f80,
0x3300,0x0000,0x0000,0x0000,0x0000,0x0000,0x3180,0x1b00,0x0e00,0x1b00,0x3180,0x0000,0x0000,0x0000,0x0000,0x0000,0x3180,0x3180,0x3180,
0x1f80,0x0180,0x1f00,0x0000,0x0000,0x0000,0x0000,0x3f00,0x0600,0x0c00,0x1800,0x3f00,0x0000,0x0000,0x0000,0x0e00,0x1800,0x1800,0x3000,
0x1800,0x1800,0x0e00,0x0000,0x0000,0x0c00,0x0c00,0x0c00,0x0c00,0x0000,0x0c00,0x0c00,0x0c00,0x0c00,0x0000,0x0000,0x1c00,0x0600,0x0600,
0x0300,0x0600,0x0600,0x1c00,0x0000,0x0000,0x0000,0x0000,0x0000,0x3800,0x6d80,0x0700,0x0000,0x0000,0x0000,0x0000,0x0000,0x0400,0x0e00,
0x1b00,0x3180,0x3180,0x3180,0x3f80,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3000,0x3000,0x3000,0x3180,0x1f00,0x0c00,0x1800,0x0000,0x1b00,
0x0000,0x3180,0x3180,0x3180,0x3180,0x1f80,0x0000,0x0000,0x0600,0x0c00,0x0000,0x1f00,0x3180,0x3f80,0x3000,0x1f00,0x0000,0x0000,0x0e00,
0x1b00,0x0000,0x1f00,0x0180,0x1f80,0x3180,0x1f80,0x0000,0x0000,0x0000,0x1b00,0x0000,0x1f00,0x0180,0x1f80,0x3180,0x1f80,0x0000,0x0000,
0x0c00,0x0600,0x0000,0x1f00,0x0180,0x1f80,0x3180,0x1f80,0x0000,0x0000,0x0e00,0x1b00,0x0e00,0x1f00,0x0180,0x1f80,0x3180,0x1f80,0x0000,
0x0000,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3000,0x3180,0x1f00,0x0c00,0x1800,0x0e00,0x1b00,0x0000,0x1f00,0x3180,0x3f80,0x3000,0x1f00,
0x0000,0x0000,0x0000,0x1b00,0x0000,0x1f00,0x3180,0x3f80,0x3000,0x1f00,0x0000,0x0000,0x0c00,0x0600,0x0000,0x1f00,0x3180,0x3f80,0x3000,
0x1f00,0x0000,0x0000,0x0000,0x3600,0x0000,0x1c00,0x0c00,0x0c00,0x0c00,0x1e00,0x0000,0x0000,0x1c00,0x3600,0x0000,0x1c00,0x0c00,0x0c00,
0x0c00,0x1e00,0x0000,0x0000,0x1800,0x0c00,0x0000,0x1c00,0x0c00,0x0c00,0x0c00,0x1e00,0x0000,0x0000,0x0000,0x1b00,0x0000,0x1f00,0x3180,
0x3f80,0x3180,0x3180,0x0000,0x0000,0x0e00,0x1b00,0x0e00,0x1f00,0x3180,0x3f80,0x3180,0x3180,0x0000,0x0000,0x0600,0x0c00,0x0000,0x3f80,
0x3000,0x3f00,0x3000,0x3f80,0x0000,0x0000,0x0000,0x0000,0x0000,0x3b80,0x0ec0,0x3fc0,0x6e00,0x3b80,0x0000,0x0000,0x0000,0x1f80,0x3600,
0x6600,0x7f80,0x6600,0x6600,0x6780,0x0000,0x0000,0x0e00,0x1b00,0x0000,0x1f00,0x3180,0x3180,0x3180,0x1f00,0x0000,0x0000,0x0000,0x1b00,
0x0000,0x1f00,0x3180,0x3180,0x3180,0x1f00,0x0000,0x0000,0x0c00,0x0600,0x0000,0x1f00,0x3180,0x3180,0x3180,0x1f00,0x0000,0x0000,0x0e00,
0x1b00,0x0000,0x3180,0x3180,0x3180,0x3180,0x1f80,0x0000,0x0000,0x0c00,0x0600,0x0000,0x3180,0x3180,0x3180,0x3180,0x1f80,0x0000,0x0000,
0x0000,0x1b00,0x0000,0x3180,0x3180,0x3180,0x1f80,0x0180,0x1f00,0x0000,0x0000,0x1b00,0x0000,0x1f00,0x3180,0x3180,0x3180,0x1f00,0x0000,
0x0000,0x0000,0x1b00,0x0000,0x3180,0x3180,0x3180,0x3180,0x1f80,0x0000,0x0000,0x0000,0x0000,0x0400,0x1f00,0x3580,0x3400,0x3580,0x1f00,
0x0400,0x0000,0x0000,0x0f00,0x1980,0x1800,0x3e00,0x1800,0x1800,0x3000,0x3f80,0x0000,0x0000,0x6180,0x6180,0x3300,0x1e00,0x3f00,0x0c00,
0x3f00,0x0c00,0x0000,0x0000,0x7f00,0x6180,0x6d80,0x6d80,0x7f00,0x6c00,0x6c00,0x6700,0x0000,0x0000,0x0700,0x0c00,0x0c00,0x1e00,0x0c00,
0x0c00,0x0c00,0x3800,0x0000,0x0600,0x0c00,0x0000,0x1f00,0x0180,0x1f80,0x3180,0x1f80,0x0000,0x0000,0x0c00,0x1800,0x0000,0x1c00,0x0c00,
0x0c00,0x0c00,0x1e00,0x0000,0x0000,0x0600,0x0c00,0x0000,0x1f00,0x3180,0x3180,0x3180,0x1f00,0x0000,0x0000,0x0600,0x0c00,0x0000,0x3180,
0x3180,0x3180,0x3180,0x1f80,0x0000,0x0000,0x1d80,0x3700,0x0000,0x3f00,0x3180,0x3180,0x3180,0x3180,0x0000,0x0000,0x1d80,0x3700,0x0000,
0x3980,0x3d80,0x3780,0x3380,0x3180,0x0000,0x0000,0x0000,0x1e00,0x0300,0x1f00,0x3300,0x1f00,0x0000,0x0000,0x0000,0x0000,0x0000,0x1e00,
0x3300,0x3300,0x3300,0x1e00,0x0000,0x0000,0x0000,0x0000,0x0000,0x0c00,0x0000,0x0c00,0x1800,0x3000,0x3000,0x3300,0x1e00,0x0000,0x0000,
0x0000,0x0000,0x0000,0x3f80,0x3000,0x3000,0x3000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x3f80,0x0180,0x0180,0x0180,0x0000,0x0000,
0x0000,0x2080,0x2100,0x2200,0x2400,0x0b00,0x1180,0x2300,0x4380,0x0000,0x0000,0x2080,0x2100,0x2200,0x2400,0x0a80,0x1280,0x2380,0x4080,
0x0000,0x0000,0x0c00,0x0000,0x0c00,0x0c00,0x1e00,0x1e00,0x0c00,0x0000,0x0000,0x0000,0x0000,0x1980,0x3300,0x6600,0x3300,0x1980,0x0000,
0x0000,0x0000,0x0000,0x0000,0x6600,0x3300,0x1980,0x3300,0x6600,0x0000,0x0000,0x0000,0x2200,0x8880,0x2200,0x8880,0x2200,0x8880,0x2200,
0x8880,0x2200,0x8880,0x5540,0xaa80,0x5540,0xaa80,0x5540,0xaa80,0x5540,0xaa80,0x5540,0xaa80,0xbb80,0xeec0,0xbb80,0xeec0,0xbb80,0xeec0,
0xbb80,0xeec0,0xbb80,0xeec0,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0xfc00,
0xfc00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0xfc00,0xfc00,0x0c00,0x0c00,0xfc00,0xfc00,0x0c00,0x0c00,0x3300,0x3300,0x3300,0x3300,
0xf300,0xf300,0x3300,0x3300,0x3300,0x3300,0x0000,0x0000,0x0000,0x0000,0xff00,0xff00,0x3300,0x3300,0x3300,0x3300,0x0000,0x0000,0xfc00,
0xfc00,0x0c00,0x0c00,0xfc00,0xfc00,0x0c00,0x0c00,0x3300,0x3300,0xf300,0xf300,0x0300,0x0300,0xf300,0xf300,0x3300,0x3300,0x3300,0x3300,
0x3300,0x3300,0x3300,0x3300,0x3300,0x3300,0x3300,0x3300,0x0000,0x0000,0xff00,0xff00,0x0300,0x0300,0xf300,0xf300,0x3300,0x3300,0x3300,
0x3300,0xf300,0xf300,0x0300,0x0300,0xff00,0xff00,0x0000,0x0000,0x3300,0x3300,0x3300,0x3300,0xff00,0xff00,0x0000,0x0000,0x0000,0x0000,
0x1800,0x1800,0xf800,0xf800,0x1800,0x1800,0xf800,0xf800,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xfc00,0xfc00,0x0c00,0x0c00,0x0c00,
0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0fc0,0x0fc0,0x0000,0x0000,0x0000,0x0000,0x0c00,0x0c00,0x0c00,0x0c00,0xffc0,0xffc0,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xffc0,0xffc0,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0fc0,0x0fc0,0x0c00,
0x0c00,0x0c00,0x0c00,0x0000,0x0000,0x0000,0x0000,0xffc0,0xffc0,0x0000,0x0000,0x0000,0x0000,0x0c00,0x0c00,0x0c00,0x0c00,0xffc0,0xffc0,
0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0fc0,0x0fc0,0x0c00,0x0c00,0x0fc0,0x0fc0,0x0c00,0x0c00,0x3300,0x3300,0x3300,0x3300,0x33c0,
0x33c0,0x3300,0x3300,0x3300,0x3300,0x3300,0x3300,0x33c0,0x33c0,0x3000,0x3000,0x3fc0,0x3fc0,0x0000,0x0000,0x0000,0x0000,0x3fc0,0x3fc0,
0x3000,0x3000,0x33c0,0x33c0,0x3300,0x3300,0x3300,0x3300,0xf3c0,0xf3c0,0x0000,0x0000,0xffc0,0xffc0,0x0000,0x0000,0x0000,0x0000,0xffc0,
0xffc0,0x0000,0x0000,0xf3c0,0xf3c0,0x3300,0x3300,0x3300,0x3300,0x33c0,0x33c0,0x3000,0x3000,0x33c0,0x33c0,0x3300,0x3300,0x0000,0x0000,
0xffc0,0xffc0,0x0000,0x0000,0xffc0,0xffc0,0x0000,0x0000,0x3300,0x3300,0xf3c0,0xf3c0,0x0000,0x0000,0xf3c0,0xf3c0,0x3300,0x3300,0x0c00,
0x0c00,0xffc0,0xffc0,0x0000,0x0000,0xffc0,0xffc0,0x0000,0x0000,0x3300,0x3300,0x3300,0x3300,0xffc0,0xffc0,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0xffc0,0xffc0,0x0000,0x0000,0xffc0,0xffc0,0x0c00,0x0c00,0x0000,0x0000,0x0000,0x0000,0xffc0,0xffc0,0x3300,0x3300,0x3300,
0x3300,0x3300,0x3300,0x3300,0x3300,0x3fc0,0x3fc0,0x0000,0x0000,0x0000,0x0000,0x0c00,0x0c00,0x0fc0,0x0fc0,0x0c00,0x0c00,0x0fc0,0x0fc0,
0x0000,0x0000,0x0000,0x0000,0x0fc0,0x0fc0,0x0c00,0x0c00,0x0fc0,0x0fc0,0x0c00,0x0c00,0x0000,0x0000,0x0000,0x0000,0x3fc0,0x3fc0,0x3300,
0x3300,0x3300,0x3300,0x3300,0x3300,0x3300,0x3300,0xf3c0,0xf3c0,0x3300,0x3300,0x3300,0x3300,0x0c00,0x0c00,0xffc0,0xffc0,0x0000,0x0000,
0xffc0,0xffc0,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0xfc00,0xfc00,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0fc0,
0x0fc0,0x0c00,0x0c00,0x0c00,0x0c00,0xffc0,0xffc0,0xffc0,0xffc0,0xffc0,0xffc0,0xffc0,0xffc0,0xffc0,0xffc0,0x0000,0x0000,0x0000,0x0000,
0x0000,0xffc0,0xffc0,0xffc0,0xffc0,0xffc0,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0x07c0,0x07c0,0x07c0,
0x07c0,0x07c0,0x07c0,0x07c0,0x07c0,0x07c0,0x07c0,0xffc0,0xffc0,0xffc0,0xffc0,0xffc0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x1d80,0x3700,0x3200,0x3700,0x1d80,0x0000,0x0000,0x0000,0x1e00,0x3300,0x3300,0x3600,0x3300,0x3180,0x3700,0x3000,0x0000,0x0000,
0x3f80,0x3180,0x3000,0x3000,0x3000,0x3000,0x3000,0x0000,0x0000,0x0000,0x0000,0x7f80,0x3300,0x3300,0x3300,0x3300,0x3300,0x0000,0x0000,
0x0000,0x3f80,0x1800,0x0c00,0x0600,0x0c00,0x1800,0x3f80,0x0000,0x0000,0x0000,0x0000,0x0000,0x1f80,0x3600,0x3300,0x3300,0x1e00,0x0000,
0x0000,0x0000,0x0000,0x0000,0x6300,0x6300,0x6700,0x7d80,0x6000,0x6000,0x0000,0x0000,0x0000,0x0000,0x3f00,0x0c00,0x0c00,0x0c00,0x0600,
0x0000,0x0000,0x0000,0x1e00,0x0c00,0x3f00,0x6d80,0x6d80,0x3f00,0x0c00,0x1e00,0x0000,0x0000,0x1e00,0x3300,0x3300,0x3f00,0x3300,0x3300,
0x1e00,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3180,0x3180,0x3180,0x1b00,0x3b80,0x0000,0x0000,0x0000,0x1f00,0x0c00,0x0600,0x1f00,0x3180,
0x3180,0x1f00,0x0000,0x0000,0x0000,0x0000,0x0000,0x3b80,0x66c0,0x64c0,0x6cc0,0x3b80,0x0000,0x0000,0x0000,0x0000,0x0180,0x3f00,0x6780,
0x6d80,0x7980,0x3f00,0x6000,0x0000,0x0000,0x0000,0x0000,0x1f00,0x3000,0x1e00,0x3000,0x1f00,0x0000,0x0000,0x0000,0x1f00,0x3180,0x3180,
0x3180,0x3180,0x3180,0x3180,0x0000,0x0000,0x0000,0x0000,0x3f00,0x0000,0x3f00,0x0000,0x3f00,0x0000,0x0000,0x0000,0x0000,0x0c00,0x0c00,
0x3f00,0x0c00,0x0c00,0x0000,0x3f00,0x0000,0x0000,0x0000,0x0600,0x0c00,0x1800,0x0c00,0x0600,0x0000,0x3f00,0x0000,0x0000,0x0000,0x1800,
0x0c00,0x0600,0x0c00,0x1800,0x0000,0x3f00,0x0000,0x0000,0x0000,0x0700,0x0d80,0x0d80,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,
0x0c00,0x0c00,0x0c00,0x0c00,0x0c00,0x6c00,0x6c00,0x3800,0x0000,0x0000,0x0000,0x0c00,0x0000,0x3f00,0x0000,0x0c00,0x0000,0x0000,0x0000,
0x0000,0x3800,0x6d80,0x0700,0x0000,0x3800,0x6d80,0x0700,0x0000,0x0000,0x0000,0x0e00,0x1b00,0x1b00,0x0e00,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0c00,0x0c00,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0c00,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x07c0,0x0600,0x0600,0x6600,0x3600,0x1e00,0x0e00,0x0600,0x0200,0x0000,0x3e00,0x3300,0x3300,0x3300,0x3300,0x0000,
0x0000,0x0000,0x0000,0x0000,0x1e00,0x0300,0x0e00,0x1800,0x1f00,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1e00,0x1e00,0x1e00,
0x1e00,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
];

// bits 0..3: width
// bits 4..7: lshift
public immutable ubyte[256] kgiFont6PropWidth = () {
  ubyte[256] res;
  foreach (immutable cnum; 0..256) {
    import core.bitop : bsf, bsr;
    immutable doshift =
      (cnum >= 32 && cnum <= 127) ||
      (cnum >= 143 && cnum <= 144) ||
      (cnum >= 166 && cnum <= 167) ||
      (cnum >= 192 && cnum <= 255);
    int shift = 0;
    if (doshift) {
      shift = 8;
      foreach (immutable dy; 0..8) {
        immutable b = kgiFont6[cnum*8+dy];
        if (b) {
          immutable mn = 7-bsr(b);
          if (mn < shift) shift = mn;
        }
      }
    }
    ubyte wdt = 0;
    foreach (immutable dy; 0..8) {
      immutable b = (kgiFont6[cnum*8+dy]<<shift);
      immutable cwdt = (b ? 8-bsf(b) : 0);
      if (cwdt > wdt) wdt = cast(ubyte)cwdt;
    }
    switch (cnum) {
      case 0: wdt = 8; break; // 8px space
      case 32: wdt = 5; break; // 5px space
      case  17: .. case  27: wdt = 8; break; // single frames
      case  48: .. case  57: wdt = 5; break; // digits are monospaced
      case 127: .. case 142: wdt = 8; break; // filled frames
      case 145: .. case 151: wdt = 8; break; // filled frames
      case 155: .. case 159: wdt = 8; break; // filled frames
      default:
    }
    res[cnum] = (wdt&0x0f)|((shift<<4)&0xf0);
  }
  return res;
}();

// bits 0..3: width
// bits 4..7: lshift
public immutable ubyte[256] kgiFont8PropWidth = () {
  ubyte[256] res;
  foreach (immutable cnum; 0..256) {
    import core.bitop : bsf, bsr;
    immutable doshift =
      (cnum >= 32 && cnum <= 127) ||
      (cnum >= 143 && cnum <= 144) ||
      (cnum >= 166 && cnum <= 167) ||
      (cnum >= 192 && cnum <= 255);
    int shift = 0;
    if (doshift) {
      shift = 8;
      foreach (immutable dy; 0..8) {
        immutable b = kgiFont8[cnum*8+dy];
        if (b) {
          immutable mn = 7-bsr(b);
          if (mn < shift) shift = mn;
        }
      }
    }
    ubyte wdt = 0;
    foreach (immutable dy; 0..8) {
      immutable b = (kgiFont8[cnum*8+dy]<<shift);
      immutable cwdt = (b ? 8-bsf(b) : 0);
      if (cwdt > wdt) wdt = cast(ubyte)cwdt;
    }
    switch (cnum) {
      case 0: wdt = 8; break; // 8px space
      case 32: wdt = 5; break; // 5px space
      case  48: .. case  57: wdt = 5; break; // digits are monospaced
      case 176: .. case 223: wdt = 8; break; // pseudographics (frames, etc)
      default:
    }
    res[cnum] = (wdt&0x0f)|((shift<<4)&0xf0);
  }
  return res;
}();


// ////////////////////////////////////////////////////////////////////////// //
private:

const(char)[] sdrGetPart(string typepfx) (const(char)[] s) nothrow @trusted @nogc {
  // skips prefix "---"
  static usize findMark(string at) (const(char)[] s, uint idx=0) nothrow @trusted @nogc {
    while (idx < s.length) {
      if (idx == 0 || s.ptr[idx-1] == '\n') {
        while (idx < s.length && (s.ptr[idx] == ' ' || s.ptr[idx] == '\t')) ++idx;
        if (s.length-idx >= 3 && s.ptr[idx] == '-' && s.ptr[idx+1] == '-' && s.ptr[idx+2] == '-') {
          static if (at == "start") {
            while (idx > 0 && s.ptr[idx-1] != '\n') --idx;
          } else static if (at == "end") {
            idx += 3;
            while (idx < s.length && s.ptr[idx] == '-') ++idx;
            while (idx < s.length && (s.ptr[idx] == ' ' || s.ptr[idx] == '\t')) ++idx;
          } else {
            static assert(0, "wtf?!");
          }
          return idx;
        }
      }
      ++idx;
    }
    return idx;
  }

  usize idx = findMark!"end"(s);
  while (idx < s.length) {
    if (s.length-idx >= typepfx.length && s[idx..idx+typepfx.length] == typepfx) {
      while (idx < s.length && s.ptr[idx] != '\n') ++idx;
      while (idx < s.length && s.ptr[idx] <= ' ') ++idx;
      if (idx >= s.length) return null;
      auto eidx = findMark!"start"(s, idx);
      if (eidx > s.length) eidx = s.length;
      while (eidx > idx && s.ptr[eidx-1] <= ' ') --eidx;
      return (eidx > idx ? s[idx..eidx] : null);
    } else {
      while (idx < s.length && s.ptr[idx] != '\n') ++idx;
      idx = findMark!"end"(s, idx);
    }
  }
  return null;
}


// find var id: glGetUniformLocation(prg, bufasciiz.ptr)
// set var: glUniformXXX()

// returns 0 or programid
uint compileShaders (const(char)[] src) nothrow @trusted @nogc {
  import iv.glbinds;

  GLuint prg = 0;
  GLuint fsid = 0, vsid = 0;

  auto fragsrc = sdrGetPart!"frag"(src);
  auto vertsrc = sdrGetPart!"vert"(src);

  if (fragsrc.length == 0 && vertsrc.length == 0) return 0;

  if (fragsrc.length) {
    fsid = createShader!GL_FRAGMENT_SHADER(fragsrc);
    if (fsid == 0) return 0;
  }

  if (vertsrc.length) {
    vsid = createShader!GL_VERTEX_SHADER(vertsrc);
    if (vsid == 0) {
      if (fsid != 0) glDeleteShader(fsid);
      return 0;
    }
  }

  prg = glCreateProgram();
  if (prg == 0) {
    if (fsid != 0) glDeleteShader(fsid);
    if (vsid != 0) glDeleteShader(vsid);
    conwriteln("GLKGI ERROR: can't create shader program.");
    return 0;
  }

  if (fsid) glAttachShader(prg, fsid);
  if (vsid) glAttachShader(prg, vsid);
  glLinkProgram(prg);

  GLint lres = 0;
  glGetProgramiv(prg, GL_LINK_STATUS, &lres);
  if (lres != GL_TRUE) {
    glDeleteProgram(prg);
    if (fsid != 0) glDeleteShader(fsid);
    if (vsid != 0) glDeleteShader(vsid);
    conwriteln("GLKGI ERROR: can't link shader program.");
    return 0;
  }

  return prg;
}


// returns 0 or shaderid
uint createShader(uint type) (const(char)[] src) nothrow @trusted @nogc {
  import iv.glbinds;

  auto shaderId = glCreateShader(type);
  if (!shaderId) {
    conwriteln("GLKGI ERROR: can't create shader.");
    return 0;
  }
  auto sptr = src.ptr;
  GLint slen = cast(int)src.length;
  glShaderSource(shaderId, 1, &sptr, &slen);
  glCompileShader(shaderId);
  GLint success = 0;
  glGetShaderiv(shaderId, GL_COMPILE_STATUS, &success);
  if (!success || showShaderWarnings) {
    import core.stdc.stdlib : malloc, free;
    GLint logSize = 0;
    glGetShaderiv(shaderId, GL_INFO_LOG_LENGTH, &logSize);
    if (logSize > 0) {
      auto logStrZ = cast(GLchar*)malloc(logSize);
      if (logStrZ !is null) {
        //import core.stdc.stdio : printf;
        scope(exit) free(logStrZ);
        glGetShaderInfoLog(shaderId, logSize, null, logStrZ);
        if (logSize > 0 && logStrZ[logSize-1] == 0) --logSize;
        //printf("shader '%.*s' compilation messages:\n%s\n", cast(uint)ashaderName.length, ashaderName.ptr, logStrZ);
        conwriteln("GLKGI: shader compilation messages:\n", logStrZ[0..logSize]);
      }
    }
  }
  if (!success) {
    glDeleteShader(shaderId);
    conwriteln("GLKGI ERROR: can't compile shader.");
    return 0;
  }
  return shaderId;
}


// ////////////////////////////////////////////////////////////////////////// //
// shaders
static string sdrScanlineSrc = q{
---frag---
#version 120

uniform sampler2D tex;

void main () {
  vec4 color = texture2D(tex, gl_TexCoord[0].xy);
  if (mod(floor(gl_FragCoord.y), 2) == 1) { color.x *= 0.75; color.y *= 0.75; color.z *= 0.75; }
  gl_FragColor = color;
}

---vert---
#version 120

void main () {
  gl_TexCoord[0] = gl_MultiTexCoord0;
  //gl_Position = gl_ProjectionMatrix*gl_ModelViewMatrix*gl_Vertex;
  gl_Position = gl_ProjectionMatrix*gl_Vertex;
}
};


// ////////////////////////////////////////////////////////////////////////// //
// default cursor (hi, Death Track!)
private enum defaultCurWidth = 17;
private enum defaultCurHeight = 23;
private static immutable ubyte[defaultCurWidth*defaultCurHeight] defaultCurImg = [
  0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,
  1,0,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,
  1,1,3,3,2,2,0,0,0,0,0,0,0,0,0,0,0,
  1,1,3,3,4,2,2,0,0,0,0,0,0,0,0,0,0,
  1,1,3,3,4,4,2,2,0,0,0,0,0,0,0,0,0,
  1,1,3,3,4,4,4,2,2,0,0,0,0,0,0,0,0,
  1,1,3,3,4,4,4,4,2,2,0,0,0,0,0,0,0,
  1,1,3,3,4,4,4,5,6,2,2,0,0,0,0,0,0,
  1,1,3,3,4,4,5,6,7,5,2,2,0,0,0,0,0,
  1,1,3,3,4,5,6,7,5,4,5,2,2,0,0,0,0,
  1,1,3,3,5,6,7,5,4,5,6,7,2,2,0,0,0,
  1,1,3,3,6,7,5,4,5,6,7,7,7,2,2,0,0,
  1,1,3,3,7,5,4,5,6,7,7,7,7,7,2,2,0,
  1,1,3,3,5,4,5,6,8,8,8,8,8,8,8,8,2,
  1,1,3,3,4,5,6,3,8,8,8,8,8,8,8,8,8,
  1,1,3,3,5,6,3,3,1,1,1,1,1,1,1,0,0,
  1,1,3,3,6,3,3,1,1,1,1,1,1,1,1,0,0,
  1,1,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,
  1,1,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,
  1,1,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,
  1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
];
private static immutable VColor[9] defaultCurPal = [
  rgbacol(  0,  0,  0,  0),
  rgbacol(  0,  0,  0,127),
  rgbacol( 85,255,255,255),
  rgbacol( 85, 85,255,255),
  rgbacol(255, 85, 85,255),
  rgbacol(170,  0,170,255),
  rgbacol( 85, 85, 85,255),
  rgbacol(  0,  0,  0,255),
  rgbacol(  0,  0,170,255),
];
