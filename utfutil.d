/* Invisible Vector Library
 * coded by Ketmar // Invisible Vector <ketmar@ketmar.no-ip.org>
 * Understanding is not required. Only obedience.
 *
 * This software is provided 'as-is', without any express or implied
 * warranty.  In no event will the authors be held liable for any damages
 * arising from the use of this software.
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 */
// UTF-8 utilities (there will be more soon ;-)
module iv.utfutil;


// ////////////////////////////////////////////////////////////////////////// //
struct Utf8DecoderFast {
public:
  enum dchar replacement = '\uFFFD';
  static bool isValidDC (dchar c) pure nothrow @safe @nogc { pragma(inline, true); return (c < 0xD800 || (c > 0xDFFF && c <= 0x10FFFF)); }

private:
  enum State {
    Accept = 0,
    Reject = 12,
  }

  // see http://bjoern.hoehrmann.de/utf-8/decoder/dfa/
  static immutable ubyte[0x16c] utf8dfa = [
    // maps bytes to character classes
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 00-0f
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 10-1f
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 20-2f
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 30-3f
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 40-4f
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 50-5f
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 60-6f
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 70-7f
    0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01, // 80-8f
    0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09, // 90-9f
    0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07, // a0-af
    0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07, // b0-bf
    0x08,0x08,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02, // c0-cf
    0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02, // d0-df
    0x0a,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x04,0x03,0x03, // e0-ef
    0x0b,0x06,0x06,0x06,0x05,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08, // f0-ff
    // maps a combination of a state of the automaton and a character class to a state
    0x00,0x0c,0x18,0x24,0x3c,0x60,0x54,0x0c,0x0c,0x0c,0x30,0x48,0x0c,0x0c,0x0c,0x0c, // 100-10f
    0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x00,0x0c,0x0c,0x0c,0x0c,0x0c,0x00, // 110-11f
    0x0c,0x00,0x0c,0x0c,0x0c,0x18,0x0c,0x0c,0x0c,0x0c,0x0c,0x18,0x0c,0x18,0x0c,0x0c, // 120-12f
    0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x18,0x0c,0x0c,0x0c,0x0c,0x0c,0x18,0x0c,0x0c, // 130-13f
    0x0c,0x0c,0x0c,0x0c,0x0c,0x18,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x24, // 140-14f
    0x0c,0x24,0x0c,0x0c,0x0c,0x24,0x0c,0x0c,0x0c,0x0c,0x0c,0x24,0x0c,0x24,0x0c,0x0c, // 150-15f
    0x0c,0x24,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c];

nothrow @safe @nogc:
public:
  uint state;
  dchar codepoint = 0;

  // is current character complete? take `codepoint` then
  @property bool complete () const pure { pragma(inline, true); return (state == State.Accept); }
  @property bool invalid () const pure { pragma(inline, true); return (state == State.Reject); }
  @property bool completeOrInvalid () const pure { pragma(inline, true); return (state == State.Accept || state == State.Reject); }
  void reset () pure { pragma(inline, true); state = State.Accept; codepoint = 0; }
  // process one byte, return `true` if codepoint is ready
  bool decode (ubyte b) pure @trusted {
    if (state == State.Reject) { state = 0; codepoint = 0; }
    uint type = utf8dfa.ptr[b];
    codepoint = (state != State.Accept ? (b&0x3fu)|(codepoint<<6) : (0xff>>type)&b);
    state = utf8dfa.ptr[256+state+type];
    return (state == State.Accept);
  }
  // same as `decode`, but caller is guaranteed that decoder will never get invalid utf-8 sequence
  bool decodeValid (ubyte b) pure @trusted {
    uint type = utf8dfa.ptr[b];
    codepoint = (state != State.Accept ? (b&0x3fu)|(codepoint<<6) : (0xff>>type)&b);
    state = utf8dfa.ptr[256+state+type];
    return (state == State.Accept);
  }
  // same as `decode`, never reaches `invalid` state, returns `replacement` for invalid chars
  bool decodeSafe (ubyte b) pure @trusted {
    uint type = utf8dfa.ptr[b];
    codepoint = (state != State.Accept ? (b&0x3f)|(codepoint<<6) : (0xff>>type)&b);
    if ((state = utf8dfa.ptr[256+state+type]) == State.Reject) { state = State.Accept; codepoint = replacement; }
    return (state == State.Accept);
  }
}


// ////////////////////////////////////////////////////////////////////////// //
// slow, but using only 4 bytes (dchar)
struct Utf8Decoder {
public:
  enum dchar replacement = '\uFFFD';
  static bool isValidDC (dchar c) pure nothrow @safe @nogc { pragma(inline, true); return (c < 0xD800 || (c > 0xDFFF && c <= 0x10FFFF)); }

private:
  enum State : uint {
    Accept = 0x0000_0000u,
    Reject = 0x0c00_0000u,
    Mask = 0xff00_0000u
  }
  uint codep = State.Accept;
pure nothrow @safe @nogc:
public:
  // is current character complete? take `codepoint` then
  @property bool complete () const { pragma(inline, true); return ((codep&State.Mask) == State.Accept); }
  @property bool invalid () const { pragma(inline, true); return ((codep&State.Mask) == State.Reject); }
  @property bool completeOrInvalid () const { pragma(inline, true); return (complete || invalid); }
  @property dchar currCodePoint () const { pragma(inline, true); return (codep <= dchar.max ? codep : replacement); }
  void reset () { codep = State.Accept; }
  // same as `decode`, never reaches `invalid` state, returns `replacement` for invalid chars
  // returns invalid dchar while it is "in progress" (i.e. result > dchar.max)
  dchar decode (ubyte b) @trusted {
    immutable ubyte type = Utf8DecoderFast.utf8dfa.ptr[b];
    ubyte state = (codep>>24)&0xff;
    codep = (state /*!= State.Accept*/ ? (b&0x3f)|((codep&~State.Mask)<<6) : (0xff>>type)&b);
    if ((state = Utf8DecoderFast.utf8dfa.ptr[256+state+type]) == 12/*State.Reject*/) {
      codep = replacement;
    } else {
      codep |= (cast(uint)state<<24);
    }
    return codep;
  }
}


// ////////////////////////////////////////////////////////////////////////// //
// returns -1 on error (out of room in `s`, for example), or bytes taken
int utf8Encode(dchar replacement='\uFFFD') (char[] s, dchar c) pure nothrow @trusted @nogc {
  static assert(Utf8Decoder.isValidDC(replacement), "invalid replacement char");
  if (!Utf8Decoder.isValidDC(c)) c = replacement;
  if (c <= 0x7F) {
    if (s.length < 1) return -1;
    s.ptr[0] = cast(char)c;
    return 1;
  } else {
    char[4] buf;
    ubyte len;
    if (c <= 0x7FF) {
      buf.ptr[0] = cast(char)(0xC0|(c>>6));
      buf.ptr[1] = cast(char)(0x80|(c&0x3F));
      len = 2;
    } else if (c <= 0xFFFF) {
      buf.ptr[0] = cast(char)(0xE0|(c>>12));
      buf.ptr[1] = cast(char)(0x80|((c>>6)&0x3F));
      buf.ptr[2] = cast(char)(0x80|(c&0x3F));
      len = 3;
    } else if (c <= 0x10FFFF) {
      buf.ptr[0] = cast(char)(0xF0|(c>>18));
      buf.ptr[1] = cast(char)(0x80|((c>>12)&0x3F));
      buf.ptr[2] = cast(char)(0x80|((c>>6)&0x3F));
      buf.ptr[3] = cast(char)(0x80|(c&0x3F));
      len = 4;
    } else {
      assert(0, "wtf?!");
    }
    if (s.length < len) return -1;
    s[0..len] = buf[0..len];
    return len;
  }
}


// ////////////////////////////////////////////////////////////////////////// //
// doesn't do all possible checks, so don't pass invalid UTF-8
size_t utf8Length (const(char)[] s) pure nothrow @trusted @nogc {
  static immutable ubyte[256] UTF8stride = [
    cast(ubyte)
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
    3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
    4,4,4,4,4,4,4,4,5,5,5,5,6,6,0xFF,0xFF,
  ];
  size_t pos = 0, res = 0;
  while (pos < s.length) {
    ubyte l = UTF8stride.ptr[s.ptr[pos++]];
    if (l == 0xFF) l = 1;
    res += l;
    pos += (l-1);
  }
  return res;
}


// ////////////////////////////////////////////////////////////////////////// //
bool isUtf8Start() (char ch) pure nothrow @trusted @nogc { pragma(inline, true); return ((ch&0xC0) == 0xC0); }
bool isUtf8Cont() (char ch) pure nothrow @trusted @nogc { pragma(inline, true); return ((ch&0xC0) == 0x80); }


// ////////////////////////////////////////////////////////////////////////// //
private static immutable ubyte[0x458-0x401] uni2koiTable = [
  0xB3,0x3F,0x3F,0xB4,0x3F,0xB6,0xB7,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0xE1,
  0xE2,0xF7,0xE7,0xE4,0xE5,0xF6,0xFA,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF2,
  0xF3,0xF4,0xF5,0xE6,0xE8,0xE3,0xFE,0xFB,0xFD,0xFF,0xF9,0xF8,0xFC,0xE0,0xF1,0xC1,
  0xC2,0xD7,0xC7,0xC4,0xC5,0xD6,0xDA,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD2,
  0xD3,0xD4,0xD5,0xC6,0xC8,0xC3,0xDE,0xDB,0xDD,0xDF,0xD9,0xD8,0xDC,0xC0,0xD1,0x3F,
  0xA3,0x3F,0x3F,0xA4,0x3F,0xA6,0xA7
];


private static immutable dchar[128] koi2uniTable = [
  0x2500,0x2502,0x250C,0x2510,0x2514,0x2518,0x251C,0x2524,0x252C,0x2534,0x253C,0x2580,0x2584,0x2588,0x258C,0x2590,
  0x2591,0x2592,0x2593,0x2320,0x25A0,0x2219,0x221A,0x2248,0x2264,0x2265,0x00A0,0x2321,0x00B0,0x00B2,0x00B7,0x00F7,
  0x2550,0x2551,0x2552,0x0451,0x0454,0x2554,0x0456,0x0457,0x2557,0x2558,0x2559,0x255A,0x255B,0x0491,0x255D,0x255E,
  0x255F,0x2560,0x2561,0x0401,0x0404,0x2563,0x0406,0x0407,0x2566,0x2567,0x2568,0x2569,0x256A,0x0490,0x256C,0x00A9,
  0x044E,0x0430,0x0431,0x0446,0x0434,0x0435,0x0444,0x0433,0x0445,0x0438,0x0439,0x043A,0x043B,0x043C,0x043D,0x043E,
  0x043F,0x044F,0x0440,0x0441,0x0442,0x0443,0x0436,0x0432,0x044C,0x044B,0x0437,0x0448,0x044D,0x0449,0x0447,0x044A,
  0x042E,0x0410,0x0411,0x0426,0x0414,0x0415,0x0424,0x0413,0x0425,0x0418,0x0419,0x041A,0x041B,0x041C,0x041D,0x041E,
  0x041F,0x042F,0x0420,0x0421,0x0422,0x0423,0x0416,0x0412,0x042C,0x042B,0x0417,0x0428,0x042D,0x0429,0x0427,0x042A,
];


// convert unicode to koi8-u
public char uni2koi() (dchar ch) pure nothrow @trusted @nogc {
  if (ch < 128) return cast(char)(ch&0xff);
  if (ch > 0x400 && ch < 0x458) return cast(char)(uni2koiTable.ptr[ch-0x401]);
  switch (ch) {
    case 0x490: return 0xBD; // ukrainian G with upturn (upcase)
    case 0x491: return 0xAD; // ukrainian G with upturn (locase)
    case 0x2500: return 0x80; // BOX DRAWINGS LIGHT HORIZONTAL
    case 0x2502: return 0x81; // BOX DRAWINGS LIGHT VERTICAL
    case 0x250c: return 0x82; // BOX DRAWINGS LIGHT DOWN AND RIGHT
    case 0x2510: return 0x83; // BOX DRAWINGS LIGHT DOWN AND LEFT
    case 0x2514: return 0x84; // BOX DRAWINGS LIGHT UP AND RIGHT
    case 0x2518: return 0x85; // BOX DRAWINGS LIGHT UP AND LEFT
    case 0x251c: return 0x86; // BOX DRAWINGS LIGHT VERTICAL AND RIGHT
    case 0x2524: return 0x87; // BOX DRAWINGS LIGHT VERTICAL AND LEFT
    case 0x252c: return 0x88; // BOX DRAWINGS LIGHT DOWN AND HORIZONTAL
    case 0x2534: return 0x89; // BOX DRAWINGS LIGHT UP AND HORIZONTAL
    case 0x253c: return 0x8A; // BOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL
    case 0x2580: return 0x8B; // UPPER HALF BLOCK
    case 0x2584: return 0x8C; // LOWER HALF BLOCK
    case 0x2588: return 0x8D; // FULL BLOCK
    case 0x258c: return 0x8E; // LEFT HALF BLOCK
    case 0x2590: return 0x8F; // RIGHT HALF BLOCK
    case 0x2591: return 0x90; // LIGHT SHADE
    case 0x2592: return 0x91; // MEDIUM SHADE
    case 0x2593: return 0x92; // DARK SHADE
    case 0x2320: return 0x93; // TOP HALF INTEGRAL
    case 0x25a0: return 0x94; // BLACK SQUARE
    case 0x2219: return 0x95; // BULLET OPERATOR
    case 0x221a: return 0x96; // SQUARE ROOT
    case 0x2248: return 0x97; // ALMOST EQUAL TO
    case 0x2264: return 0x98; // LESS-THAN OR EQUAL TO
    case 0x2265: return 0x99; // GREATER-THAN OR EQUAL TO
    case 0x00a0: return 0x9A; // NO-BREAK SPACE
    case 0x2321: return 0x9B; // BOTTOM HALF INTEGRAL
    case 0x00b0: return 0x9C; // DEGREE SIGN
    case 0x00b2: return 0x9D; // SUPERSCRIPT TWO
    case 0x00b7: return 0x9E; // MIDDLE DOT
    case 0x00f7: return 0x9F; // DIVISION SIGN
    case 0x2550: return 0xA0; // BOX DRAWINGS DOUBLE HORIZONTAL
    case 0x2551: return 0xA1; // BOX DRAWINGS DOUBLE VERTICAL
    case 0x2552: return 0xA2; // BOX DRAWINGS DOWN SINGLE AND RIGHT DOUBLE
    case 0x2554: return 0xA5; // BOX DRAWINGS DOUBLE DOWN AND RIGHT
    case 0x2557: return 0xA8; // BOX DRAWINGS DOUBLE DOWN AND LEFT
    case 0x2558: return 0xA9; // BOX DRAWINGS UP SINGLE AND RIGHT DOUBLE
    case 0x2559: return 0xAA; // BOX DRAWINGS UP DOUBLE AND RIGHT SINGLE
    case 0x255a: return 0xAB; // BOX DRAWINGS DOUBLE UP AND RIGHT
    case 0x255b: return 0xAC; // BOX DRAWINGS UP SINGLE AND LEFT DOUBLE
    case 0x255d: return 0xAE; // BOX DRAWINGS DOUBLE UP AND LEFT
    case 0x255e: return 0xAF; // BOX DRAWINGS VERTICAL SINGLE AND RIGHT DOUBLE
    case 0x255f: return 0xB0; // BOX DRAWINGS VERTICAL DOUBLE AND RIGHT SINGLE
    case 0x2560: return 0xB1; // BOX DRAWINGS DOUBLE VERTICAL AND RIGHT
    case 0x2561: return 0xB2; // BOX DRAWINGS VERTICAL SINGLE AND LEFT DOUBLE
    case 0x2563: return 0xB5; // BOX DRAWINGS DOUBLE VERTICAL AND LEFT
    case 0x2566: return 0xB8; // BOX DRAWINGS DOUBLE DOWN AND HORIZONTAL
    case 0x2567: return 0xB9; // BOX DRAWINGS UP SINGLE AND HORIZONTAL DOUBLE
    case 0x2568: return 0xBA; // BOX DRAWINGS UP DOUBLE AND HORIZONTAL SINGLE
    case 0x2569: return 0xBB; // BOX DRAWINGS DOUBLE UP AND HORIZONTAL
    case 0x256a: return 0xBC; // BOX DRAWINGS VERTICAL SINGLE AND HORIZONTAL DOUBLE
    case 0x256c: return 0xBE; // BOX DRAWINGS DOUBLE VERTICAL AND HORIZONTAL
    case 0x00a9: return 0xBF; // COPYRIGHT SIGN
    //
    case 0x2562: return 0xB4; // BOX DRAWINGS DOUBLE VERTICAL AND LEFT SINGLE
    case 0x2564: return 0xB6; // BOX DRAWINGS DOWN SINGLE AND DOUBLE HORIZONTAL
    case 0x2565: return 0xB7; // BOX DRAWINGS DOWN DOUBLE AND SINGLE HORIZONTAL
    case 0x256B: return 0xBD; // BOX DRAWINGS DOUBLE VERTICAL AND HORIZONTAL SINGLE
    default:
  }
  return 0;
}


// convert koi8-u to unicode
public dchar koi2uni() (char ch) pure nothrow @trusted @nogc {
  pragma(inline, true);
  return (ch < 128 ? ch : koi2uniTable.ptr[cast(ubyte)ch-128]);
}
