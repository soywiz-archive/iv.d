/* Invisible Vector Library
 * coded by Ketmar // Invisible Vector <ketmar@ketmar.no-ip.org>
 * Understanding is not required. Only obedience.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
module tweetNaCl_test;

void main () {
  import iv.tweetNaCl;
  import std.exception;
  import std.range;
  import std.stdio;

  //private extern(C) int open(const(char)* filename, int flags, ...);
  randombytes = (ubyte[] dest) @trusted nothrow @nogc {
    version(Posix) {
      import core.sys.posix.unistd : close, read, sleep;
      import core.sys.posix.fcntl : open, O_RDONLY;
      static int fd = -1;
      if (fd == -1) {
        for (;;) {
          fd = open("/dev/urandom", O_RDONLY);
          if (fd != -1) break;
          sleep(1);
        }
      }
      size_t pos = 0;
      size_t len = dest.length;
      while (len > 0) {
        auto i = read(fd, cast(void*)(&dest[pos]), (len < 1048576 ? len : 1048576));
        if (i < 1) {
          sleep(1);
          continue;
        }
        pos += i;
        len -= i;
      }
    } else {
      import std.random : uniform;
      foreach (ref b; dest) b = cast(ubyte)uniform(0, 256);
    }
  };

  void dumpArray(T) (T[] arr) {
    writefln("============================= (%s)", arr.length);
    for (auto f = 0; f < arr.length; ++f) {
      if (f && f%16 == 0) writeln();
      static if (T.sizeof == 1) writef(" 0x%02x", arr[f]);
      else static if (T.sizeof == 2) writef(" 0x%04x", arr[f]);
      else static if (T.sizeof == 4) writef(" 0x%08x", arr[f]);
      else writef(" 0x%08x", arr[f]);
    }
    writeln();
    writeln("-----------------------------");
  }

  string hashToString (const(ubyte)[] hash) {
    char[] s;
    s.length = hash.length*2;
    char toHex(int a) { return cast(char)(a < 10 ? a+'0' : a+'a'-10); }
    for (int a = 0; a < hash.length; ++a) {
      s[a*2] = toHex(hash[a]>>4);
      s[a*2+1] = toHex(hash[a]&0x0f);
    }
    return assumeUnique(s);
  }

  static immutable ubyte[crypto_sign_PUBLICKEYBYTES] pk = [0x8f,0x58,0xd8,0xbf,0xb1,0x92,0xd1,0xd7,0xe0,0xc3,0x99,0x8a,0x8d,0x5c,0xb5,0xef,0xfc,0x92,0x2a,0x0d,0x70,0x80,0xe8,0x3b,0xe0,0x27,0xeb,0xf6,0x14,0x95,0xfd,0x16];
  static immutable ubyte[crypto_sign_SECRETKEYBYTES] sk = [0x78,0x34,0x09,0x59,0x54,0xaa,0xa9,0x2c,0x52,0x3a,0x41,0x3f,0xb6,0xfa,0x6b,0xe1,0xd7,0x0f,0x39,0x30,0x5a,0xe1,0x70,0x12,0x59,0x7d,0x32,0x59,0x9b,0x8b,0x6b,0x2f, 0x8f,0x58,0xd8,0xbf,0xb1,0x92,0xd1,0xd7,0xe0,0xc3,0x99,0x8a,0x8d,0x5c,0xb5,0xef,0xfc,0x92,0x2a,0x0d,0x70,0x80,0xe8,0x3b,0xe0,0x27,0xeb,0xf6,0x14,0x95,0xfd,0x16];
  static immutable ubyte[5] m = [0x61,0x68,0x6f,0x6a,0x0a];
  static immutable ubyte[69] sm = [0xce,0x1e,0x15,0xad,0xc3,0x17,0x47,0x15,0x7d,0x44,0x60,0xc1,0x7f,0xb8,0xba,0x45,0xf3,0x6d,0x0b,0xbf,0x51,0xf9,0xbb,0x6b,0xb9,0xa1,0xd2,0x4e,0x44,0x8d,0x9e,0x8c,0x36,0x6f,0x7a,0x8b,0x5e,0x2c,0x69,0xba,0x90,0x2e,0x95,0x46,0x19,0xd8,0xc1,0x8a,0x47,0xc5,0x6e,0x4a,0x28,0x9e,0x81,0x17,0xae,0x90,0x69,0x71,0x7d,0x84,0x6a,0x01,0x61,0x68,0x6f,0x6a,0x0a];
  ubyte[] smres, t;

  writeln("crypto_sign");
  smres = crypto_sign(m, sk);
  assert(smres.length == sm.length);
  assert(smres == sm);

  writeln("crypto_sign_open");
  t = crypto_sign_open(smres, pk);
  assert(t !is null);
  assert(t.length == m.length);
  assert(t == m);


  // based on the code by Adam D. Ruppe
  // This does the preprocessing of input data, fetching one byte at a time of the data until it is empty, then the padding and length at the end
  template SHARange(T) if (isInputRange!(T)) {
    struct SHARange {
      T r;

      bool empty () { return state == 5; }

      void popFront () {
        if (state == 0) {
          r.popFront;
          ++length; // FIXME
          if (r.empty) {
            state = 1;
            position = 2;
            current = 0x80;
          }
        } else {
          bool hackforward = false;
          if (state == 1) {
            current = 0x0;
            state = 2;
            if (((position+length+8)*8)%512 == 8) {
              --position;
              hackforward = true;
            }
            goto proceed;
            //++position;
          } else if (state == 2) {
          proceed:
            if (!(((position+length+8)*8)%512)) {
              state = 3;
              position = 7;
              length *= 8;
              if (hackforward) goto proceedmoar;
            } else {
              ++position;
            }
          } else if (state == 3) {
          proceedmoar:
            current = (length>>(position*8))&0xff;
            if (position == 0) state = 4; else --position;
          } else if (state == 4) {
            current = 0xff;
            state = 5;
          }
        }
      }

      ubyte front () {
        if (state == 0) return cast(ubyte)r.front;
        assert(state != 5);
        //writefln("%x", current);
        return current;
      }

      ubyte current;
      uint position;
      ulong length;
      int state = 0; // reading range, reading appended bit, reading padding, reading length, done
    }
  }


  immutable(ubyte)[] SHA256(T) (T data) if (isInputRange!(T)) {
    uint[8] h = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];
    static immutable(uint[64]) k = [
      0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
    ];


    SHARange!(T) range;
    static if (is(data == SHARange)) range = data; else range.r = data;


    while(!range.empty) {
      uint[64] words;

      for(int a = 0; a < 16; ++a) {
        for(int b = 3; b >= 0; --b) {
          words[a] |= cast(uint)(range.front())<<(b*8);
          range.popFront;
        }
      }

      uint ror (uint n, int cnt) {
        return cast(uint)(n>>cnt)|cast(uint)(n<<(32-(cnt)));
      }

      uint xrot00 (uint reax, int r0, int r1, int r2) {
        uint rebx = reax, recx = reax;
        reax = ror(reax, r0);
        rebx = ror(rebx, r1);
        recx >>= r2;
        reax ^= rebx;
        reax ^= recx;
        return reax;
      }

      for(int a = 16; a < 64; ++a) {
        uint t1 = xrot00(words[a-15], 7, 18, 3);
        uint t2 = xrot00(words[a-2], 17, 19, 10);
        words[a] = words[a-16]+t1+words[a-7]+t2;
      }

      uint A = h[0];
      uint B = h[1];
      uint C = h[2];
      uint D = h[3];
      uint E = h[4];
      uint F = h[5];
      uint G = h[6];
      uint H = h[7];

      uint xrot01 (uint reax, int r0, int r1, int r2) {
        uint rebx = reax, recx = reax;
        reax = ror(reax, r0);
        rebx = ror(rebx, r1);
        recx = ror(recx, r2);
        reax ^= rebx;
        reax ^= recx;
        return reax;
      }

      for(int i = 0; i < 64; ++i) {
        uint s0 = xrot01(A, 2, 13, 22);
        uint maj = (A&B)^(A&C)^(B&C);
        uint t2 = s0+maj;
        uint s1 = xrot01(E, 6, 11, 25);
        uint ch = (E&F)^((~E)&G);
        uint t1 = H+s1+ch+k[i]+words[i];

        H = G;
        G = F;
        F = E;
        E = D+t1;
        D = C;
        C = B;
        B = A;
        A = t1+t2;
      }

      h[0] += A;
      h[1] += B;
      h[2] += C;
      h[3] += D;
      h[4] += E;
      h[5] += F;
      h[6] += G;
      h[7] += H;
    }

    ubyte[] hash;
    for(int j = 0; j < 8; ++j)
    for(int i = 3; i >= 0; --i) {
      hash ~= cast(ubyte)(h[j]>>(i*8))&0xff;
    }

    return hash.idup;
  }


  void box () {
    writeln("box");

    static immutable ubyte[32] alicesk = [
     0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d
    ,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45
    ,0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a
    ,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a
    ];

    static immutable ubyte[32] bobpk = [
     0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4
    ,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37
    ,0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d
    ,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f
    ];

    static immutable ubyte[24] nonce = [
     0x69,0x69,0x6e,0xe9,0x55,0xb6,0x2b,0x73
    ,0xcd,0x62,0xbd,0xa8,0x75,0xfc,0x73,0xd6
    ,0x82,0x19,0xe0,0x03,0x6b,0x7a,0x0b,0x37
    ];

    // API requires first 32 bytes to be 0
    static immutable ubyte[163] m = [
        0,   0,   0,   0,   0,   0,   0,   0
    ,   0,   0,   0,   0,   0,   0,   0,   0
    ,   0,   0,   0,   0,   0,   0,   0,   0
    ,   0,   0,   0,   0,   0,   0,   0,   0
    ,0xbe,0x07,0x5f,0xc5,0x3c,0x81,0xf2,0xd5
    ,0xcf,0x14,0x13,0x16,0xeb,0xeb,0x0c,0x7b
    ,0x52,0x28,0xc5,0x2a,0x4c,0x62,0xcb,0xd4
    ,0x4b,0x66,0x84,0x9b,0x64,0x24,0x4f,0xfc
    ,0xe5,0xec,0xba,0xaf,0x33,0xbd,0x75,0x1a
    ,0x1a,0xc7,0x28,0xd4,0x5e,0x6c,0x61,0x29
    ,0x6c,0xdc,0x3c,0x01,0x23,0x35,0x61,0xf4
    ,0x1d,0xb6,0x6c,0xce,0x31,0x4a,0xdb,0x31
    ,0x0e,0x3b,0xe8,0x25,0x0c,0x46,0xf0,0x6d
    ,0xce,0xea,0x3a,0x7f,0xa1,0x34,0x80,0x57
    ,0xe2,0xf6,0x55,0x6a,0xd6,0xb1,0x31,0x8a
    ,0x02,0x4a,0x83,0x8f,0x21,0xaf,0x1f,0xde
    ,0x04,0x89,0x77,0xeb,0x48,0xf5,0x9f,0xfd
    ,0x49,0x24,0xca,0x1c,0x60,0x90,0x2e,0x52
    ,0xf0,0xa0,0x89,0xbc,0x76,0x89,0x70,0x40
    ,0xe0,0x82,0xf9,0x37,0x76,0x38,0x48,0x64
    ,0x5e,0x07,0x05
    ];

    ubyte[163] c;


    static immutable ubyte[163] res = [
     0xf3,0xff,0xc7,0x70,0x3f,0x94,0x00,0xe5
    ,0x2a,0x7d,0xfb,0x4b,0x3d,0x33,0x05,0xd9
    ,0x8e,0x99,0x3b,0x9f,0x48,0x68,0x12,0x73
    ,0xc2,0x96,0x50,0xba,0x32,0xfc,0x76,0xce
    ,0x48,0x33,0x2e,0xa7,0x16,0x4d,0x96,0xa4
    ,0x47,0x6f,0xb8,0xc5,0x31,0xa1,0x18,0x6a
    ,0xc0,0xdf,0xc1,0x7c,0x98,0xdc,0xe8,0x7b
    ,0x4d,0xa7,0xf0,0x11,0xec,0x48,0xc9,0x72
    ,0x71,0xd2,0xc2,0x0f,0x9b,0x92,0x8f,0xe2
    ,0x27,0x0d,0x6f,0xb8,0x63,0xd5,0x17,0x38
    ,0xb4,0x8e,0xee,0xe3,0x14,0xa7,0xcc,0x8a
    ,0xb9,0x32,0x16,0x45,0x48,0xe5,0x26,0xae
    ,0x90,0x22,0x43,0x68,0x51,0x7a,0xcf,0xea
    ,0xbd,0x6b,0xb3,0x73,0x2b,0xc0,0xe9,0xda
    ,0x99,0x83,0x2b,0x61,0xca,0x01,0xb6,0xde
    ,0x56,0x24,0x4a,0x9e,0x88,0xd5,0xf9,0xb3
    ,0x79,0x73,0xf6,0x22,0xa4,0x3d,0x14,0xa6
    ,0x59,0x9b,0x1f,0x65,0x4c,0xb4,0x5a,0x74
    ,0xe3,0x55,0xa5];
    /*crypto_box_curve25519xsalsa20poly1305*/crypto_box(c, m, nonce, bobpk, alicesk);
    for (auto f = 16; f < 163; ++f) assert(c[f] == res[f-16]);
  }
  box();

  void box2 () {
    writeln("box2");
    static immutable ubyte[32] bobsk = [
     0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b
    ,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6
    ,0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd
    ,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb
    ];

    static immutable ubyte[32] alicepk = [
     0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54
    ,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a
    ,0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4
    ,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a
    ];

    static immutable ubyte[24] nonce = [
     0x69,0x69,0x6e,0xe9,0x55,0xb6,0x2b,0x73
    ,0xcd,0x62,0xbd,0xa8,0x75,0xfc,0x73,0xd6
    ,0x82,0x19,0xe0,0x03,0x6b,0x7a,0x0b,0x37
    ];

    // API requires first 16 bytes to be 0
    static immutable ubyte[163] c = [
        0,   0,   0,   0,   0,   0,   0,   0
    ,   0,   0,   0,   0,   0,   0,   0,   0
    ,0xf3,0xff,0xc7,0x70,0x3f,0x94,0x00,0xe5
    ,0x2a,0x7d,0xfb,0x4b,0x3d,0x33,0x05,0xd9
    ,0x8e,0x99,0x3b,0x9f,0x48,0x68,0x12,0x73
    ,0xc2,0x96,0x50,0xba,0x32,0xfc,0x76,0xce
    ,0x48,0x33,0x2e,0xa7,0x16,0x4d,0x96,0xa4
    ,0x47,0x6f,0xb8,0xc5,0x31,0xa1,0x18,0x6a
    ,0xc0,0xdf,0xc1,0x7c,0x98,0xdc,0xe8,0x7b
    ,0x4d,0xa7,0xf0,0x11,0xec,0x48,0xc9,0x72
    ,0x71,0xd2,0xc2,0x0f,0x9b,0x92,0x8f,0xe2
    ,0x27,0x0d,0x6f,0xb8,0x63,0xd5,0x17,0x38
    ,0xb4,0x8e,0xee,0xe3,0x14,0xa7,0xcc,0x8a
    ,0xb9,0x32,0x16,0x45,0x48,0xe5,0x26,0xae
    ,0x90,0x22,0x43,0x68,0x51,0x7a,0xcf,0xea
    ,0xbd,0x6b,0xb3,0x73,0x2b,0xc0,0xe9,0xda
    ,0x99,0x83,0x2b,0x61,0xca,0x01,0xb6,0xde
    ,0x56,0x24,0x4a,0x9e,0x88,0xd5,0xf9,0xb3
    ,0x79,0x73,0xf6,0x22,0xa4,0x3d,0x14,0xa6
    ,0x59,0x9b,0x1f,0x65,0x4c,0xb4,0x5a,0x74
    ,0xe3,0x55,0xa5
    ];

    ubyte[163] m;

    static immutable ubyte[163] res = [
     0xbe,0x07,0x5f,0xc5,0x3c,0x81,0xf2,0xd5
    ,0xcf,0x14,0x13,0x16,0xeb,0xeb,0x0c,0x7b
    ,0x52,0x28,0xc5,0x2a,0x4c,0x62,0xcb,0xd4
    ,0x4b,0x66,0x84,0x9b,0x64,0x24,0x4f,0xfc
    ,0xe5,0xec,0xba,0xaf,0x33,0xbd,0x75,0x1a
    ,0x1a,0xc7,0x28,0xd4,0x5e,0x6c,0x61,0x29
    ,0x6c,0xdc,0x3c,0x01,0x23,0x35,0x61,0xf4
    ,0x1d,0xb6,0x6c,0xce,0x31,0x4a,0xdb,0x31
    ,0x0e,0x3b,0xe8,0x25,0x0c,0x46,0xf0,0x6d
    ,0xce,0xea,0x3a,0x7f,0xa1,0x34,0x80,0x57
    ,0xe2,0xf6,0x55,0x6a,0xd6,0xb1,0x31,0x8a
    ,0x02,0x4a,0x83,0x8f,0x21,0xaf,0x1f,0xde
    ,0x04,0x89,0x77,0xeb,0x48,0xf5,0x9f,0xfd
    ,0x49,0x24,0xca,0x1c,0x60,0x90,0x2e,0x52
    ,0xf0,0xa0,0x89,0xbc,0x76,0x89,0x70,0x40
    ,0xe0,0x82,0xf9,0x37,0x76,0x38,0x48,0x64
    ,0x5e,0x07,0x05
    ];

    assert(/*crypto_box_curve25519xsalsa20poly1305_open*/crypto_box_open(m, c, nonce, alicepk, bobsk));
    for (auto f = 32; f < 163; ++f) assert(m[f] == res[f-32]);
  }
  box2();

  void box7 () {
    writeln("box7");
    ubyte[crypto_box_SECRETKEYBYTES] alicesk;
    ubyte[crypto_box_PUBLICKEYBYTES] alicepk;
    ubyte[crypto_box_SECRETKEYBYTES] bobsk;
    ubyte[crypto_box_PUBLICKEYBYTES] bobpk;
    ubyte[crypto_box_NONCEBYTES] n;
    ubyte[10000] m, c, m2;
    for (auto mlen = 0; mlen < 1000 && mlen+crypto_box_ZEROBYTES < m.length; ++mlen) {
      crypto_box_keypair(alicepk, alicesk);
      crypto_box_keypair(bobpk, bobsk);
      randombytes(n[0..crypto_box_NONCEBYTES]);
      randombytes(m[crypto_box_ZEROBYTES..crypto_box_ZEROBYTES+mlen]);
      crypto_box(c[0..mlen+crypto_box_ZEROBYTES], m[0..crypto_box_ZEROBYTES+mlen], n, bobpk, alicesk);
      assert(crypto_box_open(m2[0..mlen+crypto_box_ZEROBYTES], c[0..mlen+crypto_box_ZEROBYTES], n, alicepk, bobsk));
      for (auto i = 0; i < mlen+crypto_box_ZEROBYTES; ++i) assert(m2[i] == m[i]);
    }
  }
  version(unittest_full) box7(); // it's slow

  void box8 () {
    writeln("box8");
    ubyte[crypto_box_SECRETKEYBYTES] alicesk;
    ubyte[crypto_box_PUBLICKEYBYTES] alicepk;
    ubyte[crypto_box_SECRETKEYBYTES] bobsk;
    ubyte[crypto_box_PUBLICKEYBYTES] bobpk;
    ubyte[crypto_box_NONCEBYTES] n;
    ubyte[10000] m, c, m2;
    for (auto mlen = 0; mlen < 1000 && mlen+crypto_box_ZEROBYTES < m.length; ++mlen) {
      crypto_box_keypair(alicepk, alicesk);
      crypto_box_keypair(bobpk, bobsk);
      randombytes(n[0..crypto_box_NONCEBYTES]);
      randombytes(m[crypto_box_ZEROBYTES..crypto_box_ZEROBYTES+mlen]);
      crypto_box(c[0..mlen+crypto_box_ZEROBYTES], m, n, bobpk, alicesk);
      int caught = 0;
      while (caught < 10) {
        import std.random : uniform;
        c[uniform(0, mlen+crypto_box_ZEROBYTES)] = cast(ubyte)uniform(0, 256);
        if (crypto_box_open(m2[0..mlen+crypto_box_ZEROBYTES], c, n, alicepk, bobsk)) {
          for (auto i = 0; i < mlen+crypto_box_ZEROBYTES; ++i) assert(m2[i] == m[i]);
        } else {
          ++caught;
        }
      }
      assert(caught == 10);
    }
  }
  version(unittest_full) box8(); // it's slow

  void core1 () {
    writeln("core1");
    static immutable ubyte[32] shared_ = [
     0x4a,0x5d,0x9d,0x5b,0xa4,0xce,0x2d,0xe1
    ,0x72,0x8e,0x3b,0xf4,0x80,0x35,0x0f,0x25
    ,0xe0,0x7e,0x21,0xc9,0x47,0xd1,0x9e,0x33
    ,0x76,0xf0,0x9b,0x3c,0x1e,0x16,0x17,0x42
    ];

    static immutable ubyte[32] zero = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];

    static immutable ubyte[16] c = [
     0x65,0x78,0x70,0x61,0x6e,0x64,0x20,0x33
    ,0x32,0x2d,0x62,0x79,0x74,0x65,0x20,0x6b
    ];

    ubyte[32] firstkey;

    static immutable ubyte[32] res = [
     0x1b,0x27,0x55,0x64,0x73,0xe9,0x85,0xd4
    ,0x62,0xcd,0x51,0x19,0x7a,0x9a,0x46,0xc7
    ,0x60,0x09,0x54,0x9e,0xac,0x64,0x74,0xf2
    ,0x06,0xc4,0xee,0x08,0x44,0xf6,0x83,0x89
    ];

    crypto_core_hsalsa20(firstkey, zero, shared_, c);
    assert(firstkey == res);
  }
  core1();

  void core2 () {
    writeln("core2");
    static immutable ubyte[32]firstkey = [
     0x1b,0x27,0x55,0x64,0x73,0xe9,0x85,0xd4
    ,0x62,0xcd,0x51,0x19,0x7a,0x9a,0x46,0xc7
    ,0x60,0x09,0x54,0x9e,0xac,0x64,0x74,0xf2
    ,0x06,0xc4,0xee,0x08,0x44,0xf6,0x83,0x89
    ];

    static immutable ubyte[16]nonceprefix = [
     0x69,0x69,0x6e,0xe9,0x55,0xb6,0x2b,0x73
    ,0xcd,0x62,0xbd,0xa8,0x75,0xfc,0x73,0xd6
    ];

    static immutable ubyte[16] c = [
     0x65,0x78,0x70,0x61,0x6e,0x64,0x20,0x33
    ,0x32,0x2d,0x62,0x79,0x74,0x65,0x20,0x6b
    ];

    ubyte[32] secondkey;

    static immutable ubyte[32] res = [
     0xdc,0x90,0x8d,0xda,0x0b,0x93,0x44,0xa9
    ,0x53,0x62,0x9b,0x73,0x38,0x20,0x77,0x88
    ,0x80,0xf3,0xce,0xb4,0x21,0xbb,0x61,0xb9
    ,0x1c,0xbd,0x4c,0x3e,0x66,0x25,0x6c,0xe4
    ];

    crypto_core_hsalsa20(secondkey, nonceprefix, firstkey, c);
    assert(secondkey == res);
  }
  core2();

  void core3 () {
    writeln("core3");
    static immutable ubyte[32] secondkey = [
     0xdc,0x90,0x8d,0xda,0x0b,0x93,0x44,0xa9
    ,0x53,0x62,0x9b,0x73,0x38,0x20,0x77,0x88
    ,0x80,0xf3,0xce,0xb4,0x21,0xbb,0x61,0xb9
    ,0x1c,0xbd,0x4c,0x3e,0x66,0x25,0x6c,0xe4
    ];

    static immutable ubyte[8] noncesuffix = [
     0x82,0x19,0xe0,0x03,0x6b,0x7a,0x0b,0x37
    ];

    static immutable ubyte[16] c = [
     0x65,0x78,0x70,0x61,0x6e,0x64,0x20,0x33
    ,0x32,0x2d,0x62,0x79,0x74,0x65,0x20,0x6b
    ];

    static ubyte[16] input = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];

    static ubyte[64*256*256] output;

    static ubyte[64] h;

    static immutable ubyte[64] res = [0x2b,0xd8,0xe7,0xdb,0x68,0x77,0x53,0x9e,0x4f,0x2b,0x29,0x5e,0xe4,0x15,0xcd,0x37,0x8a,0xe2,0x14,0xaa,0x3b,0xeb,0x3e,0x08,0xe9,0x11,0xa5,0xbd,0x4a,0x25,0xe6,0xac,0x16,0xca,0x28,0x3c,0x79,0xc3,0x4c,0x08,0xc9,0x9f,0x7b,0xdb,0x56,0x01,0x11,0xe8,0xca,0xc1,0xae,0x65,0xee,0xa0,0x8a,0xc3,0x84,0xd7,0xa5,0x91,0x46,0x1a,0xb6,0xe3];

    int pos = 0;
    for (auto i = 0; i < 8; ++i) input[i] = noncesuffix[i];
    do {
      do {
        crypto_core_salsa20(output[pos..$], input, secondkey, c);
        pos += 64;
      } while (++input[8]);
    } while (++input[9]);
    crypto_hash(h, output);
    assert(h == res);
  }
  version(unittest_full) core3(); // it's slow

  void core4 () {
    writeln("core4");
    static immutable ubyte[32] k = [
       1,  2,  3,  4,  5,  6,  7,  8
    ,  9, 10, 11, 12, 13, 14, 15, 16
    ,201,202,203,204,205,206,207,208
    ,209,210,211,212,213,214,215,216
    ];

    static immutable ubyte[16] input = [
     101,102,103,104,105,106,107,108
    ,109,110,111,112,113,114,115,116
    ];

    static immutable ubyte[16] c = [
     101,120,112, 97,110,100, 32, 51
    , 50, 45, 98,121,116,101, 32,107
    ];

    ubyte[64] output;

    static immutable ubyte[64] res = [
      69, 37, 68, 39, 41, 15,107,193
    ,255,139,122,  6,170,233,217, 98
    , 89,144,182,106, 21, 51,200, 65
    ,239, 49,222, 34,215,114, 40,126
    ,104,197,  7,225,197,153, 31,  2
    ,102, 78, 76,176, 84,245,246,184
    ,177,160,133,130,  6, 72,149,119
    ,192,195,132,236,234,103,246, 74
    ];

    crypto_core_salsa20(output, input, k, c);
    assert(output == res);
  }
  core4();

  void core5 () {
    writeln("core5");
    static immutable ubyte[32] k = [
     0xee,0x30,0x4f,0xca,0x27,0x00,0x8d,0x8c
    ,0x12,0x6f,0x90,0x02,0x79,0x01,0xd8,0x0f
    ,0x7f,0x1d,0x8b,0x8d,0xc9,0x36,0xcf,0x3b
    ,0x9f,0x81,0x96,0x92,0x82,0x7e,0x57,0x77
    ];

    static immutable ubyte[16] input = [
     0x81,0x91,0x8e,0xf2,0xa5,0xe0,0xda,0x9b
    ,0x3e,0x90,0x60,0x52,0x1e,0x4b,0xb3,0x52
    ];

    static immutable ubyte[16] c = [
     101,120,112, 97,110,100, 32, 51
    , 50, 45, 98,121,116,101, 32,107
    ];

    ubyte[32] output;

    static immutable ubyte[32] res = [
     0xbc,0x1b,0x30,0xfc,0x07,0x2c,0xc1,0x40
    ,0x75,0xe4,0xba,0xa7,0x31,0xb5,0xa8,0x45
    ,0xea,0x9b,0x11,0xe9,0xa5,0x19,0x1f,0x94
    ,0xe1,0x8c,0xba,0x8f,0xd8,0x21,0xa7,0xcd
    ];

    crypto_core_hsalsa20(output, input, k, c);
    assert(output == res);
  }
  core5();

  void core6 () {
    writeln("core6");
    static immutable ubyte[32] k = [
     0xee,0x30,0x4f,0xca,0x27,0x00,0x8d,0x8c
    ,0x12,0x6f,0x90,0x02,0x79,0x01,0xd8,0x0f
    ,0x7f,0x1d,0x8b,0x8d,0xc9,0x36,0xcf,0x3b
    ,0x9f,0x81,0x96,0x92,0x82,0x7e,0x57,0x77
    ];

    static immutable ubyte[16] input = [
     0x81,0x91,0x8e,0xf2,0xa5,0xe0,0xda,0x9b
    ,0x3e,0x90,0x60,0x52,0x1e,0x4b,0xb3,0x52
    ];

    static immutable ubyte[16] c = [
     101,120,112, 97,110,100, 32, 51
    , 50, 45, 98,121,116,101, 32,107
    ];

    ubyte[64] output;

    static immutable ubyte[32] res = [
     0xbc,0x1b,0x30,0xfc,0x07,0x2c,0xc1,0x40
    ,0x75,0xe4,0xba,0xa7,0x31,0xb5,0xa8,0x45
    ,0xea,0x9b,0x11,0xe9,0xa5,0x19,0x1f,0x94
    ,0xe1,0x8c,0xba,0x8f,0xd8,0x21,0xa7,0xcd
    ];

    ubyte[32] pp;
    uint pppos = 0;

    void print(const(ubyte)[] x, const(ubyte)[] y)
    {
      uint borrow = 0;
      for (auto i = 0; i < 4; ++i) {
        uint xi = x[i];
        uint yi = y[i];
        //printf(",0x%02x",255&(xi-yi-borrow));
        pp[pppos++] = cast(ubyte)(255&(xi-yi-borrow));
        borrow = (xi < yi+borrow);
      }
    }

    crypto_core_salsa20(output, input, k, c);
    print(output, c);
    print(output[20..$], c[4..$]);
    print(output[40..$], c[8..$]);
    print(output[60..$], c[12..$]);
    print(output[24..$], input);
    print(output[28..$], input[4..$]);
    print(output[32..$], input[8..$]);
    print(output[36..$], input[12..$]);
    assert(pp == res);
  }
  core6();

  void hash () {
    writeln("hash");
    static immutable ubyte[8] x = ['t','e','s','t','i','n','g','\n'];
    static ubyte[crypto_hash_BYTES] h;
    static immutable ubyte[crypto_hash_BYTES] res = [0x24,0xf9,0x50,0xaa,0xc7,0xb9,0xea,0x9b,0x3c,0xb7,0x28,0x22,0x8a,0x0c,0x82,0xb6,0x7c,0x39,0xe9,0x6b,0x4b,0x34,0x47,0x98,0x87,0x0d,0x5d,0xae,0xe9,0x3e,0x3a,0xe5,0x93,0x1b,0xaa,0xe8,0xc7,0xca,0xcf,0xea,0x4b,0x62,0x94,0x52,0xc3,0x80,0x26,0xa8,0x1d,0x13,0x8b,0xc7,0xaa,0xd1,0xaf,0x3e,0xf7,0xbf,0xd5,0xec,0x64,0x6d,0x6c,0x28];
    crypto_hash(h, x);
    //for (auto f = 0; f < crypto_hash_BYTES; ++f) assert(h[f] == res[f]);
    assert(h == res);
  }
  hash();

  void onetimeauth () {
    writeln("onetimeauth");
    static immutable ubyte[32] rs = [
     0xee,0xa6,0xa7,0x25,0x1c,0x1e,0x72,0x91
    ,0x6d,0x11,0xc2,0xcb,0x21,0x4d,0x3c,0x25
    ,0x25,0x39,0x12,0x1d,0x8e,0x23,0x4e,0x65
    ,0x2d,0x65,0x1f,0xa4,0xc8,0xcf,0xf8,0x80
    ];

    static immutable ubyte[131] c = [
     0x8e,0x99,0x3b,0x9f,0x48,0x68,0x12,0x73
    ,0xc2,0x96,0x50,0xba,0x32,0xfc,0x76,0xce
    ,0x48,0x33,0x2e,0xa7,0x16,0x4d,0x96,0xa4
    ,0x47,0x6f,0xb8,0xc5,0x31,0xa1,0x18,0x6a
    ,0xc0,0xdf,0xc1,0x7c,0x98,0xdc,0xe8,0x7b
    ,0x4d,0xa7,0xf0,0x11,0xec,0x48,0xc9,0x72
    ,0x71,0xd2,0xc2,0x0f,0x9b,0x92,0x8f,0xe2
    ,0x27,0x0d,0x6f,0xb8,0x63,0xd5,0x17,0x38
    ,0xb4,0x8e,0xee,0xe3,0x14,0xa7,0xcc,0x8a
    ,0xb9,0x32,0x16,0x45,0x48,0xe5,0x26,0xae
    ,0x90,0x22,0x43,0x68,0x51,0x7a,0xcf,0xea
    ,0xbd,0x6b,0xb3,0x73,0x2b,0xc0,0xe9,0xda
    ,0x99,0x83,0x2b,0x61,0xca,0x01,0xb6,0xde
    ,0x56,0x24,0x4a,0x9e,0x88,0xd5,0xf9,0xb3
    ,0x79,0x73,0xf6,0x22,0xa4,0x3d,0x14,0xa6
    ,0x59,0x9b,0x1f,0x65,0x4c,0xb4,0x5a,0x74
    ,0xe3,0x55,0xa5
    ];

    ubyte[16] a;

    static immutable ubyte[16] res = [0xf3,0xff,0xc7,0x70,0x3f,0x94,0x00,0xe5,0x2a,0x7d,0xfb,0x4b,0x3d,0x33,0x05,0xd9];

    /*crypto_onetimeauth_poly1305*/crypto_onetimeauth(a, c, rs);
    assert(a == res);
  }
  onetimeauth();

  void onetimeauth2 () {
    writeln("onetimeauth2");
    static immutable ubyte[32] rs = [
     0xee,0xa6,0xa7,0x25,0x1c,0x1e,0x72,0x91
    ,0x6d,0x11,0xc2,0xcb,0x21,0x4d,0x3c,0x25
    ,0x25,0x39,0x12,0x1d,0x8e,0x23,0x4e,0x65
    ,0x2d,0x65,0x1f,0xa4,0xc8,0xcf,0xf8,0x80
    ];

    static immutable ubyte[131] c = [
     0x8e,0x99,0x3b,0x9f,0x48,0x68,0x12,0x73
    ,0xc2,0x96,0x50,0xba,0x32,0xfc,0x76,0xce
    ,0x48,0x33,0x2e,0xa7,0x16,0x4d,0x96,0xa4
    ,0x47,0x6f,0xb8,0xc5,0x31,0xa1,0x18,0x6a
    ,0xc0,0xdf,0xc1,0x7c,0x98,0xdc,0xe8,0x7b
    ,0x4d,0xa7,0xf0,0x11,0xec,0x48,0xc9,0x72
    ,0x71,0xd2,0xc2,0x0f,0x9b,0x92,0x8f,0xe2
    ,0x27,0x0d,0x6f,0xb8,0x63,0xd5,0x17,0x38
    ,0xb4,0x8e,0xee,0xe3,0x14,0xa7,0xcc,0x8a
    ,0xb9,0x32,0x16,0x45,0x48,0xe5,0x26,0xae
    ,0x90,0x22,0x43,0x68,0x51,0x7a,0xcf,0xea
    ,0xbd,0x6b,0xb3,0x73,0x2b,0xc0,0xe9,0xda
    ,0x99,0x83,0x2b,0x61,0xca,0x01,0xb6,0xde
    ,0x56,0x24,0x4a,0x9e,0x88,0xd5,0xf9,0xb3
    ,0x79,0x73,0xf6,0x22,0xa4,0x3d,0x14,0xa6
    ,0x59,0x9b,0x1f,0x65,0x4c,0xb4,0x5a,0x74
    ,0xe3,0x55,0xa5
    ];

    static immutable ubyte[16] a = [
     0xf3,0xff,0xc7,0x70,0x3f,0x94,0x00,0xe5
    ,0x2a,0x7d,0xfb,0x4b,0x3d,0x33,0x05,0xd9
    ];

    assert(/*crypto_onetimeauth_poly1305_verify*/crypto_onetimeauth_verify(a, c, rs));
  }
  onetimeauth2();

  void onetimeauth7 () {
    writeln("onetimeauth7");
    static ubyte[32] key;
    static ubyte[10000] c;
    static ubyte[16] a;

    for (auto clen = 0; clen < 10000; ++clen) {
      //if (clen%512 == 0) { writef("\r%s", clen); stdout.flush(); }
      randombytes(key);
      randombytes(c[0..clen]);
      crypto_onetimeauth(a, c[0..clen], key);
      assert(crypto_onetimeauth_verify(a, c[0..clen], key));
      if (clen > 0) {
        import std.random : uniform;
        c[uniform(0, clen)] += 1+(uniform(0, 255));
        assert(!crypto_onetimeauth_verify(a, c[0..clen], key));
        a[uniform(0, a.length)] += 1+(uniform(0, 255));
        assert(!crypto_onetimeauth_verify(a, c[0..clen], key));
      }
    }
  }
  version(unittest_full) onetimeauth7(); // it's slow

  void scalarmult () {
    writeln("scalarmult");
    static immutable ubyte[32] alicesk = [
     0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d
    ,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45
    ,0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a
    ,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a
    ];

    ubyte[32] alicepk;

    static immutable ubyte[32] res = [
     0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54
    ,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a
    ,0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4
    ,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a
    ];

    /*crypto_scalarmult_curve25519_base*/crypto_scalarmult_base(alicepk, alicesk);
    assert(alicepk == res);
  }
  scalarmult();

  void scalarmult2 () {
    writeln("scalarmult2");
    static immutable ubyte[32] bobsk = [
     0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b
    ,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6
    ,0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd
    ,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb
    ];

    ubyte[32] bobpk;

    static immutable ubyte[32] res = [
     0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4
    ,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37
    ,0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d
    ,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f
    ];

    /*crypto_scalarmult_curve25519_base*/crypto_scalarmult_base(bobpk, bobsk);
    assert(bobpk == res);
  }
  scalarmult2();

  void scalarmult5 () {
    writeln("scalarmult5");
    static immutable ubyte[32] alicesk = [
     0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d
    ,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45
    ,0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a
    ,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a
    ];

    static immutable ubyte[32] bobpk = [
     0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4
    ,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37
    ,0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d
    ,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f
    ];

    ubyte[32] k;

    static immutable ubyte[32] res = [
     0x4a,0x5d,0x9d,0x5b,0xa4,0xce,0x2d,0xe1
    ,0x72,0x8e,0x3b,0xf4,0x80,0x35,0x0f,0x25
    ,0xe0,0x7e,0x21,0xc9,0x47,0xd1,0x9e,0x33
    ,0x76,0xf0,0x9b,0x3c,0x1e,0x16,0x17,0x42
    ];

    crypto_scalarmult(k, alicesk, bobpk);
    assert(k == res);
  }
  scalarmult5();

  void scalarmult6 () {
    writeln("scalarmult6");
    static immutable ubyte[32] bobsk = [
     0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b
    ,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6
    ,0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd
    ,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb
    ];

    static immutable ubyte[32] alicepk = [
     0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54
    ,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a
    ,0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4
    ,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a
    ];

    ubyte[32] k;

    static immutable ubyte[32] res = [
     0x4a,0x5d,0x9d,0x5b,0xa4,0xce,0x2d,0xe1
    ,0x72,0x8e,0x3b,0xf4,0x80,0x35,0x0f,0x25
    ,0xe0,0x7e,0x21,0xc9,0x47,0xd1,0x9e,0x33
    ,0x76,0xf0,0x9b,0x3c,0x1e,0x16,0x17,0x42
    ];

    crypto_scalarmult(k, bobsk, alicepk);
    assert(k == res);
  }
  scalarmult6();

  void secretbox () {
    writeln("secretbox");
    static immutable ubyte[32] firstkey = [
     0x1b,0x27,0x55,0x64,0x73,0xe9,0x85,0xd4
    ,0x62,0xcd,0x51,0x19,0x7a,0x9a,0x46,0xc7
    ,0x60,0x09,0x54,0x9e,0xac,0x64,0x74,0xf2
    ,0x06,0xc4,0xee,0x08,0x44,0xf6,0x83,0x89
    ];

    static immutable ubyte[24] nonce = [
     0x69,0x69,0x6e,0xe9,0x55,0xb6,0x2b,0x73
    ,0xcd,0x62,0xbd,0xa8,0x75,0xfc,0x73,0xd6
    ,0x82,0x19,0xe0,0x03,0x6b,0x7a,0x0b,0x37
    ];

    // API requires first 32 bytes to be 0
    static immutable ubyte[163] m = [
        0,   0,   0,   0,   0,   0,   0,   0
    ,   0,   0,   0,   0,   0,   0,   0,   0
    ,   0,   0,   0,   0,   0,   0,   0,   0
    ,   0,   0,   0,   0,   0,   0,   0,   0
    ,0xbe,0x07,0x5f,0xc5,0x3c,0x81,0xf2,0xd5
    ,0xcf,0x14,0x13,0x16,0xeb,0xeb,0x0c,0x7b
    ,0x52,0x28,0xc5,0x2a,0x4c,0x62,0xcb,0xd4
    ,0x4b,0x66,0x84,0x9b,0x64,0x24,0x4f,0xfc
    ,0xe5,0xec,0xba,0xaf,0x33,0xbd,0x75,0x1a
    ,0x1a,0xc7,0x28,0xd4,0x5e,0x6c,0x61,0x29
    ,0x6c,0xdc,0x3c,0x01,0x23,0x35,0x61,0xf4
    ,0x1d,0xb6,0x6c,0xce,0x31,0x4a,0xdb,0x31
    ,0x0e,0x3b,0xe8,0x25,0x0c,0x46,0xf0,0x6d
    ,0xce,0xea,0x3a,0x7f,0xa1,0x34,0x80,0x57
    ,0xe2,0xf6,0x55,0x6a,0xd6,0xb1,0x31,0x8a
    ,0x02,0x4a,0x83,0x8f,0x21,0xaf,0x1f,0xde
    ,0x04,0x89,0x77,0xeb,0x48,0xf5,0x9f,0xfd
    ,0x49,0x24,0xca,0x1c,0x60,0x90,0x2e,0x52
    ,0xf0,0xa0,0x89,0xbc,0x76,0x89,0x70,0x40
    ,0xe0,0x82,0xf9,0x37,0x76,0x38,0x48,0x64
    ,0x5e,0x07,0x05
    ];

    static immutable ubyte[163] res = [
     0xf3,0xff,0xc7,0x70,0x3f,0x94,0x00,0xe5
    ,0x2a,0x7d,0xfb,0x4b,0x3d,0x33,0x05,0xd9
    ,0x8e,0x99,0x3b,0x9f,0x48,0x68,0x12,0x73
    ,0xc2,0x96,0x50,0xba,0x32,0xfc,0x76,0xce
    ,0x48,0x33,0x2e,0xa7,0x16,0x4d,0x96,0xa4
    ,0x47,0x6f,0xb8,0xc5,0x31,0xa1,0x18,0x6a
    ,0xc0,0xdf,0xc1,0x7c,0x98,0xdc,0xe8,0x7b
    ,0x4d,0xa7,0xf0,0x11,0xec,0x48,0xc9,0x72
    ,0x71,0xd2,0xc2,0x0f,0x9b,0x92,0x8f,0xe2
    ,0x27,0x0d,0x6f,0xb8,0x63,0xd5,0x17,0x38
    ,0xb4,0x8e,0xee,0xe3,0x14,0xa7,0xcc,0x8a
    ,0xb9,0x32,0x16,0x45,0x48,0xe5,0x26,0xae
    ,0x90,0x22,0x43,0x68,0x51,0x7a,0xcf,0xea
    ,0xbd,0x6b,0xb3,0x73,0x2b,0xc0,0xe9,0xda
    ,0x99,0x83,0x2b,0x61,0xca,0x01,0xb6,0xde
    ,0x56,0x24,0x4a,0x9e,0x88,0xd5,0xf9,0xb3
    ,0x79,0x73,0xf6,0x22,0xa4,0x3d,0x14,0xa6
    ,0x59,0x9b,0x1f,0x65,0x4c,0xb4,0x5a,0x74
    ,0xe3,0x55,0xa5
    ];

    ubyte[163] c;
    crypto_secretbox(c, m, nonce, firstkey);
    for (auto i = 16; i < 163; ++i) assert(c[i] == res[i-16]);
  }
  secretbox();

  void secretbox2 () {
    writeln("secretbox2");
    static immutable ubyte[32] firstkey = [
     0x1b,0x27,0x55,0x64,0x73,0xe9,0x85,0xd4
    ,0x62,0xcd,0x51,0x19,0x7a,0x9a,0x46,0xc7
    ,0x60,0x09,0x54,0x9e,0xac,0x64,0x74,0xf2
    ,0x06,0xc4,0xee,0x08,0x44,0xf6,0x83,0x89
    ];

    static immutable ubyte[24] nonce = [
     0x69,0x69,0x6e,0xe9,0x55,0xb6,0x2b,0x73
    ,0xcd,0x62,0xbd,0xa8,0x75,0xfc,0x73,0xd6
    ,0x82,0x19,0xe0,0x03,0x6b,0x7a,0x0b,0x37
    ];

    // API requires first 16 bytes to be 0
    static immutable ubyte[163] c = [
        0,   0,   0,   0,   0,   0,   0,   0
    ,   0,   0,   0,   0,   0,   0,   0,   0
    ,0xf3,0xff,0xc7,0x70,0x3f,0x94,0x00,0xe5
    ,0x2a,0x7d,0xfb,0x4b,0x3d,0x33,0x05,0xd9
    ,0x8e,0x99,0x3b,0x9f,0x48,0x68,0x12,0x73
    ,0xc2,0x96,0x50,0xba,0x32,0xfc,0x76,0xce
    ,0x48,0x33,0x2e,0xa7,0x16,0x4d,0x96,0xa4
    ,0x47,0x6f,0xb8,0xc5,0x31,0xa1,0x18,0x6a
    ,0xc0,0xdf,0xc1,0x7c,0x98,0xdc,0xe8,0x7b
    ,0x4d,0xa7,0xf0,0x11,0xec,0x48,0xc9,0x72
    ,0x71,0xd2,0xc2,0x0f,0x9b,0x92,0x8f,0xe2
    ,0x27,0x0d,0x6f,0xb8,0x63,0xd5,0x17,0x38
    ,0xb4,0x8e,0xee,0xe3,0x14,0xa7,0xcc,0x8a
    ,0xb9,0x32,0x16,0x45,0x48,0xe5,0x26,0xae
    ,0x90,0x22,0x43,0x68,0x51,0x7a,0xcf,0xea
    ,0xbd,0x6b,0xb3,0x73,0x2b,0xc0,0xe9,0xda
    ,0x99,0x83,0x2b,0x61,0xca,0x01,0xb6,0xde
    ,0x56,0x24,0x4a,0x9e,0x88,0xd5,0xf9,0xb3
    ,0x79,0x73,0xf6,0x22,0xa4,0x3d,0x14,0xa6
    ,0x59,0x9b,0x1f,0x65,0x4c,0xb4,0x5a,0x74
    ,0xe3,0x55,0xa5
    ];

    static immutable ubyte[163] res = [
     0xbe,0x07,0x5f,0xc5,0x3c,0x81,0xf2,0xd5
    ,0xcf,0x14,0x13,0x16,0xeb,0xeb,0x0c,0x7b
    ,0x52,0x28,0xc5,0x2a,0x4c,0x62,0xcb,0xd4
    ,0x4b,0x66,0x84,0x9b,0x64,0x24,0x4f,0xfc
    ,0xe5,0xec,0xba,0xaf,0x33,0xbd,0x75,0x1a
    ,0x1a,0xc7,0x28,0xd4,0x5e,0x6c,0x61,0x29
    ,0x6c,0xdc,0x3c,0x01,0x23,0x35,0x61,0xf4
    ,0x1d,0xb6,0x6c,0xce,0x31,0x4a,0xdb,0x31
    ,0x0e,0x3b,0xe8,0x25,0x0c,0x46,0xf0,0x6d
    ,0xce,0xea,0x3a,0x7f,0xa1,0x34,0x80,0x57
    ,0xe2,0xf6,0x55,0x6a,0xd6,0xb1,0x31,0x8a
    ,0x02,0x4a,0x83,0x8f,0x21,0xaf,0x1f,0xde
    ,0x04,0x89,0x77,0xeb,0x48,0xf5,0x9f,0xfd
    ,0x49,0x24,0xca,0x1c,0x60,0x90,0x2e,0x52
    ,0xf0,0xa0,0x89,0xbc,0x76,0x89,0x70,0x40
    ,0xe0,0x82,0xf9,0x37,0x76,0x38,0x48,0x64
    ,0x5e,0x07,0x05
    ];

    ubyte[163] m;

    assert(crypto_secretbox_open(m, c, nonce, firstkey));
    for (auto i = 32; i < 163; ++i) assert(m[i] == res[i-32]);
  }
  secretbox2();

  void secretbox7 () {
    writeln("secretbox7");
    static ubyte[crypto_secretbox_KEYBYTES] k;
    static ubyte[crypto_secretbox_NONCEBYTES] n;
    static ubyte[10000] m, c, m2;
    for (auto mlen = 0; mlen < 1000 && mlen+crypto_secretbox_ZEROBYTES < m.length; ++mlen) {
      randombytes(k[0..crypto_secretbox_KEYBYTES]);
      randombytes(n[0..crypto_secretbox_NONCEBYTES]);
      randombytes(m[crypto_secretbox_ZEROBYTES..crypto_secretbox_ZEROBYTES+mlen]);
      crypto_secretbox(c[0..mlen+crypto_secretbox_ZEROBYTES], m[0..crypto_secretbox_ZEROBYTES+mlen], n, k);
      assert(crypto_secretbox_open(m2[0..mlen+crypto_secretbox_ZEROBYTES], c[0..mlen+crypto_secretbox_ZEROBYTES], n, k));
      for (auto i = 0; i < mlen+crypto_secretbox_ZEROBYTES; ++i) assert(m2[i] == m[i]);
    }
  }
  secretbox7();

  void secretbox8 () {
    writeln("secretbox8");
    static ubyte[crypto_secretbox_KEYBYTES] k;
    static ubyte[crypto_secretbox_NONCEBYTES] n;
    static ubyte[10000] m, c, m2;
    for (auto mlen = 0; mlen < 1000 && mlen+crypto_secretbox_ZEROBYTES < m.length; ++mlen) {
      randombytes(k[0..crypto_secretbox_KEYBYTES]);
      randombytes(n[0..crypto_secretbox_NONCEBYTES]);
      randombytes(m[crypto_secretbox_ZEROBYTES..crypto_secretbox_ZEROBYTES+mlen]);
      crypto_secretbox(c[0..mlen+crypto_secretbox_ZEROBYTES], m, n, k);
      auto caught = 0;
      while (caught < 10) {
        import std.random : uniform;
        c[uniform(0, mlen+crypto_secretbox_ZEROBYTES)] = cast(ubyte)uniform(0, 256);
        if (crypto_secretbox_open(m2[0..mlen+crypto_secretbox_ZEROBYTES], c, n, k)) {
          for (auto i = 0; i < mlen+crypto_secretbox_ZEROBYTES; ++i) assert(m2[i] == m[i]);
        }
        ++caught;
      }
      assert(caught == 10);
    }
  }
  version(unittest_full) secretbox8(); // it's slow

  void stream () {
    writeln("stream");
    static immutable ubyte[32] firstkey = [
     0x1b,0x27,0x55,0x64,0x73,0xe9,0x85,0xd4
    ,0x62,0xcd,0x51,0x19,0x7a,0x9a,0x46,0xc7
    ,0x60,0x09,0x54,0x9e,0xac,0x64,0x74,0xf2
    ,0x06,0xc4,0xee,0x08,0x44,0xf6,0x83,0x89
    ];

    static immutable ubyte[24] nonce = [
     0x69,0x69,0x6e,0xe9,0x55,0xb6,0x2b,0x73
    ,0xcd,0x62,0xbd,0xa8,0x75,0xfc,0x73,0xd6
    ,0x82,0x19,0xe0,0x03,0x6b,0x7a,0x0b,0x37
    ];

    static ubyte[4194304] output;

    //ubyte h[32];
    //static immutable ubyte[32] res = [0x66,0x2b,0x9d,0x0e,0x34,0x63,0x02,0x91,0x56,0x06,0x9b,0x12,0xf9,0x18,0x69,0x1a,0x98,0xf7,0xdf,0xb2,0xca,0x03,0x93,0xc9,0x6b,0xbf,0xc6,0xb1,0xfb,0xd6,0x30,0xa2];

    crypto_stream(output, nonce, firstkey);
    //crypto_hash_sha256(h, output, sizeof output);
    assert(hashToString(SHA256(output[0..$])) == "662b9d0e3463029156069b12f918691a98f7dfb2ca0393c96bbfc6b1fbd630a2");
  }
  stream();

  void stream2 () {
    writeln("stream2");
    static immutable ubyte[32] secondkey = [
     0xdc,0x90,0x8d,0xda,0x0b,0x93,0x44,0xa9
    ,0x53,0x62,0x9b,0x73,0x38,0x20,0x77,0x88
    ,0x80,0xf3,0xce,0xb4,0x21,0xbb,0x61,0xb9
    ,0x1c,0xbd,0x4c,0x3e,0x66,0x25,0x6c,0xe4
    ];

    static immutable ubyte[8] noncesuffix = [
     0x82,0x19,0xe0,0x03,0x6b,0x7a,0x0b,0x37
    ];

    static ubyte[4194304] output;

    crypto_stream_salsa20(output,noncesuffix,secondkey);
    assert(hashToString(SHA256(output[0..$])) == "662b9d0e3463029156069b12f918691a98f7dfb2ca0393c96bbfc6b1fbd630a2");
  }
  stream2();

  void stream3 () {
    writeln("stream3");
    static immutable ubyte[32] firstkey = [
     0x1b,0x27,0x55,0x64,0x73,0xe9,0x85,0xd4
    ,0x62,0xcd,0x51,0x19,0x7a,0x9a,0x46,0xc7
    ,0x60,0x09,0x54,0x9e,0xac,0x64,0x74,0xf2
    ,0x06,0xc4,0xee,0x08,0x44,0xf6,0x83,0x89
    ];

    static immutable ubyte[24] nonce = [
     0x69,0x69,0x6e,0xe9,0x55,0xb6,0x2b,0x73
    ,0xcd,0x62,0xbd,0xa8,0x75,0xfc,0x73,0xd6
    ,0x82,0x19,0xe0,0x03,0x6b,0x7a,0x0b,0x37
    ];

    ubyte[32] rs;

    static immutable ubyte[32] res = [
     0xee,0xa6,0xa7,0x25,0x1c,0x1e,0x72,0x91
    ,0x6d,0x11,0xc2,0xcb,0x21,0x4d,0x3c,0x25
    ,0x25,0x39,0x12,0x1d,0x8e,0x23,0x4e,0x65
    ,0x2d,0x65,0x1f,0xa4,0xc8,0xcf,0xf8,0x80
    ];

    crypto_stream/*_xsalsa20*/(rs, nonce, firstkey);
    assert(rs == res);
  }
  stream3();

  void stream4 () {
    writeln("stream4");
    static immutable ubyte[32] firstkey = [
     0x1b,0x27,0x55,0x64,0x73,0xe9,0x85,0xd4
    ,0x62,0xcd,0x51,0x19,0x7a,0x9a,0x46,0xc7
    ,0x60,0x09,0x54,0x9e,0xac,0x64,0x74,0xf2
    ,0x06,0xc4,0xee,0x08,0x44,0xf6,0x83,0x89
    ];

    static immutable ubyte[24] nonce = [
     0x69,0x69,0x6e,0xe9,0x55,0xb6,0x2b,0x73
    ,0xcd,0x62,0xbd,0xa8,0x75,0xfc,0x73,0xd6
    ,0x82,0x19,0xe0,0x03,0x6b,0x7a,0x0b,0x37
    ];

    static immutable ubyte[163] m = [
        0,   0,   0,   0,   0,   0,   0,   0
    ,   0,   0,   0,   0,   0,   0,   0,   0
    ,   0,   0,   0,   0,   0,   0,   0,   0
    ,   0,   0,   0,   0,   0,   0,   0,   0
    ,0xbe,0x07,0x5f,0xc5,0x3c,0x81,0xf2,0xd5
    ,0xcf,0x14,0x13,0x16,0xeb,0xeb,0x0c,0x7b
    ,0x52,0x28,0xc5,0x2a,0x4c,0x62,0xcb,0xd4
    ,0x4b,0x66,0x84,0x9b,0x64,0x24,0x4f,0xfc
    ,0xe5,0xec,0xba,0xaf,0x33,0xbd,0x75,0x1a
    ,0x1a,0xc7,0x28,0xd4,0x5e,0x6c,0x61,0x29
    ,0x6c,0xdc,0x3c,0x01,0x23,0x35,0x61,0xf4
    ,0x1d,0xb6,0x6c,0xce,0x31,0x4a,0xdb,0x31
    ,0x0e,0x3b,0xe8,0x25,0x0c,0x46,0xf0,0x6d
    ,0xce,0xea,0x3a,0x7f,0xa1,0x34,0x80,0x57
    ,0xe2,0xf6,0x55,0x6a,0xd6,0xb1,0x31,0x8a
    ,0x02,0x4a,0x83,0x8f,0x21,0xaf,0x1f,0xde
    ,0x04,0x89,0x77,0xeb,0x48,0xf5,0x9f,0xfd
    ,0x49,0x24,0xca,0x1c,0x60,0x90,0x2e,0x52
    ,0xf0,0xa0,0x89,0xbc,0x76,0x89,0x70,0x40
    ,0xe0,0x82,0xf9,0x37,0x76,0x38,0x48,0x64
    ,0x5e,0x07,0x05
    ];

    ubyte[163] c;

    static immutable ubyte[163] res = [
     0x8e,0x99,0x3b,0x9f,0x48,0x68,0x12,0x73
    ,0xc2,0x96,0x50,0xba,0x32,0xfc,0x76,0xce
    ,0x48,0x33,0x2e,0xa7,0x16,0x4d,0x96,0xa4
    ,0x47,0x6f,0xb8,0xc5,0x31,0xa1,0x18,0x6a
    ,0xc0,0xdf,0xc1,0x7c,0x98,0xdc,0xe8,0x7b
    ,0x4d,0xa7,0xf0,0x11,0xec,0x48,0xc9,0x72
    ,0x71,0xd2,0xc2,0x0f,0x9b,0x92,0x8f,0xe2
    ,0x27,0x0d,0x6f,0xb8,0x63,0xd5,0x17,0x38
    ,0xb4,0x8e,0xee,0xe3,0x14,0xa7,0xcc,0x8a
    ,0xb9,0x32,0x16,0x45,0x48,0xe5,0x26,0xae
    ,0x90,0x22,0x43,0x68,0x51,0x7a,0xcf,0xea
    ,0xbd,0x6b,0xb3,0x73,0x2b,0xc0,0xe9,0xda
    ,0x99,0x83,0x2b,0x61,0xca,0x01,0xb6,0xde
    ,0x56,0x24,0x4a,0x9e,0x88,0xd5,0xf9,0xb3
    ,0x79,0x73,0xf6,0x22,0xa4,0x3d,0x14,0xa6
    ,0x59,0x9b,0x1f,0x65,0x4c,0xb4,0x5a,0x74
    ,0xe3,0x55,0xa5
    ];

    /*crypto_stream_xsalsa20_xor*/crypto_stream_xor(c, m, nonce, firstkey);
    for (auto i = 32; i < 163; ++i) assert(c[i] == res[i-32]);
  }
  stream4();
}
